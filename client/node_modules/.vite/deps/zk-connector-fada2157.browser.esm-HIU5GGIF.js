import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  HttpRpcClient
} from "./chunk-7WA2LFYP.js";
import {
  ENTRYPOINT_ADDRESS,
  isZkSyncChain,
  require_dist as require_dist4
} from "./chunk-J7AYA5NI.js";
import {
  Connector
} from "./chunk-BJ3Q2M2N.js";
import "./chunk-4MMI5T6E.js";
import {
  _defineProperty
} from "./chunk-7YQW7K4V.js";
import "./chunk-QU2H4SD2.js";
import "./chunk-5Y4RQ6D5.js";
import "./chunk-GUSRGUBP.js";
import "./chunk-LNZJK5RN.js";
import "./chunk-XN7Z4YSU.js";
import "./chunk-XMSXM2E4.js";
import "./chunk-U4XESRYZ.js";
import "./chunk-CAWHCWPV.js";
import "./chunk-BL4VSW2C.js";
import "./chunk-7QDYPHE5.js";
import "./chunk-T7SU3EOS.js";
import "./chunk-RHGXPIYU.js";
import "./chunk-HYWBSNOJ.js";
import "./chunk-4ZVJN6FY.js";
import "./chunk-AW5SWZJE.js";
import "./chunk-RYFD5FY6.js";
import "./chunk-STA435HD.js";
import "./chunk-DFC6BI5N.js";
import "./chunk-3376PJ73.js";
import "./chunk-YPYICWYD.js";
import "./chunk-U6IJB3QF.js";
import "./chunk-LMJC2RD2.js";
import "./chunk-4K65M2LO.js";
import "./chunk-IMPEKHNI.js";
import "./chunk-YRREQA3W.js";
import "./chunk-ZZ56NLTE.js";
import "./chunk-CG33N7WG.js";
import "./chunk-ENLC2GGB.js";
import "./chunk-AO5YUUGU.js";
import "./chunk-GXMHMEEO.js";
import "./chunk-4WUEILHN.js";
import "./chunk-ZSYQ5PGN.js";
import "./chunk-D6ZRKGHM.js";
import "./chunk-XDXECFPF.js";
import "./chunk-YOGJGII4.js";
import "./chunk-7PBDWUZZ.js";
import "./chunk-KQT2DMC7.js";
import "./chunk-VSMNETTA.js";
import "./chunk-IAOBFAKY.js";
import "./chunk-YTCBHIZC.js";
import "./chunk-H6LS4AKV.js";
import "./chunk-ZEON4SY2.js";
import "./chunk-5TF2ZDVM.js";
import "./chunk-COLQIUNX.js";
import "./chunk-2PW66HIP.js";
import "./chunk-YPNI3TBW.js";
import {
  require_utils
} from "./chunk-43DMFY6L.js";
import "./chunk-2GDUVVK5.js";
import "./chunk-C347233M.js";
import "./chunk-VE5YG2UP.js";
import "./chunk-57UGKABR.js";
import "./chunk-ECNDAD33.js";
import "./chunk-VA6DT6HZ.js";
import "./chunk-GYWPTUR7.js";
import "./chunk-UPLMOH3U.js";
import "./chunk-WY46RIEA.js";
import "./chunk-FUT2NW4P.js";
import "./chunk-43OABXJU.js";
import {
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4357AYQK.js";
import {
  BigNumber,
  Signer
} from "./chunk-5UPRJSZY.js";
import "./chunk-ZKAAZOGS.js";
import "./chunk-OKK22FPZ.js";
import "./chunk-4K5QQUIR.js";
import "./chunk-OWJUH5G2.js";
import "./chunk-46FQ3G72.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/wallets/dist/zk-connector-fada2157.browser.esm.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
init_lib();
var import_utils = __toESM(require_utils());
var import_contracts = __toESM(require_dist4());
var DEFAULT_GAS_PER_PUBDATA_LIMIT = 5e4;
var EIP712_TX_TYPE = 113;
var EIP712_TYPES = {
  Transaction: [{
    name: "txType",
    type: "uint256"
  }, {
    name: "from",
    type: "uint256"
  }, {
    name: "to",
    type: "uint256"
  }, {
    name: "gasLimit",
    type: "uint256"
  }, {
    name: "gasPerPubdataByteLimit",
    type: "uint256"
  }, {
    name: "maxFeePerGas",
    type: "uint256"
  }, {
    name: "maxPriorityFeePerGas",
    type: "uint256"
  }, {
    name: "paymaster",
    type: "uint256"
  }, {
    name: "nonce",
    type: "uint256"
  }, {
    name: "value",
    type: "uint256"
  }, {
    name: "data",
    type: "bytes"
  }, {
    name: "factoryDeps",
    type: "bytes32[]"
  }, {
    name: "paymasterInput",
    type: "bytes"
  }]
};
var ZkWrappedSigner = class _ZkWrappedSigner extends Signer {
  constructor(signer, httpRpcClient) {
    super();
    this.signer = signer;
    (0, import_utils.defineReadOnly)(this, "provider", signer.provider);
    this.httpRpcClient = httpRpcClient;
  }
  async getAddress() {
    return await this.signer.getAddress();
  }
  async signMessage(message) {
    return await this.signer.signMessage(message);
  }
  async signTransaction(transaction) {
    return await this.signer.signTransaction(transaction);
  }
  connect(provider) {
    return new _ZkWrappedSigner(this.signer.connect(provider), this.httpRpcClient);
  }
  _signTypedData(domain, types, value) {
    return this.signer._signTypedData(domain, types, value);
  }
  async sendTransaction(transaction) {
    return await this.sendZkSyncTransaction(transaction);
  }
  async sendZkSyncTransaction(_transaction) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let transaction = await this.populateTransaction(_transaction);
    if (!transaction.chainId) {
      throw new Error("ChainId is required to send a ZkSync transaction");
    }
    if (!this.provider) {
      throw new Error("Provider is required to send a ZkSync transaction");
    }
    const address = await this.getAddress();
    const gasLimit = ethers_exports.BigNumber.from(transaction.gasLimit || await this.provider.estimateGas(transaction)).mul(3);
    const gasPrice = ethers_exports.BigNumber.from(transaction.gasPrice || await this.provider.getGasPrice()).mul(2);
    if (!transaction.maxFeePerGas) {
      transaction.maxFeePerGas = gasPrice;
    } else {
      transaction.maxFeePerGas = transaction.maxFeePerGas.mul(2);
    }
    if (!transaction.maxPriorityFeePerGas) {
      transaction.maxPriorityFeePerGas = gasPrice;
    } else {
      transaction.maxPriorityFeePerGas = transaction.maxPriorityFeePerGas.mul(2);
    }
    transaction = {
      ...transaction,
      from: address,
      gasLimit,
      gasPrice,
      chainId: (await this.provider.getNetwork()).chainId,
      nonce: await this.provider.getTransactionCount(address),
      type: 113,
      value: BigInt(0)
    };
    const pmDataResult = await ((_a = this.httpRpcClient) == null ? void 0 : _a.zkPaymasterData(transaction));
    transaction.customData = {
      gasPerPubdata: DEFAULT_GAS_PER_PUBDATA_LIMIT,
      factoryDeps: [],
      paymasterParams: {
        paymaster: pmDataResult.paymaster,
        paymasterInput: pmDataResult.paymasterInput
      }
    };
    const eip712tx = {
      txType: EIP712_TX_TYPE,
      from: BigInt(transaction.from || await this.getAddress()).toString(),
      to: BigInt(transaction.to || "0x0").toString(),
      gasLimit: transaction.gasLimit ? Number(transaction.gasLimit) : 0,
      gasPerPubdataByteLimit: DEFAULT_GAS_PER_PUBDATA_LIMIT,
      maxFeePerGas: ethers_exports.BigNumber.from(transaction.maxFeePerGas).toNumber(),
      maxPriorityFeePerGas: ethers_exports.BigNumber.from(transaction.maxPriorityFeePerGas).toNumber(),
      paymaster: BigInt(pmDataResult.paymaster).toString(),
      nonce: ethers_exports.BigNumber.from(transaction.nonce).toNumber(),
      value: ethers_exports.BigNumber.from(transaction.value).toNumber(),
      data: transaction.data || "0x",
      factoryDeps: [],
      paymasterInput: ethers_exports.utils.arrayify(pmDataResult.paymasterInput)
    };
    const signature = await this._signTypedData({
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    }, EIP712_TYPES, eip712tx);
    const serializedTx = this.serialize(transaction, signature);
    const zkSignedTx = {
      from: ((_b = transaction.from) == null ? void 0 : _b.toString()) || await this.getAddress(),
      to: ((_c = transaction.to) == null ? void 0 : _c.toString()) || "",
      gas: ((_d = transaction.gasLimit) == null ? void 0 : _d.toString()) || "",
      maxFeePerGas: ((_e = transaction.maxFeePerGas) == null ? void 0 : _e.toString()) || "0",
      maxPriorityFeePerGas: ((_f = transaction.maxPriorityFeePerGas) == null ? void 0 : _f.toString()) || "0",
      signedTransaction: serializedTx,
      paymaster: pmDataResult.paymaster
    };
    const broadcastResult = await ((_g = this.httpRpcClient) == null ? void 0 : _g.zkBroadcastTransaction(zkSignedTx));
    const hash = broadcastResult.transactionHash;
    return await ((_h = this.provider) == null ? void 0 : _h.getTransaction(hash));
  }
  serialize(transaction, signature) {
    if (!transaction.customData && transaction.type !== EIP712_TX_TYPE) {
      return utils_exports.serializeTransaction(transaction, signature);
    }
    if (!transaction.chainId) {
      throw Error("Transaction chainId isn't set!");
    }
    function formatNumber(value, name) {
      const result = utils_exports.stripZeros(BigNumber.from(value).toHexString());
      if (result.length > 32) {
        throw new Error(`Invalid length for ${name}!`);
      }
      return result;
    }
    if (!transaction.from) {
      throw new Error("Explicitly providing `from` field is required for EIP712 transactions!");
    }
    const from = transaction.from;
    const meta = transaction.customData ?? {};
    const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;
    const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
    const fields = [formatNumber(transaction.nonce || 0, "nonce"), formatNumber(maxPriorityFeePerGas, "maxPriorityFeePerGas"), formatNumber(maxFeePerGas, "maxFeePerGas"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to ? utils_exports.getAddress(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x"];
    if (signature) {
      const sig = utils_exports.splitSignature(signature);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push(utils_exports.stripZeros(sig.r));
      fields.push(utils_exports.stripZeros(sig.s));
    } else {
      fields.push(formatNumber(transaction.chainId, "chainId"));
      fields.push("0x");
      fields.push("0x");
    }
    fields.push(formatNumber(transaction.chainId, "chainId"));
    fields.push(utils_exports.getAddress(from));
    fields.push(formatNumber(meta.gasPerPubdata || DEFAULT_GAS_PER_PUBDATA_LIMIT, "gasPerPubdata"));
    fields.push((meta.factoryDeps ?? []).map((dep) => utils_exports.hexlify(dep)));
    if (meta.customSignature && ethers_exports.utils.arrayify(meta.customSignature).length === 0) {
      throw new Error("Empty signatures are not supported!");
    }
    fields.push(meta.customSignature || "0x");
    if (meta.paymasterParams) {
      fields.push([meta.paymasterParams.paymaster, ethers_exports.utils.hexlify(meta.paymasterParams.paymasterInput)]);
    } else {
      fields.push([]);
    }
    return utils_exports.hexConcat([[EIP712_TX_TYPE], utils_exports.RLP.encode(fields)]);
  }
};
var ZkSyncConnector = class extends Connector {
  constructor(config) {
    super();
    _defineProperty(this, "chainId", 1);
    this.config = config;
  }
  async connect(args) {
    this.personalWallet = args.personalWallet;
    this.chainId = await (await this.personalWallet.getSigner()).getChainId();
    if (!await isZkSyncChain(this.chainId)) {
      throw new Error("Invalid zksync chain id");
    }
    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;
    const entryPointAddress = this.config.entryPointAddress || ENTRYPOINT_ADDRESS;
    this.httpRpcClient = new HttpRpcClient(bundlerUrl, entryPointAddress, this.chainId, this.config.clientId, this.config.secretKey);
    return this.getAddress();
  }
  disconnect() {
    throw new Error("Method not implemented.");
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async getSigner() {
    if (!this.personalWallet) {
      throw new Error("Wallet not connected");
    }
    return new ZkWrappedSigner(await this.personalWallet.getSigner(), this.httpRpcClient);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  switchChain(chainId) {
    throw new Error("Method not implemented.");
  }
  isConnected() {
    return Promise.resolve(!!this.personalWallet);
  }
  setupListeners() {
    throw new Error("Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateChains(chains) {
    throw new Error("Method not implemented.");
  }
  async getProvider() {
    if (!this.getSigner()) {
      throw new Error("Personal wallet not connected");
    }
    const signer = await this.getSigner();
    if (!signer.provider) {
      throw new Error("Provider not found");
    }
    return signer.provider;
  }
};
export {
  ZkSyncConnector
};
//# sourceMappingURL=zk-connector-fada2157.browser.esm-HIU5GGIF.js.map
