{
  "version": 3,
  "sources": ["../../buffer-reverse/index.js", "../../treeify/treeify.js"],
  "sourcesContent": ["module.exports = function reverse (src) {\n  var buffer = new Buffer(src.length)\n\n  for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n", "//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '└' : '├');\n    if (key) {\n      str += '─ ';\n    } else {\n      str += '──┐';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '│') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,QAAAA,eAAA;AAAA,QAAAA,eAAA;AAAA,WAAO,UAAU,SAAS,QAAS,KAAK;AACtC,UAAI,SAAS,IAAI,OAAO,IAAI,MAAM;AAElC,eAAS,IAAI,GAAG,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG,EAAE,GAAG;AACpD,eAAO,CAAC,IAAI,IAAI,CAAC;AACjB,eAAO,CAAC,IAAI,IAAI,CAAC;AAAA,MACnB;AAEA,aAAO;AAAA,IACT;AAAA;AAAA;;;ACTA;AAAA;AAAA;AAAA,QAAAC,eAAA;AAAA,QAAAA,eAAA;AAKA,KAAC,SAAU,MAAM,SAAS;AAExB,UAAI,OAAO,YAAY,UAAU;AAC/B,eAAO,UAAU,QAAQ;AAAA,MAC3B,WAAW,OAAO,WAAW,cAAc,OAAO,KAAK;AACrD,eAAO,OAAO;AAAA,MAChB,OAAO;AACL,aAAK,UAAU,QAAQ;AAAA,MACzB;AAAA,IAEF,GAAE,SAAM,WAAW;AAEjB,eAAS,WAAW,KAAK,MAAM;AAC7B,YAAI,MAAO,OAAO,MAAM;AACxB,YAAI,KAAK;AACP,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAEA,eAAS,WAAW,KAAK,eAAe;AACtC,YAAI,OAAO,CAAC;AACZ,iBAAS,UAAU,KAAK;AAEtB,cAAI,CAAC,IAAI,eAAe,MAAM,GAAG;AAC/B;AAAA,UACF;AAEA,cAAI,iBAAmB,OAAO,IAAI,MAAM,MAAK,YAAa;AACxD;AAAA,UACF;AACA,eAAK,KAAK,MAAM;AAAA,QAClB;AACA,eAAO;AAAA,MACT;AAEA,eAAS,WAAW,KAAK,MAAM,MAAM,YAAY,YAAY,eAAe,UAAU;AACpF,YAAI,OAAO,IAAI,QAAQ,GAAG,SAAS,UAAU,iBAAiB,WAAW,MAAM,CAAC;AAEhF,YAAI,eAAe,KAAK,CAAE,MAAM,IAAK,CAAC,KAAK,WAAW,SAAS,GAAG;AAGhE,qBAAW,QAAQ,SAAS,WAAW,KAAK;AAC1C,gBAAI,MAAM,GAAG;AACX,uBAAS,UAAU,CAAC,IAAI,MAAM,OAAO;AAAA,YACvC;AACA,gBAAK,CAAE,YAAY,UAAU,CAAC,MAAM,MAAM;AACxC,yBAAW;AAAA,YACb;AAAA,UACF,CAAC;AAID,kBAAQ,WAAW,KAAK,IAAI,IAAI;AAGhC,yBAAe,OAAO,SAAS,YAAY,gBAAgB,UAAU,QAAQ,OAAO;AACpF,uBAAa,QAAQ;AAErB,mBAAS,IAAI;AAAA,QACf;AAGA,YAAK,CAAE,YAAY,OAAO,SAAS,UAAU;AAC3C,cAAI,OAAO,WAAW,MAAM,aAAa;AACzC,eAAK,QAAQ,SAAS,QAAO;AAE3B,sBAAU,EAAE,UAAU,KAAK;AAG3B,uBAAW,QAAQ,KAAK,MAAM,GAAG,SAAS,gBAAgB,YAAY,eAAe,QAAQ;AAAA,UAC/F,CAAC;AAAA,QACH;AAAA,MACF;AAAC;AAID,UAAI,UAAU,CAAC;AAMf,cAAQ,UAAU,SAAS,KAAK,YAAY,eAAe,cAAc;AAEvE,YAAI,mBAAmB,OAAO,kBAAkB,aAAa,gBAAgB;AAC7E,mBAAW,KAAK,KAAK,OAAO,CAAC,GAAG,YAAY,kBAAkB,gBAAgB,aAAa;AAAA,MAC7F;AAMA,cAAQ,SAAS,SAAS,KAAK,YAAY,eAAe;AACxD,YAAI,OAAO;AACX,mBAAW,KAAK,KAAK,OAAO,CAAC,GAAG,YAAY,eAAe,SAAS,MAAM;AACxE,kBAAQ,OAAO;AAAA,QACjB,CAAC;AACD,eAAO;AAAA,MACT;AAIA,aAAO;AAAA,IAET,CAAC;AAAA;AAAA;",
  "names": ["import_dist", "import_dist"]
}
