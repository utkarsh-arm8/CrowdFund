{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/rpc.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/src/chains/utils.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/src/utils/promise/withCache.ts", "../../@thirdweb-dev/sdk/node_modules/thirdweb/src/rpc/fetch-rpc.ts"],
  "sourcesContent": ["import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\n\nimport type { Chain } from \"../chains/types.js\";\nimport { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { type RpcRequest, fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\n\nconst RPC_CLIENT_MAP = new WeakMap();\n\n/**\n * @internal\n */\nfunction getRpcClientMap(client: ThirdwebClient) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n\n/**\n * @internal\n */\nfunction rpcRequestKey(request: RpcRequest): string {\n  return `${request.method}:${JSON.stringify(request.params)}`;\n}\n\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n\ntype RPCOptions = Readonly<{\n  client: ThirdwebClient;\n  chain: Chain;\n  config?: {\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    requestTimeoutMs?: number;\n  };\n}>;\n\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(\n  options: RPCOptions,\n): EIP1193RequestFn<EIP1474Methods> {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const chainId = options.chain.id;\n\n  if (rpcClientMap.has(options.chain.rpc)) {\n    return rpcClientMap.get(\n      options.chain.rpc,\n    ) as EIP1193RequestFn<EIP1474Methods>;\n  }\n\n  const rpcClient: EIP1193RequestFn<EIP1474Methods> = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      client: options.client,\n      chain: options.chain,\n    });\n\n    const batchSize =\n      // look at the direct options passed\n      options.config?.maxBatchSize ??\n      // look at the client options\n      options.client.config?.rpc?.maxBatchSize ??\n      // use defaults\n      DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n      // look at the direct options passed\n      options.config?.batchTimeoutMs ??\n      // look at the client options\n      options.client.config?.rpc?.batchTimeoutMs ??\n      DEFAULT_BATCH_TIMEOUT_MS;\n\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map<string, Promise<any>>();\n\n    let pendingBatch: Array<{\n      request: {\n        method: string;\n        params: unknown[];\n        id: number;\n        jsonrpc: \"2.0\";\n      };\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      reject: (reason?: any) => void;\n      requestKey: string;\n    }> = [];\n    let pendingBatchTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assing the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs,\n      })\n        .then((responses) => {\n          // for each response, resolve the inflight request\n          activeBatch.forEach((inflight, index) => {\n            const response = responses[index];\n            // if we didn't get a response at all, reject the inflight request\n            if (!response) {\n              inflight.reject(new Error(\"No response\"));\n              return;\n            }\n            // handle errors in the response\n            if (response instanceof Error) {\n              inflight.reject(response);\n              return;\n            }\n\n            // handle strings as responses??\n            if (typeof response === \"string\") {\n              inflight.reject(new Error(response));\n              return;\n            }\n\n            if (\"error\" in response) {\n              inflight.reject(response.error);\n              // otherwise, resolve the inflight request\n            } else if (response.method === \"eth_subscription\") {\n              // TODO: handle subscription responses\n              throw new Error(\"Subscriptions not supported yet\");\n            } else {\n              inflight.resolve(response.result);\n            }\n            // remove the inflight request from the inflightRequests map\n            inflightRequests.delete(inflight.requestKey);\n          });\n        })\n        .catch((err) => {\n          // http call failed, reject all inflight requests\n          for (const inflight of activeBatch) {\n            inflight.reject(err);\n            // remove the inflight request from the inflightRequests map\n            inflightRequests.delete(inflight.requestKey);\n          }\n        });\n    }\n\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async (request) => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs,\n        });\n\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n\n    return async (request) => {\n      const requestKey = rpcRequestKey(request);\n\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey)!;\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject: (reason?: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise<any>((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assgined within the promise constructor\n      pendingBatch.push({ request, resolve, reject, requestKey });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n\n  rpcClientMap.set(chainId, rpcClient);\n  return rpcClient as EIP1193RequestFn<EIP1474Methods>;\n}\n", "import type { Chain as ViemChain } from \"viem\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { DEFAULT_RPC_URL, getThirdwebDomains } from \"../utils/domains.js\";\nimport { isThirdwebUrl } from \"../utils/fetch.js\";\nimport { withCache } from \"../utils/promise/withCache.js\";\nimport type {\n  Chain,\n  ChainMetadata,\n  ChainOptions,\n  LegacyChain,\n} from \"./types.js\";\n\nconst CUSTOM_CHAIN_MAP = new Map<number, Chain>();\n\n/**\n * Defines a chain with the given options.\n * @param options The options for the chain.\n * @returns The defined chain.\n * @example\n * Just pass the chain ID to connect to:\n * ```ts\n * const chain = defineChain(1);\n * ```\n * Or pass your own RPC or custom values:\n * ```ts\n * const chain = defineChain({\n *  id: 1,\n *  rpc: \"https://my-rpc.com\",\n *  nativeCurrency: {\n *    name: \"Ether\",\n *    symbol: \"ETH\",\n *    decimals: 18,\n *  },\n * });\n * ```\n * @chain\n */\nexport function defineChain(\n  options: number | ChainOptions | ViemChain | LegacyChain,\n): Chain {\n  if (typeof options === \"number\") {\n    return {\n      id: options,\n      rpc: `https://${options}.rpc.thirdweb.com`,\n    } as const;\n  }\n  if (isViemChain(options)) {\n    return convertViemChain(options);\n  }\n  if (isLegacyChain(options)) {\n    return convertLegacyChain(options);\n  }\n  // otherwise if it's not a viem chain, continue\n  let rpc = options.rpc;\n  if (!rpc) {\n    rpc = `https://${options.id}.rpc.thirdweb.com`;\n  }\n  const chain = { ...options, rpc } as const;\n  CUSTOM_CHAIN_MAP.set(options.id, chain);\n  return chain;\n}\n\n/**\n * @internal\n */\nexport function getCachedChain(id: number) {\n  if (CUSTOM_CHAIN_MAP.has(id)) {\n    return CUSTOM_CHAIN_MAP.get(id) as Chain;\n  }\n  const chain = {\n    id: id,\n    rpc: `https://${id}.rpc.thirdweb.com`,\n  } as const;\n  return chain;\n}\n\nfunction isLegacyChain(\n  chain: ChainOptions | ViemChain | LegacyChain,\n): chain is LegacyChain {\n  return \"rpc\" in chain && Array.isArray(chain.rpc) && \"slug\" in chain;\n}\n\nfunction convertLegacyChain(legacyChain: LegacyChain): Chain {\n  const c: Chain = {\n    id: legacyChain.chainId,\n    name: legacyChain.name,\n    rpc:\n      legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.rpc.thirdweb.com`,\n    blockExplorers: legacyChain?.explorers?.map((explorer) => ({\n      name: explorer.name,\n      url: explorer.url,\n      apiUrl: explorer.url,\n    })),\n    nativeCurrency: {\n      name: legacyChain.nativeCurrency.name,\n      symbol: legacyChain.nativeCurrency.symbol,\n      decimals: legacyChain.nativeCurrency.decimals,\n    },\n  };\n  if (legacyChain.testnet) {\n    return { ...c, testnet: true };\n  }\n  return c;\n}\n\nfunction isViemChain(\n  chain: ChainOptions | ViemChain | LegacyChain,\n): chain is ViemChain {\n  return \"rpcUrls\" in chain && !(\"rpc\" in chain);\n}\n\nfunction convertViemChain(viemChain: ViemChain): Chain {\n  return defineChain({\n    id: viemChain.id,\n    name: viemChain.name,\n    nativeCurrency: {\n      name: viemChain.nativeCurrency.name,\n      symbol: viemChain.nativeCurrency.symbol,\n      decimals: viemChain.nativeCurrency.decimals,\n    },\n    rpc:\n      viemChain.rpcUrls.default.http[0] ??\n      `https://${viemChain.id}.rpc.thirdweb.com`,\n    blockExplorers: viemChain?.blockExplorers\n      ? Object.values(viemChain?.blockExplorers).map((explorer) => {\n          return {\n            name: explorer.name,\n            url: explorer.url,\n            apiUrl: explorer.apiUrl,\n          };\n        })\n      : [],\n  });\n}\n\ntype GetRpcUrlForChainOptions = {\n  client: ThirdwebClient;\n  chain: Chain | number;\n};\n\n/**\n * Retrieves the RPC URL for the specified chain.\n * If a custom RPC URL is defined in the options, it will be used.\n * Otherwise, a thirdweb RPC URL will be constructed using the chain ID and client ID.\n * @param options - The options object containing the chain and client information.\n * @returns The RPC URL for the specified chain.\n * @example\n * ```ts\n * import { getRpcUrlForChain } from \"thirdweb/chains\";\n * const rpcUrl = getRpcUrlForChain({ chain: 1, client });\n * console.log(rpcUrl); // \"https://1.rpc.thirdweb.com/...\n * ```\n * @chain\n */\nexport function getRpcUrlForChain(options: GetRpcUrlForChainOptions): string {\n  const baseRpcUrl = getThirdwebDomains().rpc;\n\n  // if the chain is just a number, construct the RPC URL using the chain ID and client ID\n  if (typeof options.chain === \"number\") {\n    return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;\n  }\n  const { rpc } = options.chain;\n\n  // add on the client ID to the RPC URL if it's a thirdweb URL\n  if (isThirdwebUrl(rpc)) {\n    const rpcUrl = new URL(\n      options.chain.rpc.replace(DEFAULT_RPC_URL, baseRpcUrl),\n    );\n    rpcUrl.pathname = `/${options.client.clientId}`;\n    return rpcUrl.toString();\n  }\n  return rpc;\n}\n\n/**\n * Retrieves the chain symbol from the provided chain.\n * @param chain - The chain.\n * @returns The chain symbol.\n * @internal\n */\nexport async function getChainSymbol(chain: Chain): Promise<string> {\n  if (!chain.nativeCurrency?.symbol) {\n    return getChainMetadata(chain)\n      .then((data) => data.nativeCurrency.symbol)\n      .catch(() => {\n        // if we fail to fetch the chain data, return \"ETH\" as a fallback\n        return \"ETH\";\n      });\n  }\n  // if we have a symbol, return it\n  return chain.nativeCurrency.symbol;\n}\n\n/**\n * Retrieves the number of decimals for the native currency of a given chain.\n * If the chain is not recognized or the data cannot be fetched, it returns a fallback value of 18.\n * @param chain - The chain for which to retrieve the decimals.\n * @returns A promise that resolves to the number of decimals for the native currency of the chain.\n * @internal\n */\nexport async function getChainDecimals(chain: Chain): Promise<number> {\n  if (!chain.nativeCurrency?.decimals) {\n    return getChainMetadata(chain)\n      .then((data) => data.nativeCurrency.decimals)\n      .catch(() => {\n        // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n        return 18;\n      });\n  }\n  // if we have decimals, return it\n  return chain.nativeCurrency.decimals;\n}\n\n/**\n * Retrieves the name of the native currency for a given chain.\n * If the chain object does not have a native currency name, it attempts to fetch the chain data and retrieve the native currency name from there.\n * If fetching the chain data fails, it falls back to returning \"ETH\".\n * @param chain The chain object for which to retrieve the native currency name.\n * @returns A promise that resolves to the native currency name.\n * @internal\n */\nexport async function getChainNativeCurrencyName(\n  chain: Chain,\n): Promise<string> {\n  if (!chain.nativeCurrency?.name) {\n    return getChainMetadata(chain)\n      .then((data) => data.nativeCurrency.name)\n      .catch(() => {\n        // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)\n        return \"ETH\";\n      });\n  }\n  // if we have a name, return it\n  return chain.nativeCurrency.name;\n}\n\ntype FetchChainResponse =\n  | {\n      data: ChainMetadata;\n      error?: never;\n    }\n  | {\n      data?: never;\n      error: unknown;\n    };\n\n/**\n * Retrieves chain data for a given chain.\n * @param chain - The chain object containing the chain ID.\n * @returns A Promise that resolves to the chain data.\n * @throws If there is an error fetching the chain data.\n * @example\n * ```ts\n * const chain = defineChain({ id: 1 });\n * const chainData = await getChainMetadata(chain);\n * console.log(chainData);\n * ```\n * @chain\n */\nexport function getChainMetadata(chain: Chain): Promise<ChainMetadata> {\n  const chainId = chain.id;\n  return withCache(\n    async () => {\n      try {\n        const res = await fetch(\n          `https://api.thirdweb.com/v1/chains/${chainId}`,\n        );\n        if (!res.ok) {\n          res.body?.cancel();\n          throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n        }\n\n        const response = (await res.json()) as FetchChainResponse;\n        if (response.error) {\n          throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n        }\n        if (!response.data) {\n          throw new Error(`Failed to fetch chain data for chainId ${chainId}`);\n        }\n\n        const data = response.data;\n\n        return createChainMetadata(chain, data);\n      } catch {\n        return createChainMetadata(chain);\n      }\n    },\n    {\n      cacheKey: `chain:${chainId}`,\n      cacheTime: 5 * 60 * 1000, // 5 minutes\n    },\n  );\n}\n\n/**\n * Convert `ApiChain` to `Chain` object\n * @internal\n */\nexport function convertApiChainToChain(apiChain: ChainMetadata): Chain {\n  return {\n    id: apiChain.chainId,\n    name: apiChain.name,\n    rpc: apiChain.rpc[0] || \"\",\n    testnet: apiChain.testnet === true ? true : undefined,\n    nativeCurrency: apiChain.nativeCurrency,\n    blockExplorers: apiChain.explorers?.map((explorer) => {\n      return {\n        name: explorer.name,\n        url: explorer.url,\n        apiUrl: explorer.url,\n      };\n    }),\n  };\n}\n\nfunction createChainMetadata(\n  chain: Chain,\n  data?: ChainMetadata,\n): ChainMetadata {\n  const nativeCurrency = chain.nativeCurrency\n    ? {\n        ...data?.nativeCurrency,\n        ...chain.nativeCurrency,\n      }\n    : data?.nativeCurrency;\n\n  return {\n    ...data,\n    name: chain.name || data?.name || \"\",\n    chainId: chain.id || data?.chainId || -1,\n    rpc: chain.rpc ? [chain.rpc] : data?.rpc || [\"\"],\n    testnet: chain.testnet || data?.testnet || false,\n    nativeCurrency: {\n      name: nativeCurrency?.name || \"\",\n      symbol: nativeCurrency?.symbol || \"\",\n      decimals: nativeCurrency?.decimals || 18,\n    },\n    icon: chain.icon || data?.icon,\n    chain: data?.chain || chain.name || \"\",\n    shortName: data?.shortName || chain.name || \"\",\n    slug: data?.slug || chain.name || \"\",\n    explorers:\n      chain.blockExplorers?.map((e) => ({\n        name: e.name,\n        url: e.url,\n        standard: \"EIP3091\",\n      })) || data?.explorers,\n  };\n}\n", "// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\n\nconst promiseCache = /*#__PURE__*/ new Map();\nconst responseCache = /*#__PURE__*/ new Map();\n\n/**\n *@internal\n */\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey_: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: (data: TData) => cache.set(cacheKey_, data),\n  });\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache);\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  );\n\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response,\n  };\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string;\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number;\n};\n\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey);\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n\n  try {\n    const data = await promise;\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data });\n\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n", "import type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\n\nexport type RpcRequest = {\n  jsonrpc?: \"2.0\";\n  method: string;\n  params?: unknown;\n  id?: number;\n};\n\ntype FetchRpcOptions = {\n  requests: RpcRequest[];\n  requestTimeoutMs?: number;\n};\n\ntype SuccessResult<T> = {\n  method?: never;\n  result: T;\n  error?: never;\n};\ntype ErrorResult<T> = {\n  method?: never;\n  result?: never;\n  error: T;\n};\ntype Subscription<TResult, TError> = {\n  method: \"eth_subscription\";\n  error?: never;\n  result?: never;\n  params: {\n    subscription: string;\n  } & (\n    | {\n        result: TResult;\n        error?: never;\n      }\n    | {\n        result?: never;\n        error: TError;\n      }\n  );\n};\n\ntype RpcResponse<TResult = unknown, TError = unknown> = {\n  jsonrpc: `${number}`;\n  id: number;\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n);\n\n/**\n * @internal\n */\nexport async function fetchRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchRpcOptions,\n): Promise<RpcResponse[]> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...client.config?.rpc?.fetch?.headers,\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.requests),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(\n      `RPC request failed with status ${response.status} - ${response.statusText}`,\n    );\n  }\n\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  const text = await response.text();\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    console.error(\"Error parsing response\", err, text);\n    throw err;\n  }\n}\n\ntype FetchSingleRpcOptions = {\n  request: RpcRequest;\n  requestTimeoutMs?: number;\n};\n\n/**\n * @internal\n */\nexport async function fetchSingleRpc(\n  rpcUrl: string,\n  client: ThirdwebClient,\n  options: FetchSingleRpcOptions,\n): Promise<RpcResponse> {\n  const response = await getClientFetch(client)(rpcUrl, {\n    headers: {\n      ...(client.config?.rpc?.fetch?.headers || {}),\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify(options.request),\n    method: \"POST\",\n    requestTimeoutMs:\n      options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,\n    keepalive: client.config?.rpc?.fetch?.keepalive,\n  });\n\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(`RPC request failed with status ${response.status}`);\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  const text = await response.text();\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    console.error(\"Error parsing response\", err, text);\n    throw err;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "_a"]
}
