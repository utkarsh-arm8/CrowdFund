import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  MANAGED_ACCOUNT_GAS_BUFFER,
  isZkSyncChain,
  setAnalyticsHeaders
} from "./chunk-J7AYA5NI.js";
import {
  isTwUrl
} from "./chunk-4MMI5T6E.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4357AYQK.js";
import {
  BigNumber,
  lib_exports20 as lib_exports
} from "./chunk-5UPRJSZY.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
init_lib();
async function hexlifyUserOp(op) {
  const userOp = await utils_exports.resolveProperties(op);
  return Object.keys(userOp).map((key) => {
    let val = userOp[key];
    if (typeof val !== "string" || !val.startsWith("0x")) {
      val = utils_exports.hexValue(val);
    }
    return [key, val];
  }).reduce((set, _ref) => {
    let [k, v] = _ref;
    return {
      ...set,
      [k]: v
    };
  }, {});
}
async function getUserOpHashV06(userOp, entryPoint, chainId) {
  const op = await utils_exports.resolveProperties(userOp);
  const hashedUserOp = {
    sender: op.sender,
    nonce: op.nonce,
    initCodeHash: utils_exports.keccak256(op.initCode),
    callDataHash: utils_exports.keccak256(op.callData),
    callGasLimit: op.callGasLimit,
    verificationGasLimit: op.verificationGasLimit,
    preVerificationGas: op.preVerificationGas,
    maxFeePerGas: op.maxFeePerGas,
    maxPriorityFeePerGas: op.maxPriorityFeePerGas,
    paymasterAndDataHash: utils_exports.keccak256(op.paymasterAndData)
  };
  const userOpType = {
    components: [{
      type: "address",
      name: "sender"
    }, {
      type: "uint256",
      name: "nonce"
    }, {
      type: "bytes32",
      name: "initCodeHash"
    }, {
      type: "bytes32",
      name: "callDataHash"
    }, {
      type: "uint256",
      name: "callGasLimit"
    }, {
      type: "uint256",
      name: "verificationGasLimit"
    }, {
      type: "uint256",
      name: "preVerificationGas"
    }, {
      type: "uint256",
      name: "maxFeePerGas"
    }, {
      type: "uint256",
      name: "maxPriorityFeePerGas"
    }, {
      type: "bytes32",
      name: "paymasterAndDataHash"
    }],
    name: "hashedUserOp",
    type: "tuple"
  };
  const encoded = utils_exports.defaultAbiCoder.encode([userOpType], [{
    ...hashedUserOp
  }]);
  const userOpHash = utils_exports.keccak256(encoded);
  const enc = utils_exports.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, entryPoint, chainId]);
  return utils_exports.keccak256(enc);
}
var generateRandomUint192 = () => {
  const rand1 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand2 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand3 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand4 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand5 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand6 = BigInt(Math.floor(Math.random() * 4294967296));
  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;
};
var randomNonce = () => {
  let hexString = generateRandomUint192().toString(16);
  if (hexString.length % 2 !== 0) {
    hexString = "0" + hexString;
  }
  hexString = "0x" + hexString;
  return BigNumber.from(utils_exports.concat([hexString, "0x0000000000000000"]));
};
var DEBUG = false;
var HttpRpcClient = class {
  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {
    this.bundlerUrl = bundlerUrl;
    this.entryPointAddress = entryPointAddress;
    this.chainId = chainId;
    const headers = {};
    if (isTwUrl(this.bundlerUrl)) {
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (secretKey) {
        headers["x-secret-key"] = secretKey;
      } else if (clientId) {
        headers["x-client-id"] = clientId;
        if (bundleId) {
          headers["x-bundle-id"] = bundleId;
        }
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
    }
    this.userOpJsonRpcProvider = new lib_exports.StaticJsonRpcProvider({
      url: this.bundlerUrl,
      headers
    }, {
      name: "Connected bundler network",
      chainId
    });
    this.initializing = this.validateChainId();
  }
  async validateChainId() {
    if (await isZkSyncChain(this.chainId)) {
      return;
    }
    const chain = await this.userOpJsonRpcProvider.send("eth_chainId", []);
    const bundlerChain = parseInt(chain);
    if (bundlerChain !== this.chainId) {
      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);
    }
  }
  /**
   * send a UserOperation to the bundler
   * @param userOp1 - The UserOperation to send
   * @returns userOpHash the id of this operation, for getUserOperationTransaction
   */
  async sendUserOpToBundler(userOp1) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp1);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_sendUserOperation", jsonRequestData);
    return await this.userOpJsonRpcProvider.send("eth_sendUserOperation", [hexifiedUserOp, this.entryPointAddress]);
  }
  async estimateUserOpGas(userOp) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_estimateUserOperationGas", jsonRequestData);
    const data = await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas", [hexifiedUserOp, this.entryPointAddress]);
    return {
      preVerificationGas: BigNumber.from(data.preVerificationGas),
      verificationGas: BigNumber.from(data.verificationGas),
      verificationGasLimit: BigNumber.from(data.verificationGasLimit),
      callGasLimit: BigNumber.from(data.callGasLimit).add(MANAGED_ACCOUNT_GAS_BUFFER)
    };
  }
  async getUserOperationGasPrice() {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("thirdweb_getUserOperationGasPrice", []);
  }
  async getUserOperationReceipt(userOpHash) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("eth_getUserOperationReceipt", [userOpHash]);
  }
  async zkPaymasterData(transactionInput) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("zk_paymasterData", [await hexlifyUserOp({
      ...transactionInput,
      gas: transactionInput.gasLimit
    })]);
  }
  async zkBroadcastTransaction(transactionInput) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("zk_broadcastTransaction", [transactionInput]);
  }
  async printUserOperation(method, _ref) {
    {
      return;
    }
  }
};

export {
  hexlifyUserOp,
  getUserOpHashV06,
  randomNonce,
  DEBUG,
  HttpRpcClient
};
//# sourceMappingURL=chunk-7WA2LFYP.js.map
