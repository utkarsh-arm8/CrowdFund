import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
function isHex(value, options = {}) {
  if (!value) {
    return false;
  }
  if (typeof value !== "string") {
    return false;
  }
  return options.strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/hex.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/text-encoder.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var textEncoder;
function cachedTextEncoder() {
  if (!textEncoder) {
    textEncoder = new TextEncoder();
  }
  return textEncoder;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/assert-size.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/byte-size.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
function byteSize(value) {
  if (isHex(value, { strict: false })) {
    return Math.ceil((value.length - 2) / 2);
  }
  return value.length;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/assert-size.js
function assertSize(hexOrBytes, { size }) {
  const givenSize = byteSize(hexOrBytes);
  if (givenSize > size) {
    throw new Error(`Size overflow: ${givenSize} > ${size}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/charcode-to-base-16.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine) {
    return char - charCodeMap.zero;
  }
  if (char >= charCodeMap.A && char <= charCodeMap.F) {
    return char - (charCodeMap.A - 10);
  }
  if (char >= charCodeMap.a && char <= charCodeMap.f) {
    return char - (charCodeMap.a - 10);
  }
  return void 0;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/hex.js
function padHex(hex_, options = {}) {
  const { dir, size = 32 } = options;
  if (size === null) {
    return hex_;
  }
  const hex = hex_.replace("0x", "");
  if (hex.length > size * 2) {
    throw new Error(`Size overflow: ${Math.ceil(hex.length / 2)} > ${size}`);
  }
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
  }
  const value = BigInt(hex);
  if (!signed) {
    return value;
  }
  const size = (hex.length - 2) / 2;
  const max = (1n << BigInt(size) * 8n - 1n) - 1n;
  if (value <= max) {
    return value;
  }
  return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToUint8Array(hex, opts = {}) {
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = padHex(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2) {
    hexString = `0${hexString}`;
  }
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new Error(`Invalid hex character: ${hexString}`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
var hexes = (() => Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0")))();
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return padHex(hex, { size: opts.size });
  }
  return hex;
}
function uint8ArrayToHex(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return padHex(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size) {
    if (signed) {
      maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
    } else {
      maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new Error(`Number "${value_}${suffix}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${maxValue ? `(${minValue} to ${maxValue})` : `(above ${minValue})`}`);
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
  if (size) {
    return padHex(hex, { size });
  }
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = cachedTextEncoder().encode(value_);
  return uint8ArrayToHex(value, opts);
}

export {
  cachedTextEncoder,
  isHex,
  byteSize,
  assertSize,
  charCodeToBase16,
  padHex,
  hexToBigInt,
  hexToNumber,
  hexToUint8Array,
  boolToHex,
  uint8ArrayToHex,
  numberToHex,
  stringToHex
};
//# sourceMappingURL=chunk-4ZVJN6FY.js.map
