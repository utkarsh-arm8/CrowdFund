import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  walletIds
} from "./chunk-76VURHCN.js";
import {
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-S3WHR7KM.js";
import {
  getValidPublicRPCUrl
} from "./chunk-4MMI5T6E.js";
import {
  WagmiConnector
} from "./chunk-SYPEQW6F.js";
import {
  _defineProperty
} from "./chunk-7YQW7K4V.js";
import "./chunk-C347233M.js";
import "./chunk-VE5YG2UP.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4357AYQK.js";
import {
  lib_exports20 as lib_exports
} from "./chunk-5UPRJSZY.js";
import "./chunk-ZKAAZOGS.js";
import "./chunk-OKK22FPZ.js";
import "./chunk-4K5QQUIR.js";
import "./chunk-OWJUH5G2.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/wallets/evm/connectors/wallet-connect/dist/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
init_lib();
var chainsToRequest = /* @__PURE__ */ new Set([1, 137, 10, 42161, 56]);
var NAMESPACE = "eip155";
var REQUESTED_CHAINS_KEY = "wagmi.requestedChains";
var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
var LAST_USED_CHAIN_ID = "last-used-chain-id";
var WalletConnectConnector = class extends WagmiConnector {
  constructor(config) {
    super({
      ...config,
      options: {
        isNewChainsStale: true,
        ...config.options
      }
    });
    _defineProperty(this, "id", walletIds.walletConnect);
    _defineProperty(this, "name", "WalletConnect");
    _defineProperty(this, "ready", true);
    _defineProperty(this, "onAccountsChanged", (accounts) => {
      if (accounts.length === 0) {
        this.emit("disconnect");
      } else {
        if (accounts[0]) {
          this.emit("change", {
            account: utils_exports.getAddress(accounts[0])
          });
        }
      }
    });
    _defineProperty(this, "onChainChanged", async (chainId) => {
      const id = Number(chainId);
      const unsupported = this.isChainUnsupported(id);
      await this._storage.setItem(LAST_USED_CHAIN_ID, String(chainId));
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    _defineProperty(this, "onDisconnect", async () => {
      await this._setRequestedChainsIds([]);
      await this._storage.removeItem(LAST_USED_CHAIN_ID);
      this.emit("disconnect");
    });
    _defineProperty(this, "onDisplayUri", (uri) => {
      this.emit("message", {
        type: "display_uri",
        data: uri
      });
    });
    _defineProperty(this, "onConnect", () => {
      this.emit("connect", {
        provider: this._provider
      });
    });
    this._storage = config.options.storage;
    this._createProvider();
    this.filteredChains = this.chains.length > 50 ? this.chains.filter((c) => {
      return chainsToRequest.has(c.chainId);
    }) : this.chains;
    this.showWalletConnectModal = this.options.qrcode !== false;
  }
  async connect() {
    var _a;
    let {
      chainId: chainIdP,
      pairingTopic
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    try {
      let targetChainId = chainIdP;
      if (!targetChainId) {
        const lastUsedChainIdStr = await this._storage.getItem(LAST_USED_CHAIN_ID);
        const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : void 0;
        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {
          targetChainId = lastUsedChainId;
        } else {
          targetChainId = (_a = this.filteredChains[0]) == null ? void 0 : _a.chainId;
        }
      }
      if (!targetChainId) {
        throw new Error("No chains found on connector.");
      }
      const provider = await this.getProvider();
      this.setupListeners();
      if (provider.session) {
        await provider.disconnect();
        const optionalChains = this.filteredChains.filter((chain) => chain.chainId !== targetChainId).map((optionalChain) => optionalChain.chainId);
        this.emit("message", {
          type: "connecting"
        });
        await provider.connect({
          pairingTopic,
          chains: [targetChainId],
          optionalChains: optionalChains.length > 0 ? optionalChains : [targetChainId]
        });
        await this._setRequestedChainsIds(this.filteredChains.map((_ref) => {
          let {
            chainId
          } = _ref;
          return chainId;
        }));
      }
      const accounts = await provider.enable();
      if (!accounts[0]) {
        throw new Error("No accounts found on provider.");
      }
      const account = utils_exports.getAddress(accounts[0]);
      const id = await this.getChainId();
      const unsupported = this.isChainUnsupported(id);
      return {
        account,
        chain: {
          id,
          unsupported
        },
        provider: new lib_exports.Web3Provider(provider)
      };
    } catch (error) {
      if (/user rejected/i.test(error == null ? void 0 : error.message)) {
        throw new UserRejectedRequestError(error);
      }
      throw error;
    }
  }
  async disconnect() {
    const cleanup = () => {
      if (typeof localStorage === "undefined") {
        return;
      }
      for (const key in localStorage) {
        if (key.startsWith("wc@2")) {
          localStorage.removeItem(key);
        }
      }
    };
    cleanup();
    const provider = await this.getProvider();
    const disconnectProvider = async () => {
      try {
        await provider.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        this._removeListeners();
        await this._setRequestedChainsIds([]);
        cleanup();
      }
    };
    disconnectProvider();
  }
  async getAccount() {
    const {
      accounts
    } = await this.getProvider();
    if (!accounts[0]) {
      throw new Error("No accounts found on provider.");
    }
    return utils_exports.getAddress(accounts[0]);
  }
  async getChainId() {
    const {
      chainId
    } = await this.getProvider();
    return chainId;
  }
  async getProvider() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this._provider) {
      await this._createProvider();
    }
    if (chainId) {
      await this.switchChain(chainId);
    }
    if (!this._provider) {
      throw new Error("No provider found.");
    }
    return this._provider;
  }
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider({
      chainId
    }), this.getAccount()]);
    return new lib_exports.Web3Provider(provider, chainId).getSigner(account);
  }
  async isAuthorized() {
    try {
      const [account, provider] = await Promise.all([this.getAccount(), this.getProvider()]);
      const isChainsStale = await this._isChainsStale();
      if (!account) {
        return false;
      }
      if (isChainsStale && provider.session) {
        try {
          await provider.disconnect();
        } catch {
        }
        return false;
      }
      return true;
    } catch {
      return false;
    }
  }
  async switchChain(chainId) {
    const chain = this.chains.find((chain_) => chain_.chainId === chainId);
    if (!chain) {
      throw new SwitchChainError(`Chain with ID: ${chainId}, not found on connector.`);
    }
    try {
      const provider = await this.getProvider();
      const namespaceChains = this._getNamespaceChainsIds();
      const namespaceMethods = this._getNamespaceMethods();
      const isChainApproved = namespaceChains.includes(chainId);
      if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
        const firstExplorer = chain.explorers && chain.explorers[0];
        const blockExplorerUrls = firstExplorer ? {
          blockExplorerUrls: [firstExplorer.url]
        } : {};
        await provider.request({
          method: ADD_ETH_CHAIN_METHOD,
          params: [{
            chainId: utils_exports.hexValue(chain.chainId),
            chainName: chain.name,
            nativeCurrency: chain.nativeCurrency,
            rpcUrls: getValidPublicRPCUrl(chain),
            // no clientId on purpose
            ...blockExplorerUrls
          }]
        });
        const requestedChains = await this._getRequestedChainsIds();
        requestedChains.push(chainId);
        await this._setRequestedChainsIds(requestedChains);
      }
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: utils_exports.hexValue(chainId)
        }]
      });
      return chain;
    } catch (error) {
      const message = typeof error === "string" ? error : error == null ? void 0 : error.message;
      if (/user rejected request/i.test(message)) {
        throw new UserRejectedRequestError(error);
      }
      throw new SwitchChainError(error);
    }
  }
  async _createProvider() {
    if (!this._initProviderPromise && true) {
      this._initProviderPromise = this.initProvider();
    }
    return this._initProviderPromise;
  }
  async initProvider() {
    const {
      default: EthereumProvider,
      OPTIONAL_EVENTS,
      OPTIONAL_METHODS
    } = await import("./index.es-QPRWI6PK.js");
    const [defaultChain, ...optionalChains] = this.filteredChains.map((_ref2) => {
      let {
        chainId
      } = _ref2;
      return chainId;
    });
    if (defaultChain) {
      this._provider = await EthereumProvider.init({
        showQrModal: this.showWalletConnectModal,
        projectId: this.options.projectId,
        methods: ["eth_sendTransaction", "personal_sign", "eth_signTypedData_v4"],
        optionalMethods: OPTIONAL_METHODS,
        optionalEvents: OPTIONAL_EVENTS,
        chains: [defaultChain],
        optionalChains,
        metadata: {
          name: this.options.dappMetadata.name,
          description: this.options.dappMetadata.description || "",
          url: this.options.dappMetadata.url,
          icons: [this.options.dappMetadata.logoUrl || ""]
        },
        rpcMap: Object.fromEntries(this.filteredChains.map((chain) => [
          chain.chainId,
          chain.rpc[0] || ""
          // TODO: handle chain.rpc being empty array
        ])),
        qrModalOptions: this.options.qrModalOptions
      });
    }
  }
  /**
   * Checks if the target chains match the chains that were
   * initially requested by the connector for the WalletConnect session.
   * If there is a mismatch, this means that the chains on the connector
   * are considered stale, and need to be revalidated at a later point (via
   * connection).
   *
   * There may be a scenario where a dapp adds a chain to the
   * connector later on, however, this chain will not have been approved or rejected
   * by the wallet. In this case, the chain is considered stale.
   *
   * There are exceptions however:
   * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,
   *    then the chain is not considered stale.
   * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is
   *    not considered stale.
   *
   * For the above cases, chain validation occurs dynamically when the user
   * attempts to switch chain.
   *
   * Also check that dapp supports at least 1 chain from previously approved session.
   */
  async _isChainsStale() {
    const namespaceMethods = this._getNamespaceMethods();
    if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
      return false;
    }
    if (!this.options.isNewChainsStale) {
      return false;
    }
    const requestedChains = await this._getRequestedChainsIds();
    const connectorChains = this.filteredChains.map((_ref3) => {
      let {
        chainId
      } = _ref3;
      return chainId;
    });
    const namespaceChains = this._getNamespaceChainsIds();
    if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
      return false;
    }
    return !connectorChains.every((id) => requestedChains.includes(id));
  }
  async setupListeners() {
    if (!this._provider) {
      return;
    }
    this._removeListeners();
    this._provider.on("accountsChanged", this.onAccountsChanged);
    this._provider.on("chainChanged", this.onChainChanged);
    this._provider.on("disconnect", this.onDisconnect);
    this._provider.on("session_delete", this.onDisconnect);
    this._provider.on("display_uri", this.onDisplayUri);
    this._provider.on("connect", this.onConnect);
  }
  _removeListeners() {
    if (!this._provider) {
      return;
    }
    this._provider.removeListener("accountsChanged", this.onAccountsChanged);
    this._provider.removeListener("chainChanged", this.onChainChanged);
    this._provider.removeListener("disconnect", this.onDisconnect);
    this._provider.removeListener("session_delete", this.onDisconnect);
    this._provider.removeListener("display_uri", this.onDisplayUri);
    this._provider.removeListener("connect", this.onConnect);
  }
  async _setRequestedChainsIds(chains) {
    await this._storage.setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));
  }
  async _getRequestedChainsIds() {
    const data = await this._storage.getItem(REQUESTED_CHAINS_KEY);
    return data ? JSON.parse(data) : [];
  }
  _getNamespaceChainsIds() {
    var _a, _b, _c;
    if (!this._provider) {
      return [];
    }
    const chainIds = (_c = (_b = (_a = this._provider.session) == null ? void 0 : _a.namespaces[NAMESPACE]) == null ? void 0 : _b.chains) == null ? void 0 : _c.map((chain) => parseInt(chain.split(":")[1] || ""));
    return chainIds ?? [];
  }
  _getNamespaceMethods() {
    var _a, _b;
    if (!this._provider) {
      return [];
    }
    const methods = (_b = (_a = this._provider.session) == null ? void 0 : _a.namespaces[NAMESPACE]) == null ? void 0 : _b.methods;
    return methods ?? [];
  }
};
export {
  WalletConnectConnector
};
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js.map
