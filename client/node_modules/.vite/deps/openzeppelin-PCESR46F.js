import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  getContract
} from "./chunk-XMSXM2E4.js";
import {
  readContract
} from "./chunk-7QDYPHE5.js";
import "./chunk-T7SU3EOS.js";
import "./chunk-RHGXPIYU.js";
import "./chunk-HYWBSNOJ.js";
import {
  isHex
} from "./chunk-4ZVJN6FY.js";
import "./chunk-RYFD5FY6.js";
import "./chunk-U6IJB3QF.js";
import "./chunk-LMJC2RD2.js";
import {
  stringify
} from "./chunk-4K65M2LO.js";
import "./chunk-IMPEKHNI.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/gasless/providers/openzeppelin.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
async function prepareOpenZeppelinTransaction({ account, serializableTransaction, transaction, gasless }) {
  const forrwaderContract = getContract({
    address: gasless.relayerForwarderAddress,
    chain: transaction.chain,
    client: transaction.client
  });
  const nonce = await readContract({
    contract: forrwaderContract,
    method: "function getNonce(address) view returns (uint256)",
    params: [account.address]
  });
  const [signature, message] = await (async () => {
    if (!serializableTransaction.to) {
      throw new Error("OpenZeppelin transactions must have a 'to' address");
    }
    if (!serializableTransaction.gas) {
      throw new Error("OpenZeppelin transactions must have a 'gas' value");
    }
    if (!serializableTransaction.data) {
      throw new Error("OpenZeppelin transactions must have a 'data' value");
    }
    if (gasless.experimentalChainlessSupport) {
      const message3 = {
        from: account.address,
        to: serializableTransaction.to,
        value: 0n,
        gas: serializableTransaction.gas,
        nonce,
        data: serializableTransaction.data,
        chainid: BigInt(transaction.chain.id)
      };
      return [
        await account.signTypedData({
          domain: {
            name: "GSNv2 Forwarder",
            version: "0.0.1",
            verifyingContract: forrwaderContract.address
          },
          message: message3,
          primaryType: "ForwardRequest",
          types: { ForwardRequest: ChainAwareForwardRequest }
        }),
        message3
      ];
    }
    const message2 = {
      from: account.address,
      to: serializableTransaction.to,
      value: 0n,
      gas: serializableTransaction.gas,
      nonce,
      data: serializableTransaction.data
    };
    return [
      await account.signTypedData({
        domain: {
          name: gasless.domainName ?? "GSNv2 Forwarder",
          version: gasless.domainVersion ?? "0.0.1",
          chainId: transaction.chain.id,
          verifyingContract: forrwaderContract.address
        },
        message: message2,
        primaryType: "ForwardRequest",
        types: { ForwardRequest }
      }),
      message2
    ];
  })();
  const messageType = "forward";
  return { message, signature, messageType };
}
var ForwardRequest = [
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "value", type: "uint256" },
  { name: "gas", type: "uint256" },
  { name: "nonce", type: "uint256" },
  { name: "data", type: "bytes" }
];
var ChainAwareForwardRequest = [
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "value", type: "uint256" },
  { name: "gas", type: "uint256" },
  { name: "nonce", type: "uint256" },
  { name: "data", type: "bytes" },
  { name: "chainid", type: "uint256" }
];
async function relayOpenZeppelinTransaction(options) {
  var _a;
  const { message, messageType, signature } = await prepareOpenZeppelinTransaction(options);
  const response = await fetch(options.gasless.relayerUrl, {
    method: "POST",
    body: stringify({
      request: message,
      type: messageType,
      signature,
      forwarderAddress: options.gasless.relayerForwarderAddress
    })
  });
  if (!response.ok) {
    (_a = response.body) == null ? void 0 : _a.cancel();
    throw new Error(`Failed to send transaction: ${await response.text()}`);
  }
  const json = await response.json();
  if (!json.result) {
    throw new Error(`Relay transaction failed: ${json.message}`);
  }
  const transactionHash = JSON.parse(json.result).txHash;
  if (isHex(transactionHash)) {
    return {
      transactionHash,
      chain: options.transaction.chain,
      client: options.transaction.client
    };
  }
  throw new Error(`Failed to send transaction: ${stringify(json)}`);
}
export {
  ChainAwareForwardRequest,
  ForwardRequest,
  prepareOpenZeppelinTransaction,
  relayOpenZeppelinTransaction
};
//# sourceMappingURL=openzeppelin-PCESR46F.js.map
