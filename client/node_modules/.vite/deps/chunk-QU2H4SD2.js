import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  resolvePromisedValue,
  toUnits
} from "./chunk-5Y4RQ6D5.js";
import {
  getContract
} from "./chunk-XMSXM2E4.js";
import {
  Hash,
  bytes,
  concatBytes,
  createView,
  encodeAbiParameters,
  exists,
  hash,
  isAbiFunction,
  output,
  prepareMethod,
  randomBytes,
  rotr,
  stringToBytes,
  toBytes,
  wrapConstructor
} from "./chunk-7QDYPHE5.js";
import {
  parseAbiItem
} from "./chunk-T7SU3EOS.js";
import {
  hexToUint8Array,
  isHex,
  uint8ArrayToHex
} from "./chunk-4ZVJN6FY.js";
import {
  ContractPublisher
} from "./chunk-DFC6BI5N.js";
import {
  createTransactionBatches,
  deployContractDeterministic,
  deployWithThrowawayDeployer,
  getDeploymentInfo
} from "./chunk-3376PJ73.js";
import {
  fetchSourceFilesFromMetadata
} from "./chunk-YPYICWYD.js";
import {
  defineChain,
  getCachedChain
} from "./chunk-U6IJB3QF.js";
import {
  LruMap,
  getClientFetch,
  getThirdwebDomains
} from "./chunk-LMJC2RD2.js";
import {
  TWMultichainRegistryLogic_default
} from "./chunk-XDXECFPF.js";
import {
  require_fast_deep_equal
} from "./chunk-YTCBHIZC.js";
import {
  CommonNFTInput,
  CommonNFTOutput,
  NFTInputOrUriSchema,
  normalizePriceValue
} from "./chunk-5TF2ZDVM.js";
import {
  ContractEncoder,
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-2PW66HIP.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  CONTRACT_ADDRESSES,
  ChainId,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  ContractWrapper,
  DeployTransaction,
  DropErc721ContractSchema,
  EditionDropInitializer,
  EditionInitializer,
  EventType,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  RPCConnectionHandler,
  SignatureDropInitializer,
  SplitInitializer,
  THIRDWEB_DEPLOYER,
  ThirdwebStorage,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  VoteInitializer,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  computeCreate2FactoryTransaction,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeForwarderAddress,
  coreContractAbi,
  createLruCache,
  detectFeatures,
  encodeConstructorParamsForImplementation,
  extensionContractAbi,
  extractConstructorParamsFromAbi,
  extractFeatures,
  fetchAndCacheDeployMetadata,
  fetchContractMetadataFromAddress,
  fetchExtendedReleaseMetadata,
  fetchPublishedContractFromPolygon,
  getChainProvider,
  getCompositeABI,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getDefaultGasOverrides,
  getInitBytecodeWithSalt,
  getMultichainRegistryAddress,
  getProcessEnv,
  getSignerAndProvider,
  hasDuplicates,
  hasMatchingAbi,
  invariant,
  isBrowser,
  isChainConfig,
  isContractDeployed,
  require_bs58,
  resolveAddress,
  resolveContractUriFromAddress,
  resolveImplementation,
  setSupportedChains,
  signTypedDataInternal,
  z
} from "./chunk-YPNI3TBW.js";
import {
  require_utils
} from "./chunk-43DMFY6L.js";
import {
  eventemitter3_default
} from "./chunk-C347233M.js";
import {
  Contract,
  ContractFactory,
  Wallet,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-4357AYQK.js";
import {
  BigNumber,
  lib_exports20 as lib_exports2,
  lib_exports8 as lib_exports
} from "./chunk-5UPRJSZY.js";
import {
  require_bn
} from "./chunk-OKK22FPZ.js";
import {
  defaultChains,
  getChainByChainIdAsync,
  getChainRPC
} from "./chunk-OWJUH5G2.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
var import_dist250 = __toESM(require_dist());
var import_dist251 = __toESM(require_dist2());
var import_dist252 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/dist/sdk-3e21fc5c.browser.esm.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json
var TWMultichainRegistryRouter_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_pluginMap",
        type: "address",
        internalType: "address"
      },
      {
        name: "_trustedForwarders",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "fallback",
    stateMutability: "payable"
  },
  {
    type: "receive",
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_getPluginForFunction",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "addPlugin",
    inputs: [
      {
        name: "_plugin",
        type: "tuple",
        internalType: "struct IPluginMap.Plugin",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getAllFunctionsOfPlugin",
    inputs: [
      {
        name: "_pluginAddress",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "registered",
        type: "bytes4[]",
        internalType: "bytes4[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllPlugins",
    inputs: [],
    outputs: [
      {
        name: "registered",
        type: "tuple[]",
        internalType: "struct IPluginMap.Plugin[]",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPluginForFunction",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMember",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "member",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMemberCount",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "count",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "hasRoleWithSwitch",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedForwarder",
    inputs: [
      {
        name: "forwarder",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "multicall",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [
      {
        name: "results",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pluginMap",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "removePlugin",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "updatePlugin",
    inputs: [
      {
        name: "_plugin",
        type: "tuple",
        internalType: "struct IPluginMap.Plugin",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "PluginAdded",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginRemoved",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginSet",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "functionSignature",
        type: "string",
        indexed: true,
        internalType: "string"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginUpdated",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "oldPluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newPluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-3e21fc5c.browser.esm.js
init_lib();

// node_modules/@thirdweb-dev/generated-abis/dist/thirdweb-dev-generated-abis.esm.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var GENERATED_ABI = {};

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json
var TWFactory_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_trustedForwarder",
        type: "address",
        internalType: "address"
      },
      {
        name: "_registry",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "FACTORY_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "addImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "approval",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approveImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      },
      {
        name: "_toApprove",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "currentVersion",
    inputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deployProxy",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployProxyByImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_salt",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "deployedProxy",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployProxyDeterministic",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_salt",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployer",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getImplementation",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_version",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLatestImplementation",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMember",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMemberCount",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "implementation",
    inputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedForwarder",
    inputs: [
      {
        name: "forwarder",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "multicall",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [
      {
        name: "results",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registry",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract TWRegistry"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ImplementationAdded",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "contractType",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "version",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ImplementationApproved",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "isApproved",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProxyDeployed",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "proxy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "deployer",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-3e21fc5c.browser.esm.js
var alreadyChecked = false;
function checkClientIdOrSecretKey(message, clientId, secretKey) {
  if (alreadyChecked) {
    return;
  }
  alreadyChecked = true;
  if (clientId || secretKey) {
    return;
  }
  console.warn(message);
}
async function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage) {
  var _a;
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  let constructorParamMap = arguments.length > 6 ? arguments[6] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  let encodedArgs;
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" || (extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    encodedArgs = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.encodedArgs;
  } else {
    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey);
  }
  return encodedArgs;
}
async function predictThirdwebContractAddress(contractName, chainId, storage) {
  var _a;
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  if ((extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "plugin" || (extendedMetadata == null ? void 0 : extendedMetadata.routerType) === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    const implementation2 = (_a = deploymentInfo.find((contract) => contract.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
    invariant(implementation2, "Error computing address for plugin router");
    return implementation2;
  }
  const implementation = await computeDeploymentInfo("implementation", provider, storage, create2Factory, {
    contractName
  }, clientId, secretKey);
  return implementation.transaction.predictedAddress;
}
async function getThirdwebContractAddress(contractName, chainId, storage) {
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const isDeployed = await isContractDeployed(contractAddress, provider);
  invariant(isDeployed, "Contract not deployed yet");
  return contractAddress;
}
var VerificationStatus = {
  FAILED: "Fail - Unable to verify",
  SUCCESS: "Pass - Verified",
  PENDING: "Pending in queue",
  IN_PROGRESS: "In progress",
  ALREADY_VERIFIED: "Contract source code already verified",
  AUTOMATICALLY_VERIFIED: "Already Verified"
};
var RequestStatus = {
  OK: "1",
  NOTOK: "0"
};
async function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage) {
  let contractVersion = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "latest";
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let constructorArgs = arguments.length > 8 ? arguments[8] : void 0;
  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, contractVersion, clientId, secretKey, constructorArgs);
  console.info(`Verifying ${contractName} at address ${contractAddress}`);
  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs == null ? void 0 : encodedArgs.toString().replace("0x", ""));
  return guid;
}
async function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {
  try {
    const provider = getChainProvider(chainId, {});
    contractAddress = (await resolveImplementation(contractAddress, provider)).address;
    const compilerMetadata = await fetchContractMetadataFromAddress(contractAddress, provider, storage);
    const compilerVersion = compilerMetadata.metadata.compiler.version;
    const sources = await fetchSourceFilesFromMetadata(compilerMetadata, storage);
    const sourcesWithUrl = compilerMetadata.metadata.sources;
    const sourcesWithContents = {};
    for (const path of Object.keys(sourcesWithUrl)) {
      const sourceCode = sources.find((source) => path === source.filename);
      if (!sourceCode) {
        throw new Error(`Could not find source file for ${path}`);
      }
      sourcesWithContents[path] = {
        content: sourceCode.source
      };
    }
    const compilerInput = {
      language: "Solidity",
      sources: sourcesWithContents,
      settings: {
        optimizer: compilerMetadata.metadata.settings.optimizer,
        evmVersion: compilerMetadata.metadata.settings.evmVersion,
        remappings: compilerMetadata.metadata.settings.remappings,
        outputSelection: {
          "*": {
            "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
            "": ["ast"]
          }
        }
      }
    };
    const compilationTarget = compilerMetadata.metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const contractPath = targets[0];
    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata.abi, provider, storage);
    const requestBody = {
      apikey: explorerAPIKey,
      module: "contract",
      action: "verifysourcecode",
      contractaddress: contractAddress,
      sourceCode: JSON.stringify(compilerInput),
      codeformat: "solidity-standard-json-input",
      contractname: `${contractPath}:${compilerMetadata.name}`,
      compilerversion: `v${compilerVersion}`,
      constructorArguements: encodedArgs
    };
    const parameters = new URLSearchParams({
      ...requestBody
    });
    const result = await fetch(explorerAPIUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: parameters.toString()
    });
    const data = await result.json();
    if (data.status === RequestStatus.OK) {
      return data.result;
    } else {
      throw new Error(`${data.result}`);
    }
  } catch (e) {
    throw new Error(e.toString());
  }
}
async function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {
  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}"`;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      try {
        const result = await fetch(endpoint, {
          method: "GET"
        });
        const data = await result.json();
        if ((data == null ? void 0 : data.result) !== VerificationStatus.PENDING && (data == null ? void 0 : data.result) !== VerificationStatus.IN_PROGRESS) {
          clearInterval(intervalId);
          resolve(data);
        }
      } catch (e) {
        clearInterval(intervalId);
        reject(e);
      }
    }, 3e3);
  });
}
async function isVerifiedOnEtherscan(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, clientId) {
  const provider = getChainProvider(chainId, {
    clientId
  });
  invariant(await isContractDeployed(contractAddress, provider), "Contract not deployed yet.");
  const endpoint = `${explorerAPIUrl}?module=contract&action=getsourcecode&address=${contractAddress}&apikey=${explorerAPIKey}"`;
  try {
    const result = await fetch(endpoint, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json;charset=UTF-8"
      }
    });
    const data = await result.json();
    const etherscanResult = data.result[0];
    if (etherscanResult.ABI === "Contract source code not verified") {
      return false;
    }
    return true;
  } catch (e) {
    throw new Error(`Error checking verification for contract ${contractAddress}: ${e}`);
  }
}
async function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider, storage) {
  const constructorParamTypes = extractConstructorParamsFromAbi(abi);
  if (constructorParamTypes.length === 0) {
    return "";
  }
  const result = await fetch(`${explorerAPIUrl}?module=contract&action=getcontractcreation&contractaddresses=${contractAddress}&apikey=${explorerAPIKey}`);
  const data = await result.json();
  if (data && data.status === RequestStatus.OK && data.result[0] !== void 0) {
    const contract = new utils_exports.Interface(abi);
    const txHash = data.result[0].txHash;
    let constructorArgs = "";
    if (contract.deploy.inputs.length === 0) {
      return "";
    }
    const tx = await provider.getTransaction(txHash);
    const txDeployBytecode = tx.data;
    try {
      const bytecode = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage);
      if (bytecode) {
        const bytecodeHex = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
        let create2FactoryAddress;
        try {
          create2FactoryAddress = await getCreate2FactoryAddress(provider);
        } catch (error) {
        }
        const create2SaltLength = tx.to === create2FactoryAddress ? 64 : 0;
        constructorArgs = txDeployBytecode.substring(bytecodeHex.length + create2SaltLength);
      }
    } catch (e) {
    }
    if (!constructorArgs) {
      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      if (matches.length > 0) {
        constructorArgs = matches[0][2];
      }
    }
    if (!constructorArgs) {
      const constructorParamByteLength = constructorParamTypes.length * 64;
      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);
    }
    try {
      utils_exports.defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);
    } catch (e) {
      throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.");
    }
    return constructorArgs;
  } else {
    return "";
  }
}
async function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage) {
  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider);
  if (compilerMetaUri) {
    const ContractPublisherAbi = (await import("./ContractPublisher-CJVHBNFY.js")).default;
    const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider("polygon", {}));
    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => fetchExtendedReleaseMetadata(uri, storage)));
    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : void 0;
  }
  return void 0;
}
var ContractVerifier = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
  }
  /**
   * Verifies a Thirdweb contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyThirdwebContract(
   *   "DropERC721",
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractName - Name of the contract to verify
   * @param explorerAPIUrl - Explorer API URL
   * @param explorerAPIKey - Explorer API key
   */
  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey) {
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let constructorArgs = arguments.length > 4 ? arguments[4] : void 0;
    const chainId = (await this.getProvider().getNetwork()).chainId;
    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, contractVersion, this.options.clientId, this.options.secretKey, constructorArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
  /**
   * Verifies any contract
   *
   * @example
   * ```javascript
   *
   * // Note: If verifying on a network different from the SDK instance's network,
   * //       update the verifier's chain/network as below:
   * //
   * //       sdk.verifier.updateSignerOrProvider(chainId);
   *
   * const contractAddress = ""
   * const explorerAPIUrl = "" // e.g. https://api.etherscan.io/api
   * const explorerAPIKey = "" // Generate API key on the explorer
   *
   * await sdk.verifier.verifyContract(
   *   contractAddress,
   *   explorerAPIUrl,
   *   explorerAPIKey,
   * );
   * ```
   * @param contractAddress - Address of the contract to verify
   * @param explorerAPIUrl - Explorer API URL
   * @param explorerAPIKey - Explorer API key
   */
  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    let encodedArgs;
    if (constructorArgs) {
      const paramTypes = Object.values(constructorArgs).map((arg) => {
        invariant(arg.type, "Param type is required");
        return arg.type;
      });
      const paramValues = Object.values(constructorArgs).map((arg) => {
        return arg.value;
      });
      encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypes, paramValues);
    }
    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
};
var LOCAL_NODE_PKEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
var UserWallet = class _UserWallet {
  constructor(network, options, storage) {
    __publicField(this, "events", new eventemitter3_default());
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
    this.events = new eventemitter3_default();
    this.storage = storage;
  }
  // TODO disconnect()
  // TODO switchChain()
  // TODO tokens()
  // TODO NFTs()
  // TODO this will become the source of truth of the signer and have every contract read from it
  // TODO separate signer and provider logics
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  /**
   * Transfer native or ERC20 tokens from this wallet to another wallet
   * @example
   * ```javascript
   *  // transfer 0.8 ETH
   * await sdk.wallet.transfer("0x...", 0.8);
   *  // transfer 0.8 tokens of `tokenContractAddress`
   * await sdk.wallet.transfer("0x...", 0.8, tokenContractAddress);
   * ```
   * @param to - the account to send funds to
   * @param amount - the amount in tokens
   * @param currencyAddress - Optional - ERC20 contract address of the token to transfer
   */
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const [resolvedTo, resolvedCurrency, amountInWei] = await Promise.all([resolveAddress(to), resolveAddress(currencyAddress), normalizePriceValue(this.connection.getProvider(), amount, currencyAddress)]);
    const signer = this.requireWallet();
    if (isNativeToken(resolvedCurrency)) {
      const from = await signer.getAddress();
      const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
      const tx = await signer.sendTransaction({
        from,
        to: resolvedTo,
        value: amountInWei,
        ...gasOverrides
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const ERC20Abi = (await import("./IERC20-6Q3C4BHF.js")).default;
      return {
        receipt: await this.createErc20(resolvedCurrency, ERC20Abi).sendTransaction("transfer", [resolvedTo, amountInWei])
      };
    }
  }
  /**
   * Fetch the native or ERC20 token balance of this wallet
   * @example
   * ```javascript
   * // native currency balance
   * const balance = await sdk.wallet.balance();
   * // ERC20 token balance
   * const erc20balance = await sdk.wallet.balance(tokenContractAddress);
   *
   * ```
   */
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(resolvedCurrency)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      const ERC20Abi = (await import("./IERC20-6Q3C4BHF.js")).default;
      balance = await this.createErc20(resolvedCurrency, ERC20Abi).read("balanceOf", [await this.getAddress()]);
    }
    return await fetchCurrencyValue(provider, resolvedCurrency, balance);
  }
  /**
   * Get the currently connected address
   * @example
   * ```javascript
   * const address = await sdk.wallet.getAddress();
   * ```
   */
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  /**
   * Get the currently connected wallet's chainId
   * @internal
   */
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  /**
   * Get the number of transactions sent from this address.
   * @param blockTag - Optional - the block tag to read the nonce from
   */
  async getNonce(blockTag) {
    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);
    return txCount;
  }
  /**
   * Checks whether there's a signer connected with the SDK
   * @internal
   */
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Sign any message with the connected wallet private key
   * @param message - the message to sign
   * @returns The signed message
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * const message = "Sign this message...";
   *
   * // Now we can sign the message with the connected wallet
   * const signature = await sdk.wallet.sign(message);
   * ```
   */
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  /**
   * Sign a typed data structure (EIP712) with the connected wallet private key
   * @param domain - the domain as EIP712 standard
   * @param types - the structure and data types as defined by the EIP712 standard
   * @param message - the data to sign
   * @returns The payload and its associated signature
   *
   * @example
   * ```javascript
   * // This is the message to be signed
   * // Now we can sign the message with the connected wallet
   * const { payload, signature } = await sdk.wallet.signTypedData(
   *   {
          name: "MyEIP721Domain",
          version: "1",
          chainId: 1,
          verifyingContract: "0x...",
        },
        { MyStruct: [ { name: "to", type: "address" }, { name: "quantity", type: "uint256" } ] },
        { to: "0x...", quantity: 1 },
   * );
   * ```
   */
  async signTypedData(domain, types, message) {
    return await signTypedDataInternal(this.requireWallet(), domain, types, message);
  }
  /**
   * Recover the signing address from a signed message
   * @param message - the original message that was signed
   * @param signature - the signature to recover the address from
   * @returns The address that signed the message
   *
   * @example
   * ```javascript
   * const message = "Sign this message...";
   * const signature = await sdk.wallet.sign(message);
   *
   * // Now we can recover the signing address
   * const address = sdk.wallet.recoverAddress(message, signature);
   * ```
   */
  recoverAddress(message, signature) {
    const messageHash = utils_exports.hashMessage(message);
    const messageHashBytes = utils_exports.arrayify(messageHash);
    return utils_exports.recoverAddress(messageHashBytes, signature);
  }
  /**
   * Send a raw transaction to the blockchain from the connected wallet
   * @param transactionRequest - raw transaction data to send to the blockchain
   */
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
    transactionRequest = {
      ...gasOverrides,
      ...transactionRequest
    };
    return signer.sendTransaction(transactionRequest);
  }
  /**
   * Execute a raw transaction to the blockchain from the connected wallet and wait for it to be mined
   * @param transactionRequest - raw transaction data to send to the blockchain
   */
  async executeRawTransaction(transactionRequest) {
    const tx = await this.sendRawTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  /**
   * Request funds from a running local node to the currently connected wallet
   * @param amount - the amount in native currency (in ETH) to request
   */
  async requestFunds(amount) {
    const chainId = await this.getChainId();
    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {
      const localWallet = new _UserWallet(new Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options, this.storage);
      return localWallet.transfer(await this.getAddress(), amount);
    } else {
      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);
    }
  }
  /** ***********************
   * PRIVATE FUNCTIONS
   * ***********************/
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress, ERC20Abi) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, ERC20Abi, this.options, this.storage);
  }
};
function getAllDetectedFeatureNames(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features.map((f) => f.name);
}
function getAllDetectedExtensionNames(abi) {
  return getAllDetectedFeatureNames(abi);
}
function createStorage(storage, options) {
  if (storage) {
    return storage;
  } else if (options == null ? void 0 : options.gatewayUrls) {
    return new ThirdwebStorage({
      gatewayUrls: options.gatewayUrls,
      clientId: options.clientId,
      secretKey: options.secretKey
    });
  } else {
    return new ThirdwebStorage({
      clientId: options == null ? void 0 : options.clientId,
      secretKey: options == null ? void 0 : options.secretKey
    });
  }
}
var MultichainRegistry = class {
  constructor(network, storage) {
    __publicField(this, "addContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "add",
        args: [deployerAddress, contract.address, contract.chainId, contract.metadataURI || ""]
      });
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = [];
      const contractEncoder = new ContractEncoder(this.registryLogic);
      contracts.forEach((contact) => {
        encoded.push(contractEncoder.encode("add", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || ""]));
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "remove",
        args: [deployerAddress, await resolveAddress(contract.address), contract.chainId]
      });
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const contractEncoder = new ContractEncoder(this.registryLogic);
      const encoded = await Promise.all(contracts.map(async (contract) => contractEncoder.encode("remove", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.storage = storage;
    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryLogic_default, options, storage);
    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryRouter_default, options, storage);
  }
  async updateSigner(signer) {
    this.registryLogic.updateSignerOrProvider(signer);
    this.registryRouter.updateSignerOrProvider(signer);
  }
  async getContractMetadataURI(chainId, address) {
    return await this.registryLogic.read("getMetadataUri", [chainId, await resolveAddress(address)]);
  }
  async getContractMetadata(chainId, address) {
    const uri = await this.getContractMetadataURI(chainId, address);
    if (!uri) {
      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);
    }
    return await this.storage.downloadJSON(uri);
  }
  async getContractAddresses(walletAddress) {
    return (await this.registryLogic.read("getAll", [await resolveAddress(walletAddress)])).filter((result) => utils_exports.isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== lib_exports.AddressZero).map((result) => ({
      address: result.deploymentAddress,
      chainId: result.chainId.toNumber()
    }));
  }
};
function extractFunctionParamsFromAbi(abi, functionName) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
async function computeCloneFactoryAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "TWCloneFactory"
  }, clientId, secretKey)).transaction.predictedAddress;
}
function convertParamValues(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((p, index) => {
    if (p === "tuple" || p.endsWith("[]")) {
      if (typeof constructorParamValues[index] === "string") {
        return JSON.parse(constructorParamValues[index]);
      } else {
        return constructorParamValues[index];
      }
    }
    if (p === "bytes32") {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return utils_exports.hexZeroPad(constructorParamValues[index], 32);
    }
    if (p.startsWith("bytes")) {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return constructorParamValues[index];
    }
    if (p.startsWith("uint") || p.startsWith("int")) {
      return BigNumber.from(constructorParamValues[index].toString());
    }
    return constructorParamValues[index];
  });
}
async function deployCreate2Factory(signer, options) {
  var _a, _b;
  invariant(signer.provider, "No provider");
  const deploymentInfo = await computeCreate2FactoryTransaction(signer.provider);
  if (deploymentInfo.transaction.length > 0) {
    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(deploymentInfo.valueToSend)) {
      await (await signer.sendTransaction({
        to: deploymentInfo.signer,
        value: deploymentInfo.valueToSend
      })).wait();
    }
    try {
      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);
      (_a = options == null ? void 0 : options.notifier) == null ? void 0 : _a.call(options, "deploying", "create2Factory");
      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();
      (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deployed", "create2Factory");
    } catch (err) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);
    }
  }
  return deploymentInfo.deployment;
}
var SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];
function getDefaultTrustedForwarders(chainId) {
  var _a, _b;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const biconomyForwarder = chainEnum ? (_a = CONTRACT_ADDRESSES[chainEnum]) == null ? void 0 : _a.biconomyForwarder : AddressZero;
  const openzeppelinForwarder = chainEnum ? (_b = CONTRACT_ADDRESSES[chainEnum]) == null ? void 0 : _b.openzeppelinForwarder : AddressZero;
  return [openzeppelinForwarder, biconomyForwarder].filter((a) => a !== AddressZero);
}
function overrideRecipientAddress(signerAddress, recipient) {
  if (recipient === lib_exports.AddressZero) {
    return signerAddress;
  }
  return recipient;
}
async function getDeployArguments(contractType, metadata, contractURI, signer) {
  const signerAddress = metadata.defaultAdmin || await signer.getAddress();
  const trustedForwarders = [];
  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
    trustedForwarders.push(...metadata.trusted_forwarders);
  }
  switch (contractType) {
    case NFTDropInitializer.contractType:
    case NFTCollectionInitializer.contractType:
      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
    case SignatureDropInitializer.contractType:
      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
    case MultiwrapInitializer.contractType:
      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
    case EditionDropInitializer.contractType:
    case EditionInitializer.contractType:
      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
    case TokenDropInitializer.contractType:
    case TokenInitializer.contractType:
      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
    case VoteInitializer.contractType:
      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
    case SplitInitializer.contractType:
      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
    case MarketplaceInitializer.contractType:
    case MarketplaceV3Initializer.contractType:
      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
    case PackInitializer.contractType:
      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
    default:
      return [];
  }
}
async function getTrustedForwarders(provider, storage, contractName) {
  const chainId = (await provider.getNetwork()).chainId;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const trustedForwarders = contractName && contractName === PackInitializer.name ? [] : chainEnum ? getDefaultTrustedForwarders(chainId) : [await computeForwarderAddress(provider, storage)];
  return trustedForwarders;
}
var APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  },
  [ChainId.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
    // TODO
  }
};
function getApprovedImplementation(chainId, contractType) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType in approvedImpls) {
      return approvedImpls[contractType];
    }
  }
  return null;
}
var ContractFactory2 = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, options) {
    super(network, factoryAddr, TWFactory_default, options, storage);
    // Map from contract type to version to deploy specific versions by default
    __publicField(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [MarketplaceV3Initializer.contractType]: 3,
      [PackInitializer.contractType]: 2
    });
    __publicField(this, "deploy", buildTransactionFunction(async (contractType, contractMetadata, eventEmitter, version, options, onExecute) => {
      const contract = PREBUILT_CONTRACTS_MAP[contractType];
      const metadata = await contract.schema.deploy.parseAsync(contractMetadata);
      const contractURI = await this.storage.upload(metadata);
      const implementationAddress = await this.getImplementation(contract, version) || void 0;
      if (!implementationAddress || implementationAddress === lib_exports.AddressZero) {
        throw new Error(`No implementation found for ${contractType}`);
      }
      const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);
      const signer = this.getSigner();
      invariant(signer, "A signer is required to deploy contracts");
      const args = await getDeployArguments(contractType, metadata, contractURI, signer);
      const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", args);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = (options == null ? void 0 : options.saltForProxyDeploy) ? utils_exports.id(options.saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    // TODO once IContractFactory is implemented, this can be probably be moved to its own class
    __publicField(this, "deployProxyByImplementation", buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, saltForProxyDeploy, onExecute) => {
      const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = saltForProxyDeploy ? utils_exports.id(saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    this.storage = storage;
  }
  /**
   *
   * @param contractType - the contract type to deploy
   * @param metadata - the metadata for the contract
   * @param contractURI - the contract URI
   * @returns
   * @internal
   */
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = [];
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    const signerAddress = await this.getSignerAddress();
    switch (contractType) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
      case MarketplaceV3Initializer.contractType:
        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceV3Metadata.platform_fee_recipient), marketplaceV3Metadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getImplementation(contract, version) {
    const encodedType = utils_exports.formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version === void 0) {
      return approvedImplementation;
    }
    return this.read("getImplementation", [encodedType, version !== void 0 ? version : this.DEFAULT_VERSION_MAP[contract.contractType]]);
  }
  async getLatestVersion(contractType) {
    const name = getContractName(contractType);
    if (!name) {
      throw new Error(`Invalid contract type ${contractType}`);
    }
    const encodedType = utils_exports.formatBytes32String(name);
    return this.read("currentVersion", [encodedType]);
  }
};
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, storage, TWRegistryABI, options) {
    super(network, registryAddress, TWRegistryABI, options, storage);
    __publicField(this, "addContract", buildTransactionFunction(async (contractAddress) => {
      return await this.addContracts.prepare([contractAddress]);
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("add", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contractAddress) => {
      return await this.removeContracts.prepare([contractAddress]);
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("remove", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
  }
  async getContractAddresses(walletAddress) {
    return (await this.read("getAll", [await resolveAddress(walletAddress)])).filter((adr) => utils_exports.isAddress(adr) && adr.toLowerCase() !== lib_exports.AddressZero);
  }
};
var LoyaltyCardContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var LoyaltyCardContractDeploy = (() => LoyaltyCardContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var AirdropContractInput = (() => CommonContractSchema.merge(CommonSymbolSchema))();
var AirdropContractDeploy = (() => AirdropContractInput.merge(CommonTrustedForwarderSchema))();
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  invariant(signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await deployCreate2Factory(signer);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    const tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
  return address;
}
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function directDeployDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let signer = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  let gasLimit = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 7e6;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await getCreate2FactoryAddress(provider);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
async function predictAddressDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let provider = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant((extendedMetadata == null ? void 0 : extendedMetadata.deployType) === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
var ThirdwebSDK = class _ThirdwebSDK extends RPCConnectionHandler {
  /**
   * @internal
   * should never be accessed directly, use {@link ThirdwebSDK.getPublisher} instead
   */
  /**
   * Internal handler for uploading and downloading files
   */
  /**
   * New contract deployer
   */
  /**
   * Contract verifier
   */
  /**
   * The registry of deployed contracts
   */
  /**
   * Interact with the connected wallet
   */
  /**
   * Upload and download files from IPFS or from your own storage service
   */
  constructor(network) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 ? arguments[2] : void 0;
    const apiKeyType = "clientId";
    let warnMessage = `No API key. Please provide a ${apiKeyType}. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key`;
    checkClientIdOrSecretKey(warnMessage, options.clientId, options.secretKey);
    options = addChainToSupportedChains(network, options);
    super(network, options);
    /**
     * @internal
     * the cache of contracts that we have already seen
     */
    __publicField(this, "contractCache", /* @__PURE__ */ new Map());
    setSupportedChains(options == null ? void 0 : options.supportedChains);
    const configuredStorage = createStorage(storage, options);
    this.storage = configuredStorage;
    this.storageHandler = configuredStorage;
    this.wallet = new UserWallet(network, options, configuredStorage);
    this.deployer = new ContractDeployer(network, options, configuredStorage);
    this.verifier = new ContractVerifier(network, options, configuredStorage);
    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);
    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);
  }
  /**
   * Get an instance of the thirdweb SDK based on an AbstractWallet
   *
   * @example
   * ```javascript
   * import { ThirdwebSDK } from "@thirdweb-dev/sdk"
   *
   * const wallet = new AbstractWalletImplementation();
   * const sdk = await ThirdwebSDK.fromWallet(wallet, "mainnet");
   * ```
   *
   * @param wallet - the implementation of the AbstractWallet class to use for signing
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @beta
   */
  static async fromWallet(wallet, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const signer = await wallet.getSigner();
    return _ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  /**
   * Get an instance of the thirdweb SDK based on an existing ethers signer
   *
   * @example
   * ```javascript
   * // get a signer from somewhere (createRandom is being used purely for example purposes)
   * const signer = Wallet.createRandom();
   *
   * // get an instance of the SDK with the signer already setup
   * const sdk = ThirdwebSDK.fromSigner(signer, "mainnet");
   * ```
   *
   * @param signer - a ethers Signer to be used for transactions
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @beta
   */
  static fromSigner(signer, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    let signerWithProvider = signer;
    if (network) {
      try {
        const provider = getChainProvider(network, options);
        signerWithProvider = signer.connect(provider);
      } catch {
      }
    }
    const sdk = new _ThirdwebSDK(network || signerWithProvider, network ? addChainToSupportedChains(network, options) : options, storage);
    sdk.updateSignerOrProvider(signerWithProvider);
    return sdk;
  }
  /**
   * Get an instance of the thirdweb SDK based on a private key.
   *
   * @remarks
   * This should only be used for backend services or scripts, with the private key stored in a secure way.
   * **NEVER** expose your private key to the public in any way.
   *
   * @example
   * ```javascript
   * const sdk = ThirdwebSDK.fromPrivateKey("SecretPrivateKey", "mainnet");
   * ```
   *
   * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**
   * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
   * @param options - the SDK options to use
   * @param storage - optional storage implementation to use
   * @returns An instance of the SDK
   *
   * @public
   */
  static fromPrivateKey(privateKey, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const provider = getChainProvider(network, options);
    const signer = new Wallet(privateKey, provider);
    return new _ThirdwebSDK(signer, addChainToSupportedChains(network, options), storage);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/wallets/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  /**
   * Get an instance of a NFT Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const dropContract = await sdk.getDropContract("0x1234...");
   * + const dropContract = await sdk.getContract("0x1234...", "nft-drop");
   * ```
   */
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  /**
   * Get an instance of a Signature Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getSignatureDrop("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "signature-drop");
   * ```
   */
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  /**
   * Get an instance of a NFT Collection Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const signatureDrop = await sdk.getNFTCollection("0x1234...");
   * + const signatureDrop = await sdk.getContract("0x1234...", "nft-collection");
   * ```
   */
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  /**
   * Get an instance of a Edition Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const editionDrop = await sdk.getEditionDrop("0x1234...");
   * + const editionDrop = await sdk.getContract("0x1234...", "edition-drop");
   * ```
   */
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  /**
   * Get an instance of a Edition contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const edition = await sdk.getEdition("0x1234...");
   * + const edition = await sdk.getContract("0x1234...", "edition");
   * ```
   */
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  /**
   * Get an instance of a Token Drop contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const tokenDrop = await sdk.getTokenDrop("0x1234...");
   * + const tokenDrop = await sdk.getContract("0x1234...", "token-drop");
   * ```
   */
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  /**
   * Get an instance of a Token contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const token = await sdk.getToken("0x1234...");
   * + const token = await sdk.getContract("0x1234...", "token");
   * ```
   */
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  /**
   * Get an instance of a Vote contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const vote = await sdk.getVote("0x1234...");
   * + const vote = await sdk.getContract("0x1234...", "vote");
   * ```
   */
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  /**
   * Get an instance of a Split contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const split = await sdk.getSplit("0x1234...");
   * + const split = await sdk.getContract("0x1234...", "split");
   * ```
   */
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplace("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace");
   * ```
   */
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  /**
   * Get an instance of a Marketplace contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const marketplace = await sdk.getMarketplaceV3("0x1234...");
   * + const marketplace = await sdk.getContract("0x1234...", "marketplace-v3");
   * ```
   */
  async getMarketplaceV3(contractAddress) {
    return await this.getContract(contractAddress, "marketplace-v3");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const pack = await sdk.getPack("0x1234...");
   * + const pack = await sdk.getContract("0x1234...", "pack");
   * ```
   */
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  /**
   * Get an instance of a Pack contract
   * @param contractAddress - the address of the deployed contract
   * @deprecated
   * This method is deprecated and will be removed in a future major version. You should use {@link getContract} instead.
   * ```diff
   * - const multiWrap = await sdk.getMultiwrap("0x1234...");
   * + const multiWrap = await sdk.getContract("0x1234...", "multiwrap");
   * ```
   */
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}");
   * ```
   */
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @param contractType - the {@link ContractType} of the contract to load
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}", "nft-drop");
   * ```
   */
  /**
   * Get an instance of a Custom ThirdwebContract
   * @param address - the address of the deployed contract
   * @param abi - the ABI ({@link ContractInterface}) of the contract to load
   * @returns The contract
   * @public
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}", ABI);
   * ```
   */
  async getContract(address, contractTypeOrABI) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    if (resolvedAddress in GENERATED_ABI) {
      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      try {
        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);
        newContract = await this.getContractFromAbi(resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(metadata.abi), this.getProvider(), this.options, this.storage));
      } catch (e) {
        const resolvedContractType = await this.resolveContractType(resolvedAddress);
        if (resolvedContractType && resolvedContractType !== "custom") {
          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(resolvedAddress, this.getProvider(), this.storage);
          newContract = await this.getContractFromAbi(resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(contractAbi), this.getProvider(), this.options, this.storage));
        } else {
          throw e;
        }
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);
    }
    this.contractCache.set(resolvedAddress, newContract);
    return newContract;
  }
  /**
   * @internal
   * @deprecated use {@link getContract} directly instead
   */
  async getBuiltInContract(address, contractType) {
    return await this.getContract(address, contractType);
  }
  /**
   * @param contractAddress - the address of the contract to attempt to resolve the contract type for
   * @returns The {@link ContractType} for the given contract address
   *
   */
  async resolveContractType(contractAddress) {
    try {
      const IThirdwebContractABI = (await import("./IThirdwebContract-QDPOONHT.js")).default;
      const contract = new Contract(
        await resolveAddress(contractAddress),
        IThirdwebContractABI,
        // !provider only! - signer can break things here!
        this.getProvider()
      );
      const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  /**
   * Return all the contracts deployed by the specified address
   * @param walletAddress - the deployed address
   * @example
   * ```javascript
   * const contracts = sdk.getContractList("{{wallet_address}}");
   * ```
   */
  async getContractList(walletAddress) {
    var _a;
    const addresses = await ((_a = await this.deployer.getRegistry()) == null ? void 0 : _a.getContractAddresses(await resolveAddress(walletAddress))) || [];
    const chainId = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(addresses.map(async (address) => {
      return {
        address,
        chainId,
        contractType: () => this.resolveContractType(address),
        metadata: async () => (await this.getContract(address)).metadata.get(),
        extensions: async () => getAllDetectedExtensionNames((await this.getContract(address)).abi)
      };
    }));
  }
  async getMultichainContractList(walletAddress) {
    let chains = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultChains;
    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);
    const chainMap = chains.reduce((acc, chain) => {
      acc[chain.chainId] = chain;
      return acc;
    }, {});
    const sdkMap = {};
    return contracts.map((_ref) => {
      let {
        address,
        chainId
      } = _ref;
      if (!chainMap[chainId]) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
      try {
        let chainSDK = sdkMap[chainId];
        if (!chainSDK) {
          chainSDK = new _ThirdwebSDK(chainId, {
            ...this.options,
            // need to disable readonly settings for this to work
            readonlySettings: void 0,
            // @ts-expect-error - zod doesn't like this
            supportedChains: chains
          }, this.storage);
          sdkMap[chainId] = chainSDK;
        }
        return {
          address,
          chainId,
          contractType: () => chainSDK.resolveContractType(address),
          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),
          extensions: async () => getAllDetectedExtensionNames((await chainSDK.getContract(address)).abi)
        };
      } catch (e) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
    });
  }
  /**
   * Update the active signer or provider for all contracts
   * @param network - the new signer or provider
   */
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());
    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  /**
   * Get an instance of a Custom contract from a json ABI
   * @param address - the address of the deployed contract
   * @param abi - the JSON abi
   * @returns The contract
   * @beta
   * @example
   * ```javascript
   * // Import your ABI from a JSON file
   * import myABI from "./path/to/myABI.json";
   *
   * const contract = sdk.getContractFromAbi(
   *   "{{contract_address}}",
   *   // Pass in the "abi" field from the JSON file
   *   myABI.abi
   * );
   * ```
   */
  async getContractFromAbi(address, abi) {
    const [resolvedAddress, {
      SmartContract
    }] = await Promise.all([resolveAddress(address), import("./smart-contract-ac432d60.browser.esm-5Q74DFA5.js")]);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const parsedABI = typeof abi === "string" ? JSON.parse(abi) : abi;
    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, parsedABI, this.storageHandler, this.options, (await provider.getNetwork()).chainId);
    this.contractCache.set(resolvedAddress, contract);
    return contract;
  }
  /**
   * Get the native balance of a given address (wallet or contract)
   * @example
   * ```javascript
   * const balance = await sdk.getBalance("0x...");
   * console.log(balance.displayValue);
   * ```
   * @param address - the address to check the balance for
   */
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));
  }
  /**
   * @internal
   */
  getPublisher() {
    return this._publisher;
  }
};
function addChainToSupportedChains(network, options) {
  if (isChainConfig(network)) {
    options = {
      ...options,
      // @ts-expect-error - we know that the network is assignable despite the readonly mismatch
      supportedChains: [network, ...(options == null ? void 0 : options.supportedChains) || []]
    };
  }
  return options;
}
var THIRDWEB_DEPLOYER2 = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    /**
     * @internal
     * should never be accessed directly, use {@link ContractDeployer.getFactory} instead
     */
    /**
     * @internal
     * should never be accessed directly, use {@link ContractDeployer.getRegistry} instead
     */
    __publicField(this, "transactionListener", (event) => {
      if (event.status === "submitted") {
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: event.transactionHash
        });
      }
    });
    /**
     * Deploys an NFT Collection contract
     *
     * @remarks Deploys an NFT Collection contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployNFTCollection({
     *   name: "My Collection",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployNFTCollection", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new NFTDrop contract
     *
     * @remarks Deploys an NFT Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployNFTDrop({
     *   name: "My Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployNFTDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new LoyaltyCard contract
     *
     * @remarks Deploys a LoyaltyCard contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployLoyaltyCard({
     *   name: "My Loyalty Program",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployLoyaltyCard", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await LoyaltyCardContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points, parsedMetadata.platform_fee_basis_points, parsedMetadata.platform_fee_recipient];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "LoyaltyCard", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new OpenEditionERC721 contract
     *
     * @remarks Deploys a OpenEdition contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployOpenEdition({
     *   name: "My Open Edition",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployOpenEdition", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await DropErc721ContractSchema.deploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points];
      return await this.deployPublishedContract.prepare(THIRDWEB_DEPLOYER2, "OpenEditionERC721", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new SignatureDrop contract
     *
     * @remarks Deploys a SignatureDrop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deploySignatureDrop({
     *   name: "My Signature Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deploySignatureDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Multiwrap contract
     *
     * @remarks Deploys a Multiwrap contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMultiwrap({
     *   name: "My Multiwrap",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     * @beta
     */
    __publicField(this, "deployMultiwrap", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Edition contract
     *
     * @remarks Deploys an Edition contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployEdition({
     *   name: "My Edition",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployEdition", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new EditionDrop contract
     *
     * @remarks Deploys an Edition Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployEditionDrop({
     *   name: "My Edition Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployEditionDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Token contract
     *
     * @remarks Deploys a Token contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployToken({
     *   name: "My Token",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployToken", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Token Drop contract
     *
     * @remarks Deploys a Token Drop contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployTokenDrop({
     *   name: "My Token Drop",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployTokenDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Marketplace contract
     *
     * @remarks Deploys a Marketplace contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMarketplace({
     *   name: "My Marketplace",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployMarketplace", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Marketplace-V3 contract
     *
     * @remarks Deploys a Marketplace-V3 contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployMarketplaceV3({
     *   name: "My Marketplace",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployMarketplaceV3", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Pack contract
     *
     * @remarks Deploys a Pack contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployPack({
     *   name: "My Pack",
     *   primary_sale_recipient: "your-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployPack", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Split contract
     *
     * @remarks Deploys a Split contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deploySplit({
     *   name: "My Split",
     *   primary_sale_recipient: "your-address",
     *   recipients: [
     *    {
     *      address: "your-address",
     *      sharesBps: 80 * 100, // 80%
     *    },
     *    {
     *      address: "another-address",
     *      sharesBps: 20 * 100, // 20%
     *    },
     *   ],
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deploySplit", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata, "latest", options);
    }));
    /**
     * Deploys a new Vote contract
     *
     * @remarks Deploys an Vote contract and returns the address of the deployed contract
     *
     * @example
     * ```javascript
     * const contractAddress = await sdk.deployer.deployVote({
     *   name: "My Vote",
     *   primary_sale_recipient: "your-address",
     *   voting_token_address: "your-token-contract-address",
     * });
     * ```
     * @param metadata - the contract metadata
     * @returns The address of the deployed contract
     */
    __publicField(this, "deployVote", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployAirdropERC20", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC20", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC721", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC721", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC1155", buildDeployTransactionFunction(async (metadata, options) => {
      var _a;
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await ((_a = this.getSigner()) == null ? void 0 : _a.getAddress());
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC1155", deployArgs, "latest", options);
    }));
    /**
     * Deploys a new prebuilt contract
     *
     * @public
     * @param contractType - the type of contract to deploy
     * @param contractMetadata - the metadata to deploy the contract with
     * @param version - the version of the contract to deploy
     * @returns A promise of the address of the newly deployed contract
     */
    __publicField(this, "deployBuiltInContract", buildDeployTransactionFunction(/* @__PURE__ */ (() => {
      var _this = this;
      return async function(contractType, contractMetadata) {
        let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
        let options = arguments.length > 3 ? arguments[3] : void 0;
        const signer = _this.getSigner();
        invariant(signer, "A signer is required to deploy contracts");
        const parsedMetadata = {
          app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType],
          ...await PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parseAsync(contractMetadata)
        };
        if (_this.hasLocalFactory()) {
          let parsedVersion = void 0;
          try {
            parsedVersion = parseInt(version);
            if (isNaN(parsedVersion)) {
              parsedVersion = void 0;
            }
          } catch (e) {
            parsedVersion = void 0;
          }
          const factory = await _this.getFactory();
          if (!factory) {
            throw new Error("Factory not found");
          }
          factory.on(EventType.Transaction, _this.transactionListener);
          return factory.deploy.prepare(contractType, parsedMetadata, _this.events, parsedVersion, options, () => {
            factory.off(EventType.Transaction, _this.transactionListener);
          });
        }
        const contractName = getContractName(contractType);
        invariant(contractName, "Contract name not found");
        const contractURI = await _this.storage.upload(parsedMetadata);
        const constructorParams = await getDeployArguments(contractType, parsedMetadata, contractURI, signer);
        const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER2, contractName, version);
        return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    /**
     * Deploy any published contract by its name
     * @param publisherAddress - the address of the publisher
     * @param contractName - the name of the contract to deploy
     * @param constructorParams - the constructor params to pass to the contract
     *
     * @deprecated use deployPublishedContract instead
     * @internal
     */
    __publicField(this, "deployReleasedContract", buildDeployTransactionFunction(/* @__PURE__ */ (() => {
      var _this2 = this;
      return async function(publisherAddress, contractName, constructorParams) {
        let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
        let options = arguments.length > 4 ? arguments[4] : void 0;
        const publishedContract = await _this2.fetchPublishedContractFromPolygon(publisherAddress, contractName, version);
        return await _this2.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    /**
     * Deploy any published contract by its name
     * @param publisherAddress - the address of the publisher
     * @param contractName - the name of the contract to deploy
     * @param constructorParams - the constructor params to pass to the contract
     * @param version - Optional: the version of the contract to deploy or "latest"
     * @param options - Optional: the deploy options
     */
    __publicField(this, "deployPublishedContract", this.deployReleasedContract);
    /**
     * Deploy a proxy contract of a given implementation via the given factory
     * @param factoryAddress - the address of the factory
     * @param implementationAddress - the address of the implementation
     * @param implementationAbi - the abi of the implementation
     * @param initializerFunction - the initializer function to call
     * @param initializerArgs - the initializer args to pass to the initializer function
     */
    __publicField(this, "deployViaFactory", buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs, saltForProxyDeploy) => {
      const resolvedFactoryAddress = await resolveAddress(factoryAddress);
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const signer = this.getSigner();
      invariant(signer, "signer is required");
      const proxyFactory = new ContractFactory2(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      proxyFactory.on(EventType.Transaction, this.transactionListener);
      return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, saltForProxyDeploy, () => {
        proxyFactory.off(EventType.Transaction, this.transactionListener);
      });
    }));
    /**
     * Deploy a proxy contract of a given implementation directly
     * @param implementationAddress - the address of the implementation
     * @param implementationAbi - the abi of the implementation
     * @param initializerFunction - the initializer function to call
     * @param initializerArgs - the initializer args to pass to the initializer function
     */
    __publicField(this, "deployProxy", buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedAddress = await resolveAddress(implementationAddress);
      const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const {
        TWProxy__factory
      } = await import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.esm-RFOKLC7K.js");
      return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);
    }));
    /**
     * Deploy a proxy contract of a given implementation via thirdweb's Clone factory
     * @param publishMetadataUri - the uri of the publish metadata
     * @param constructorParamValues - the constructor param values
     * @param deployMetadata - the deploy metadata
     * @param signer - the signer to use
     * @param options - the deploy options
     * @internal
     */
    __publicField(this, "deployViaAutoFactory", buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options) => {
      var _a, _b, _c;
      const create2Factory = await deployCreate2Factory(signer, options);
      const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory, this.options.clientId, this.options.secretKey);
      const implementationAddress = (_a = deploymentInfo.find((i) => i.type === "implementation")) == null ? void 0 : _a.transaction.predictedAddress;
      const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
      const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
        return i.type !== "infra";
      }).map((i) => i.transaction);
      const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
        return i.type === "infra";
      }).map((i) => i.transaction);
      await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options);
      for (const tx of transactionsforDirectDeploy) {
        try {
          await deployContractDeterministic(signer, tx, options);
        } catch (e) {
          console.debug(`Error deploying contract at ${tx.predictedAddress}`, e == null ? void 0 : e.message);
          throw e;
        }
      }
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory, this.options.clientId, this.options.secretKey);
      (_b = options == null ? void 0 : options.notifier) == null ? void 0 : _b.call(options, "deploying", "proxy");
      const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues, options == null ? void 0 : options.saltForProxyDeploy);
      (_c = options == null ? void 0 : options.notifier) == null ? void 0 : _c.call(options, "deployed", "proxy");
      return proxyDeployTransaction;
    }));
    /**
     * Deploy a proxy contract of a given implementation via a custom factory
     * @param constructorParamValues - the constructor param values
     * @param deployMetadata - the deploy metadata
     * @param signer - the signer to use
     * @param chainId - the chain id to deploy to
     * @internal
     */
    __publicField(this, "deployViaCustomFactory", buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {
      var _a, _b, _c, _d, _e, _f;
      const customFactoryAddress = (_c = (_b = (_a = deployMetadata.extendedMetadata) == null ? void 0 : _a.factoryDeploymentData) == null ? void 0 : _b.customFactoryInput) == null ? void 0 : _c.customFactoryAddresses[chainId];
      const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);
      invariant(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);
      invariant((_f = (_e = (_d = deployMetadata.extendedMetadata) == null ? void 0 : _d.factoryDeploymentData) == null ? void 0 : _e.customFactoryInput) == null ? void 0 : _f.factoryFunction, `customFactoryFunction not set'`);
      const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage, this.options);
      const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((p) => p.type);
      const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);
      let deployedImplementationAddress;
      const deployTransaction = await Transaction.fromContractInfo({
        contractAddress: resolvedCustomFactoryAddress,
        contractAbi: customFactoryMetadata.abi,
        provider: this.getProvider(),
        signer,
        method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
        args: factoryFunctionparamValues,
        parse: () => {
          return deployedImplementationAddress;
        },
        storage: this.storage
      });
      deployedImplementationAddress = await deployTransaction.simulate();
      return deployTransaction;
    }));
    /**
     * @internal
     * @param publishMetadataUri - the uri of the publish metadata
     * @param constructorParamValues - the constructor param values
     * @param options - the deploy options
     */
    __publicField(this, "deployContractFromUri", buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options) => {
      var _a, _b;
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const {
        compilerMetadata,
        extendedMetadata
      } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
      const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const isNetworkEnabled = ((_a = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _a.networksEnabled.includes(chainId)) || ((_b = extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) == null ? void 0 : _b.allNetworks);
      if ((extendedMetadata == null ? void 0 : extendedMetadata.networksForDeployment) && !isNetworkEnabled && compilerMetadata.name !== "AccountFactory") {
        throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);
      }
      if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== "standard") && !forceDirectDeploy) {
        if (extendedMetadata.deployType === "customFactory") {
          return await this.deployViaCustomFactory.prepare(constructorParamValues, {
            compilerMetadata,
            extendedMetadata
          }, signer, chainId);
        } else {
          invariant(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
          const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
          const paramValues2 = convertParamValues(initializerParamTypes, constructorParamValues);
          const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
          if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
            return await this.deployViaAutoFactory.prepare(publishMetadataUri, {
              compilerMetadata,
              extendedMetadata
            }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options);
          }
          const resolvedImplementationAddress = await resolveAddress(implementationAddress);
          invariant(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);
          if (extendedMetadata.isDeployableViaFactory) {
            invariant(extendedMetadata.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
            const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];
            invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
            const resolvedFactoryAddress = await resolveAddress(factoryAddress);
            return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options == null ? void 0 : options.saltForProxyDeploy);
          } else if (extendedMetadata.isDeployableViaProxy) {
            return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          }
        }
      }
      const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
      if (!utils_exports.isHexString(bytecode)) {
        throw new Error(`Contract bytecode is invalid.

${bytecode}`);
      }
      const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
      const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);
      return this.deployContractWithAbi.prepare(compilerMetadata.abi, bytecode, paramValues);
    }));
    /**
     * @public
     * @param abi - the abi of the contract
     * @param bytecode - the bytecode of the contract
     * @param constructorParams - the constructor params to pass to the contract
     */
    __publicField(this, "deployContractWithAbi", buildDeployTransactionFunction(async (abi, bytecode, constructorParams) => {
      const signer = this.getSigner();
      const provider = this.getProvider();
      invariant(signer, "Signer is required to deploy contracts");
      const factory = new ContractFactory(abi, bytecode).connect(signer);
      return new DeployTransaction({
        args: constructorParams,
        provider,
        signer,
        factory,
        storage: this.storage,
        events: this.events
      });
    }));
    this.storage = storage;
    this.events = new eventemitter3_default();
    this.getFactory();
    this.getRegistry();
  }
  /**
   * @internal
   * @param contractType - the type of contract to deploy
   */
  async getLatestBuiltInContractVersion(contractType) {
    const factory = await this.getFactory();
    if (!factory) {
      throw new Error("Factory not found");
    }
    return await factory.getLatestVersion(contractType);
  }
  /**
   * Deploy any published contract by its name
   * @param contractName - the name of the contract to deploy
   * @param constructorParams - the constructor params to pass to the contract
   * @param publisherAddress - the address of the publisher
   * @param version - Optional: the version of the contract to deploy or "latest"
   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address
   */
  async deployPublishedContractDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Signer is required");
    return directDeployDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, signer, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  /**
   * Predict Create2 address of a contract
   * @param contractName - the name of the contract
   * @param constructorParams - the constructor params to pass to the contract
   * @param publisherAddres -s the address of the publisher
   * @param version - Optional: the version of the contract to deploy or "latest"
   * @param saltForCreate2 - Optional: salt for create2 deployment, will determine deployment address
   */
  async predictAddressDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const provider = this.getProvider();
    invariant(provider, "Provider is required");
    return predictAddressDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, provider, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  /**
   * @internal
   */
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      if (!registryAddress) {
        return void 0;
      }
      const TWRegistryABI = (await import("./TWRegistry-QVE3TOQD.js")).default;
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.storage, TWRegistryABI, this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref3) => {
      let {
        chainId
      } = _ref3;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      if (!factoryAddress) {
        return void 0;
      }
      const factory = new ContractFactory2(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      return factory;
    });
  }
  /**
   * @internal
   */
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var _a, _b;
    (_a = this._factory) == null ? void 0 : _a.then((factory) => {
      factory == null ? void 0 : factory.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    (_b = this._registry) == null ? void 0 : _b.then((registry) => {
      registry == null ? void 0 : registry.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  /**
   * @public
   * @param publishMetadataUri - the uri of the publish metadata
   * @param options - the deploy options
   */
  async getTransactionsForDeploy(publishMetadataUri, options) {
    let transactions = [];
    const provider = this.getProvider();
    invariant(provider, "A provider is required");
    const {
      extendedMetadata
    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
    const forceDirectDeploy = (options == null ? void 0 : options.forceDirectDeploy) || false;
    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === "autoFactory") && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
      if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());
        transactions.push({
          contractType: "create2Factory",
          addresses: [create2FactoryAddress]
        });
        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress, this.options.clientId, this.options.secretKey);
        const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
          return i.type !== "infra";
        }).map((i) => i.transaction);
        transactionsforDirectDeploy.forEach((tx) => {
          transactions.push({
            contractType: "preset",
            addresses: [tx.predictedAddress]
          });
        });
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
          return i.type === "infra";
        }).map((i) => i.transaction);
        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);
        transactionBatches.forEach((batch) => {
          const addresses = batch.map((tx) => tx.predictedAddress);
          transactions.push({
            contractType: "infra",
            addresses
          });
        });
      }
      transactions = (await Promise.all(transactions.map(async (tx) => {
        const addresses = (await Promise.all(tx.addresses.map(async (address) => {
          const isDeployed = await isContractDeployed(address, provider);
          return isDeployed ? null : address;
        }))).filter(Boolean);
        return addresses.length > 0 ? tx : null;
      }))).filter(Boolean);
      transactions.push({
        contractType: "proxy",
        addresses: []
      });
    } else {
      transactions.push({
        contractType: "custom",
        addresses: []
      });
    }
    return transactions;
  }
  /**
   * Listen to all deploy transactions from this deployer
   * @param listener - the listener to add
   */
  addDeployListener(listener) {
    this.events.on("contractDeployed", listener);
  }
  /**
   * Remove a deploy listener
   * @param listener - the listener to remove
   */
  removeDeployListener(listener) {
    this.events.off("contractDeployed", listener);
  }
  /**
   * Remove all deploy listeners
   */
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  // PRIVATE METHODS
  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version) {
    const address = await resolveAddress(publisherAddress);
    const publishedContract = await new ThirdwebSDK("polygon", {
      clientId: this.options.clientId,
      secretKey: this.options.secretKey
    }, this.storage).getPublisher().getVersion(address, contractName, version);
    if (!publishedContract) {
      throw new Error(`No published contract found for '${contractName}' at version '${version}' by '${address}'`);
    }
    return publishedContract;
  }
  hasLocalFactory() {
    return !!getProcessEnv("factoryAddress");
  }
};

// node_modules/@thirdweb-dev/sdk/dist/getStatus-7ee3964f.browser.esm.js
var import_dist244 = __toESM(require_dist());
var import_dist245 = __toESM(require_dist2());
var import_dist246 = __toESM(require_dist3());
init_lib();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/thirdweb.js
var import_dist169 = __toESM(require_dist());
var import_dist170 = __toESM(require_dist2());
var import_dist171 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/client/client.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/client-id.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/hashes/esm/sha256.js
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/hashes/esm/_md.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
function sha2562(value, to) {
  const bytes2 = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes2;
  }
  return uint8ArrayToHex(bytes2);
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha2562(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  if (secretKey) {
    return {
      ...rest,
      clientId: computeClientIdFromSecretKey(secretKey),
      secretKey
    };
  }
  if (clientId) {
    return {
      ...rest,
      clientId: options.clientId,
      secretKey: void 0
    };
  }
  throw new Error("clientId or secretKey must be provided");
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getBalance.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getLogs.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getStorageAt.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_sendRawTransaction.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/prepare-transaction.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
function prepareTransaction(options, info) {
  if (info) {
    options.__preparedMethod = info.preparedMethod;
    options.__contract = info.contract;
  }
  return options;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/types.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/prepare-contract-call.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
function prepareContractCall(options) {
  const { contract, method, params, ...rest } = options;
  const preparedMethodPromise = () => (async () => {
    var _a, _b;
    if (Array.isArray(method)) {
      return method;
    }
    if (isAbiFunction(method)) {
      return prepareMethod(method);
    }
    if (typeof method === "function") {
      return prepareMethod(
        // @ts-expect-error - method *is* function in this case
        await method(contract)
      );
    }
    if (typeof method === "string" && method.startsWith("function ")) {
      const abiItem = parseAbiItem(method);
      if (abiItem.type === "function") {
        return prepareMethod(abiItem);
      }
      throw new Error(`"method" passed is not of type "function"`);
    }
    if (contract.abi && ((_a = contract.abi) == null ? void 0 : _a.length) > 0) {
      const abiFunction = (_b = contract.abi) == null ? void 0 : _b.find((item) => item.type === "function" && item.name === method);
      if (abiFunction) {
        return prepareMethod(abiFunction);
      }
    }
    throw new Error(`Could not resolve method "${method}".`);
  })();
  return prepareTransaction({
    ...rest,
    // these always inferred from the contract
    to: contract.address,
    chain: contract.chain,
    client: contract.client,
    data: async () => {
      let preparedM;
      if (Array.isArray(method)) {
        preparedM = method;
      } else {
        preparedM = await preparedMethodPromise();
      }
      if (preparedM[1].length === 0) {
        return preparedM[0];
      }
      return preparedM[0] + encodeAbiParameters(
        preparedM[1],
        // @ts-expect-error - TODO: fix this type issue
        await resolvePromisedValue(params ?? [])
      ).slice(2);
    }
  }, {
    preparedMethod: preparedMethodPromise,
    contract
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/resolve-method.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/estimate-gas-cost.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/constants.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/base-sepolia.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var baseSepolia = defineChain({
  id: 84532,
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  ],
  testnet: true
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/base.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var base = defineChain({
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  ]
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/optimism-sepolia.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var optimismSepolia = defineChain({
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  ],
  testnet: true
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/optimism.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var optimism = defineChain({
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockExplorers: [
    {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io"
    }
  ]
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/zora-sepolia.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);
var zoraSepolia = defineChain({
  id: 999999999,
  name: "Zora Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  blockExplorers: [
    {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  ],
  testnet: true
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/chain-definitions/zora.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);
var zora = defineChain({
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  blockExplorers: [
    {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  ]
});

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/constants.js
var opChains = [
  base.id,
  baseSepolia.id,
  optimism.id,
  optimismSepolia.id,
  zora.id,
  zoraSepolia.id,
  34443,
  // mode
  919,
  // mode testnet
  42220,
  // celo
  44787,
  // celo testnet
  204,
  // opBNB
  5611
  // opBNB testnet
];

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-transaction.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-and-confirm-transaction.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-batch-transaction.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/simulate.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
var import_dist121 = __toESM(require_dist(), 1);
var import_dist122 = __toESM(require_dist2(), 1);
var import_dist123 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/secp256k1.js
var import_dist109 = __toESM(require_dist());
var import_dist110 = __toESM(require_dist2());
var import_dist111 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/modular.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes,
  validateObject: () => validateObject
});
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/curve.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window = 0; window < windows; window++) {
        base2 = p;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/_shortw_utils.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/hashes/esm/hmac.js
var import_dist103 = __toESM(require_dist());
var import_dist104 = __toESM(require_dist2());
var import_dist105 = __toESM(require_dist3());
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js
var import_dist118 = __toESM(require_dist(), 1);
var import_dist119 = __toESM(require_dist2(), 1);
var import_dist120 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/trim.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/prepare-event.js
var import_dist127 = __toESM(require_dist(), 1);
var import_dist128 = __toESM(require_dist2(), 1);
var import_dist129 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/utils.js
var import_dist124 = __toESM(require_dist(), 1);
var import_dist125 = __toESM(require_dist2(), 1);
var import_dist126 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/get-events.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/parse-logs.js
var import_dist130 = __toESM(require_dist(), 1);
var import_dist131 = __toESM(require_dist2(), 1);
var import_dist132 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/watch-events.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/retry.js
var import_dist136 = __toESM(require_dist(), 1);
var import_dist137 = __toESM(require_dist2(), 1);
var import_dist138 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
var import_dist154 = __toESM(require_dist(), 1);
var import_dist155 = __toESM(require_dist2(), 1);
var import_dist156 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js
var import_dist148 = __toESM(require_dist(), 1);
var import_dist149 = __toESM(require_dist2(), 1);
var import_dist150 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js
var import_dist145 = __toESM(require_dist(), 1);
var import_dist146 = __toESM(require_dist2(), 1);
var import_dist147 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/once.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);
function once(fn) {
  let result;
  return () => {
    if (!result) {
      result = fn();
    }
    return result;
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js
var FN_SELECTOR = "0x095ea7b3";
var FN_INPUTS = [
  {
    type: "address",
    name: "spender"
  },
  {
    type: "uint256",
    name: "value"
  }
];
var FN_OUTPUTS = [
  {
    type: "bool"
  }
];
function approve(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.spender, resolvedOptions.value];
    },
    value: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.value;
    },
    accessList: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.accessList;
    },
    gas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gas;
    },
    gasPrice: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.gasPrice;
    },
    maxFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxFeePerGas;
    },
    maxPriorityFeePerGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.maxPriorityFeePerGas;
    },
    nonce: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.nonce;
    },
    extraGas: async () => {
      var _a;
      return (_a = (await asyncOptions()).overrides) == null ? void 0 : _a.extraGas;
    }
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js
function approve2(options) {
  return approve({
    contract: options.contract,
    asyncParams: async () => {
      let amount;
      if ("amount" in options) {
        const { decimals } = await import("./decimals-B2CKOT3I.js");
        const d = await decimals(options).catch(() => 18);
        amount = toUnits(options.amount.toString(), d);
      } else {
        amount = options.amountWei;
      }
      return {
        spender: options.spender,
        value: amount
      };
    }
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/utils/definitions.js
var import_dist151 = __toESM(require_dist(), 1);
var import_dist152 = __toESM(require_dist2(), 1);
var import_dist153 = __toESM(require_dist3(), 1);
var getPayBuyWithCryptoStatusUrl = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/status/v1`;
var getPayBuyWithCryptoQuoteEndpoint = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/quote/v1`;
var getPayBuyWithCryptoHistoryEndpoint = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/history/v1`;

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
async function getBuyWithCryptoQuote(params) {
  var _a;
  try {
    const queryParams = new URLSearchParams({
      fromAddress: params.fromAddress,
      fromChainId: params.fromChainId.toString(),
      fromTokenAddress: params.fromTokenAddress.toLowerCase(),
      toChainId: params.toChainId.toString(),
      toTokenAddress: params.toTokenAddress.toLowerCase()
    });
    if ("fromAmount" in params && params.fromAmount) {
      queryParams.append("fromAmount", params.fromAmount);
    }
    if ("toAmount" in params && params.toAmount) {
      queryParams.append("toAmount", params.toAmount);
    }
    if (params.maxSlippageBPS) {
      queryParams.append("maxSlippageBPS", params.maxSlippageBPS.toString());
    }
    if (params.intentId) {
      queryParams.append("intentId", params.intentId);
    }
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithCryptoQuoteEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj && typeof errorObj.error === "object" && "message" in errorObj.error) {
        throw new Error(errorObj.error.message);
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    const swapRoute = {
      transactionRequest: {
        chain: getCachedChain(data.transactionRequest.chainId),
        client: params.client,
        data: data.transactionRequest.data,
        to: data.transactionRequest.to,
        value: BigInt(data.transactionRequest.value),
        gas: BigInt(data.transactionRequest.gasLimit),
        gasPrice: BigInt(data.transactionRequest.gasPrice)
      },
      approval: data.approval ? approve2({
        contract: getContract({
          client: params.client,
          address: data.approval.tokenAddress,
          chain: getCachedChain(data.approval.chainId)
        }),
        spender: (_a = data.approval) == null ? void 0 : _a.spenderAddress,
        amountWei: BigInt(data.approval.amountWei)
      }) : void 0,
      swapDetails: {
        fromAddress: data.fromAddress,
        toAddress: data.toAddress,
        fromToken: data.fromToken,
        toToken: data.toToken,
        fromAmount: data.fromAmount,
        fromAmountWei: data.fromAmountWei,
        toAmountMinWei: data.toAmountMinWei,
        toAmountMin: data.toAmountMin,
        toAmountWei: data.toAmountWei,
        toAmount: data.toAmount,
        estimated: data.estimated,
        maxSlippageBPS: data.maxSlippageBPS
      },
      paymentTokens: data.paymentTokens,
      processingFees: data.processingFees,
      client: params.client
    };
    return swapRoute;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getStatus.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
  var _a;
  try {
    if (!buyWithCryptoTransaction.transactionHash) {
      throw new Error("Transaction hash is required");
    }
    const queryString = new URLSearchParams({
      transactionHash: buyWithCryptoTransaction.transactionHash
    }).toString();
    const url = `${getPayBuyWithCryptoStatusUrl()}?${queryString}`;
    const response = await getClientFetch(buyWithCryptoTransaction.client)(url);
    if (!response.ok) {
      (_a = response.body) == null ? void 0 : _a.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getHistory.js
var import_dist160 = __toESM(require_dist(), 1);
var import_dist161 = __toESM(require_dist2(), 1);
var import_dist162 = __toESM(require_dist3(), 1);
async function getBuyWithCryptoHistory(params) {
  var _a;
  try {
    const queryParams = new URLSearchParams();
    queryParams.append("walletAddress", params.walletAddress);
    queryParams.append("start", params.start.toString());
    queryParams.append("count", params.count.toString());
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithCryptoHistoryEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      (_a = response.body) == null ? void 0 : _a.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/concat-hex.js
var import_dist163 = __toESM(require_dist(), 1);
var import_dist164 = __toESM(require_dist2(), 1);
var import_dist165 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js
var import_dist166 = __toESM(require_dist(), 1);
var import_dist167 = __toESM(require_dist2(), 1);
var import_dist168 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/pay.js
var import_dist190 = __toESM(require_dist());
var import_dist191 = __toESM(require_dist2());
var import_dist192 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getQuote.js
var import_dist172 = __toESM(require_dist(), 1);
var import_dist173 = __toESM(require_dist2(), 1);
var import_dist174 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getStatus.js
var import_dist175 = __toESM(require_dist(), 1);
var import_dist176 = __toESM(require_dist2(), 1);
var import_dist177 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getHistory.js
var import_dist178 = __toESM(require_dist(), 1);
var import_dist179 = __toESM(require_dist2(), 1);
var import_dist180 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getPostOnRampQuote.js
var import_dist181 = __toESM(require_dist(), 1);
var import_dist182 = __toESM(require_dist2(), 1);
var import_dist183 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/getBuyHistory.js
var import_dist184 = __toESM(require_dist(), 1);
var import_dist185 = __toESM(require_dist2(), 1);
var import_dist186 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/isSwapRequiredPostOnramp.js
var import_dist187 = __toESM(require_dist(), 1);
var import_dist188 = __toESM(require_dist2(), 1);
var import_dist189 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/utils.js
var import_dist241 = __toESM(require_dist());
var import_dist242 = __toESM(require_dist2());
var import_dist243 = __toESM(require_dist3());

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/extractMnimalProxyImplementationAddress.js
var import_dist193 = __toESM(require_dist(), 1);
var import_dist194 = __toESM(require_dist2(), 1);
var import_dist195 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/is-contract-deployed.js
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/resolveImplementation.js
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/is-eip155-enforced.js
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/keyless-transaction.js
var import_dist205 = __toESM(require_dist(), 1);
var import_dist206 = __toESM(require_dist2(), 1);
var import_dist207 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
var CUSTOM_GAS_FOR_CHAIN = {
  "5001": {
    name: "Mantle Testnet",
    gasPrice: 1n
  },
  "71402": {
    name: "Godwoken Mainnet",
    gasPrice: 40000n * 10n ** 9n
  },
  "1351057110": {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000n
  },
  "361": {
    name: "Theta Mainnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "365": {
    name: "Theta Testnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "7700": {
    name: "Canto",
    gasPrice: 1000n * 10n ** 9n
  },
  "7701": {
    name: "Canto Testnet",
    gasPrice: 1000n * 10n ** 9n
  },
  "338": {
    name: "Cronos Testnet",
    gasPrice: 2000n * 10n ** 9n
  },
  "199": {
    name: "BitTorrent Chain",
    gasPrice: 300000n * 10n ** 9n
  },
  "88882": {
    name: "Spicy Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  },
  "88888": {
    name: "Chiliz Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  }
};
var CUSTOM_GAS_BINS = [
  1n,
  1n * 10n ** 9n,
  100n * 10n ** 9n,
  500n * 10n ** 9n,
  1000n * 10n ** 9n,
  2500n * 10n ** 9n,
  5000n * 10n ** 9n,
  7500n * 10n ** 9n,
  10000n * 10n ** 9n,
  25000n * 10n ** 9n,
  50000n * 10n ** 9n,
  75000n * 10n ** 9n,
  100000n * 10n ** 9n,
  250000n * 10n ** 9n,
  500000n * 10n ** 9n,
  750000n * 10n ** 9n,
  1000000n * 10n ** 9n
];

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/compute-deployment-address.js
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/get-salt-hash.js
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/keccak-id.js
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/get-init-bytecode-with-salt.js
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/resolve-signature.js
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
var import_dist232 = __toESM(require_dist(), 1);
var import_dist233 = __toESM(require_dist2(), 1);
var import_dist234 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/helpers/parseTypedData.js
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/dist/getStatus-7ee3964f.browser.esm.js
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}
async function compatibleExtensions(coreBytecode, extensionBytecodes, chainId) {
  const chain = await getChainByChainIdAsync(chainId);
  const rpcUrl = getChainRPC(chain);
  const jsonRpcProvider = new lib_exports2.JsonRpcProvider(rpcUrl);
  const addr = "0x0000000000000000000000000000000000000124";
  const coreIface = new utils_exports.Interface(coreContractAbi);
  const coreCalldata = coreIface.encodeFunctionData("getSupportedCallbackFunctions", []);
  if (!coreBytecode.startsWith("0x6080604052")) {
    const index = coreBytecode.indexOf("6080604052");
    coreBytecode = `0x${coreBytecode.substring(index)}`;
  } else if (coreBytecode.lastIndexOf("6080604052") > 0) {
    const index = coreBytecode.lastIndexOf("6080604052");
    coreBytecode = `0x${coreBytecode.substring(index)}`;
  }
  const core = await jsonRpcProvider.send("eth_call", [
    {
      to: addr,
      data: coreCalldata
    },
    "latest",
    {
      [addr]: {
        code: coreBytecode
      }
    }
    // eth_call with bytecode override
  ]);
  const extensionIface = new utils_exports.Interface(extensionContractAbi);
  const extensionCalldata = extensionIface.encodeFunctionData("getExtensionConfig", []);
  const extensions = await Promise.all(extensionBytecodes.map((b) => {
    if (!b.startsWith("0x6080604052")) {
      const index = b.indexOf("6080604052");
      b = `0x${b.substring(index)}`;
    } else if (b.lastIndexOf("6080604052") > 0) {
      const index = b.lastIndexOf("6080604052");
      b = `0x${b.substring(index)}`;
    }
    return jsonRpcProvider.send("eth_call", [
      {
        to: addr,
        data: extensionCalldata
      },
      "latest",
      {
        [addr]: {
          code: b
        }
      }
      // eth_call with bytecode override
    ]);
  }));
  const decodedCore = coreIface.decodeFunctionResult("getSupportedCallbackFunctions", core);
  const coreCallbackSelectors = decodedCore.flat().map((c) => c.selector);
  const requiredInterfaces = [];
  const extensionFallbackSelectors = [];
  const extensionCallbackSelectors = [];
  const selectors = [];
  extensions.forEach((e) => {
    const decodedExtensionConfig = extensionIface.decodeFunctionResult("getExtensionConfig", e);
    requiredInterfaces.push(...decodedExtensionConfig[0].requiredInterfaces);
    const fallbackSelectors = decodedExtensionConfig[0].fallbackFunctions.map((a) => a.selector);
    const callbackSelectors = decodedExtensionConfig[0].callbackFunctions.map((a) => a.selector);
    extensionFallbackSelectors.push(...fallbackSelectors);
    extensionCallbackSelectors.push(...callbackSelectors);
  });
  for (const callback of extensionCallbackSelectors) {
    if (!coreCallbackSelectors.includes(callback)) {
      return false;
    }
  }
  if (requiredInterfaces.length > 0) {
    const supportsInterfaceResult = await Promise.all(requiredInterfaces.map((r) => {
      const supportsInterfaceCalldata = coreIface.encodeFunctionData("supportsInterface", [r]);
      return jsonRpcProvider.send("eth_call", [{
        to: addr,
        data: supportsInterfaceCalldata
      }, "latest", {
        [addr]: {
          code: coreBytecode
        }
      }]);
    }));
    const supportsInterfaceDecoded = supportsInterfaceResult.map((r) => {
      return coreIface.decodeFunctionResult("supportsInterface", r);
    });
    if (supportsInterfaceDecoded.flat().some((element) => element === false)) {
      return false;
    }
  }
  selectors.push(...extensionFallbackSelectors, ...extensionCallbackSelectors);
  return !hasDuplicates(selectors.flat(), (a, b) => a === b);
}
function toUnits2(amount, decimals) {
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toDisplayValue(amount, decimals) {
  return utils_exports.formatUnits(amount, decimals);
}
async function computeNativeTokenAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  }, clientId, secretKey)).transaction.predictedAddress;
}
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    const tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}
var ProposalState = function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  return ProposalState2;
}({});
var PropertiesInput = (() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var OptionalPropertiesInput = (() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();
var EditionMetadataOutputSchema = (() => z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
}))();
var EditionMetadataWithOwnerOutputSchema = (() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();
var EditionMetadataInputSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
}))();
var EditionMetadataInputOrUriSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
}))();
var TokenMintInputSchema = (() => z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
}))();
async function getBuyWithCryptoHistory2(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  return getBuyWithCryptoHistory({
    ...params,
    client
  });
}
async function getBuyWithCryptoQuote2(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  const data = await getBuyWithCryptoQuote({
    ...params,
    client
  });
  const sendTxn = prepareTransaction(data.transactionRequest);
  const approvalTxn = data.approval ? prepareTransaction(data.approval) : void 0;
  const [sendTxnTo, sendTxnData, sendTxnGasPrice, sendTxnGasLimit, sendTxnNonce, sendTxnValue, approvalTxnTo, approvalTxnData, approvalTxnGasLimit, approvalTxnGasPrice, approvalTxnNonce, approvalTxnValue] = await Promise.all([resolvePromisedValue(sendTxn.to), resolvePromisedValue(sendTxn.data), resolvePromisedValue(sendTxn.gasPrice), resolvePromisedValue(sendTxn.gas), resolvePromisedValue(sendTxn.nonce), resolvePromisedValue(sendTxn.value), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.to), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.data), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.gas), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.gasPrice), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.nonce), resolvePromisedValue(approvalTxn == null ? void 0 : approvalTxn.value)]);
  const swapRoute = {
    transactionRequest: {
      to: sendTxnTo,
      data: sendTxnData,
      gasPrice: sendTxnGasPrice,
      gasLimit: sendTxnGasLimit,
      nonce: sendTxnNonce,
      value: sendTxnValue,
      chainId: sendTxn.chain.id
    },
    approval: approvalTxn ? {
      to: approvalTxnTo,
      data: approvalTxnData,
      gasLimit: approvalTxnGasLimit,
      gasPrice: approvalTxnGasPrice,
      nonce: approvalTxnNonce,
      value: approvalTxnValue,
      chainId: approvalTxn.chain.id
    } : void 0,
    swapDetails: data.swapDetails,
    paymentTokens: data.paymentTokens,
    processingFees: data.processingFees,
    client
  };
  return swapRoute;
}
async function getBuyWithCryptoStatus2(buyWithCryptoTransaction) {
  return getBuyWithCryptoStatus({
    ...buyWithCryptoTransaction,
    client: createThirdwebClient({
      clientId: buyWithCryptoTransaction.clientId
    })
  });
}

// node_modules/@thirdweb-dev/sdk/dist/watchTransactions-95d1cc2b.browser.esm.js
var import_dist247 = __toESM(require_dist());
var import_dist248 = __toESM(require_dist2());
var import_dist249 = __toESM(require_dist3());
init_lib();
var STORAGE_CACHE = new ThirdwebStorage();
var CONTRACT_CACHE = createLruCache(10);
function getContractCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function inContractCache(address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.has(cacheKey);
}
function getCachedContract(address, chainId) {
  if (!inContractCache(address, chainId)) {
    throw new Error(`Contract ${address} was not found in cache`);
  }
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.get(cacheKey);
}
function cacheContract(contract, address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  CONTRACT_CACHE.put(cacheKey, contract);
}
function getCachedStorage(storage) {
  return storage || STORAGE_CACHE;
}
async function getContractFromAbi(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    SmartContract
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./smart-contract-ac432d60.browser.esm-5Q74DFA5.js")]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  const parsedAbi = typeof params.abi === "string" ? JSON.parse(params.abi) : params.abi;
  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);
  cacheContract(contract, resolvedAddress, chainId);
  return contract;
}
async function resolveContractType(params) {
  try {
    const IThirdwebContractABI = (await import("./IThirdwebContract-QDPOONHT.js")).default;
    const contract = new Contract(params.address, IThirdwebContractABI, params.provider);
    const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    return getContractTypeForRemoteName(remoteContractType);
  } catch (err) {
    return "custom";
  }
}
async function getContract2(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    ContractPublisher: ContractPublisher2
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./contract-publisher-01e4eba8.browser.esm-VLODXPXO.js").then(function(n) {
    return n.c;
  })]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === "custom") {
    const contractType = await resolveContractType({
      address: resolvedAddress,
      provider
    });
    if (contractType === "custom") {
      const publisher = new ContractPublisher2(params.network, params.sdkOptions, getCachedStorage(params.storage));
      try {
        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);
        return getContractFromAbi({
          ...params,
          address: resolvedAddress,
          abi: metadata.abi
        });
      } catch {
        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
      }
    } else {
      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));
      return getContractFromAbi({
        ...params,
        address: resolvedAddress,
        abi
      });
    }
  } else if (typeof params.contractTypeOrAbi === "string" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {
    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);
    cacheContract(contract, resolvedAddress, chainId);
    return contract;
  } else {
    return getContractFromAbi({
      ...params,
      address: resolvedAddress,
      abi: params.contractTypeOrAbi
    });
  }
}
var CHAIN_ID_CACHE = /* @__PURE__ */ new WeakMap();
async function getChainId(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  let chainIdPromise;
  if (CHAIN_ID_CACHE.has(provider)) {
    chainIdPromise = CHAIN_ID_CACHE.get(provider);
  } else {
    chainIdPromise = provider.getNetwork().then((network) => network.chainId).catch((err) => {
      CHAIN_ID_CACHE.delete(provider);
      throw err;
    });
    CHAIN_ID_CACHE.set(provider, chainIdPromise);
  }
  return await chainIdPromise;
}
async function getBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  return provider.getBlockNumber();
}
var BLOCK_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlock(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlock(blockTag).catch((err) => {
      BLOCK_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
var BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlockWithTransactions(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlockWithTransactions(blockTag).catch((err) => {
      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
function watchBlockNumber2(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  provider.on("block", params.onBlockNumber);
  return () => {
    provider.off("block", params.onBlockNumber);
  };
}
function watchBlock(_ref) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlock({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber2({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchBlockWithTransactions(_ref2) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref2;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlockWithTransactions({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber2({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchTransactions(_ref) {
  let {
    address,
    onTransactions,
    ...sharedBlockParams
  } = _ref;
  const lcAddress = address.toLowerCase();
  function onBlock(block) {
    const transactions = block.transactions.filter((tx) => {
      var _a;
      if (tx.from.toLowerCase() === lcAddress) {
        return true;
      }
      return ((_a = tx.to) == null ? void 0 : _a.toLowerCase()) === lcAddress;
    });
    if (transactions.length > 0) {
      onTransactions(transactions);
    }
  }
  return watchBlockWithTransactions({
    ...sharedBlockParams,
    onBlock
  });
}

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils23 = __toESM(require_utils());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function getRpcUrl(network, clientId) {
  return `https://${network}.rpc.thirdweb.com/${clientId || ""}`;
}
globalThis.global = globalThis;

export {
  checkClientIdOrSecretKey,
  getEncodedConstructorParamsForThirdwebContract,
  predictThirdwebContractAddress,
  getThirdwebContractAddress,
  verifyThirdwebPrebuiltImplementation,
  verify,
  checkVerificationStatus,
  isVerifiedOnEtherscan,
  ContractVerifier,
  LOCAL_NODE_PKEY,
  UserWallet,
  getAllDetectedFeatureNames,
  getAllDetectedExtensionNames,
  extractFunctionParamsFromAbi,
  computeCloneFactoryAddress,
  convertParamValues,
  deployCreate2Factory,
  SUPPORTED_CHAIN_IDS,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getTrustedForwarders,
  APPROVED_IMPLEMENTATIONS,
  getApprovedImplementation,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  directDeployDeterministicPublished,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  predictAddressDeterministicPublished,
  ThirdwebSDK,
  ContractDeployer,
  matchesPrebuiltAbi,
  compatibleExtensions,
  toUnits2 as toUnits,
  toDisplayValue,
  computeNativeTokenAddress,
  deployContractDeterministicRaw,
  getCachedAbiForContract,
  ProposalState,
  OptionalPropertiesInput,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EditionMetadataInputSchema,
  EditionMetadataInputOrUriSchema,
  TokenMintInputSchema,
  getBuyWithCryptoHistory2 as getBuyWithCryptoHistory,
  getBuyWithCryptoQuote2 as getBuyWithCryptoQuote,
  getBuyWithCryptoStatus2 as getBuyWithCryptoStatus,
  getContractFromAbi,
  getContract2 as getContract,
  getChainId,
  getBlockNumber,
  getBlock,
  getBlockWithTransactions,
  watchBlockNumber2 as watchBlockNumber,
  watchBlock,
  watchBlockWithTransactions,
  watchTransactions,
  getRpcUrl
};
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-QU2H4SD2.js.map
