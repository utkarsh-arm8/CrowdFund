import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_immutable,
  require_js,
  require_readable_browser
} from "./chunk-RHH6GAQ7.js";
import {
  require_assert,
  require_dist as require_dist4
} from "./chunk-WC742KWC.js";
import {
  Connector
} from "./chunk-BJ3Q2M2N.js";
import {
  _defineProperty
} from "./chunk-7YQW7K4V.js";
import {
  require_browser,
  require_browser2,
  require_elliptic,
  require_stream_browserify
} from "./chunk-NPKO3TR3.js";
import {
  require_callBound,
  require_get_intrinsic,
  require_type,
  require_util
} from "./chunk-IAEGYWYU.js";
import {
  require_events
} from "./chunk-KFI3GVST.js";
import {
  require_utils
} from "./chunk-43DMFY6L.js";
import "./chunk-C347233M.js";
import "./chunk-VE5YG2UP.js";
import {
  ethers_exports,
  init_lib as init_lib5,
  init_lib5 as init_lib8,
  init_lib7 as init_lib9,
  lib_exports as lib_exports5,
  lib_exports5 as lib_exports8,
  lib_exports7 as lib_exports9
} from "./chunk-4357AYQK.js";
import {
  init_lib11 as init_lib4,
  init_lib13 as init_lib6,
  init_lib19 as init_lib7,
  init_lib2 as init_lib,
  init_lib3 as init_lib2,
  init_lib7 as init_lib3,
  lib_exports11 as lib_exports4,
  lib_exports13 as lib_exports6,
  lib_exports19 as lib_exports7,
  lib_exports2 as lib_exports,
  lib_exports3 as lib_exports2,
  lib_exports7 as lib_exports3
} from "./chunk-5UPRJSZY.js";
import "./chunk-ZKAAZOGS.js";
import {
  require_bn,
  require_inherits_browser
} from "./chunk-OKK22FPZ.js";
import {
  dist_exports,
  init_dist
} from "./chunk-4K5QQUIR.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = /* @__PURE__ */ function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter2) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing) return null;
      var i = thing.length;
      if (isUndefined(i)) return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = /* @__PURE__ */ function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/axios/lib/core/AxiosError.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module.exports = AxiosError;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null) return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value)) return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module.exports = toFormData;
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var AxiosError = require_AxiosError();
    module.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var AxiosError = require_AxiosError();
    var utils = require_utils2();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module.exports = CanceledError;
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/helpers/null.js
var require_null = __commonJS({
  "node_modules/axios/lib/helpers/null.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = null;
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var VERSION = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners) return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve2) {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.CanceledError = require_CanceledError();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.toFormData = require_toFormData();
    axios.AxiosError = require_AxiosError();
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = require_axios();
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js
var require_service = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/service.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeService = void 0;
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var axios_1 = __importDefault(require_axios2());
    var SafeService2 = class {
      constructor(serviceUrl, network) {
        this.serviceUrl = serviceUrl;
        this.network = network !== null && network !== void 0 ? network : axios_1.default;
      }
      /**
       * Estimates a Safe transaction
       *
       * @param safe - Address of the Safe for which this transaction should be estimated
       * @param safeTx - Safe transaction that should be estimated for execution
       * @returns A big number representing the safeTxGas for the passed Safe transaction
       */
      async estimateSafeTx(safe, safeTx) {
        const url = `${this.serviceUrl}/api/v1/safes/${safe}/multisig-transactions/estimations/`;
        const resp = await this.network.post(url, safeTx);
        return bignumber_1.BigNumber.from(resp.data.safeTxGas);
      }
      /**
       * Load details for a Safe transaction
       *
       * @param safeTxHash - Hash of the Safe transaction
       * @returns A `SafeTxDetails` object that contains the details of a Safe transaction
       */
      async getSafeTxDetails(safeTxHash) {
        const url = `${this.serviceUrl}/api/v1/multisig-transactions/${safeTxHash}`;
        const resp = await this.network.get(url);
        return resp.data;
      }
      /**
       * Propose a new Safe transaction to the service
       *
       * @param safeAddress - Address of the Safe for which this transaction should be proposed
       * @param safeTxHash - Hash of the Safe transaction
       * @param safeTx - Safe transaction that should be proposed
       * @param signature - Signature of an owner or a delegate of an owner of the specified Safe to authorize the proposal
       * @returns The hash of the Safe transaction that has been proposed
       */
      async proposeTx(safeAddress, safeTxHash, safeTx, signature) {
        const url = `${this.serviceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        const data = {
          ...safeTx.data,
          contractTransactionHash: safeTxHash,
          sender: signature.signer,
          signature: signature.data
        };
        const resp = await this.network.post(url, data);
        return resp.data;
      }
    };
    exports.SafeService = SafeService2;
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CompatibilityFallbackHandlerContract.js
var require_CompatibilityFallbackHandlerContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CompatibilityFallbackHandlerContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CreateCallContract.js
var require_CreateCallContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/CreateCallContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeContract.js
var require_GnosisSafeContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeProxyFactoryContract.js
var require_GnosisSafeProxyFactoryContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/GnosisSafeProxyFactoryContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendCallOnlyContract.js
var require_MultiSendCallOnlyContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendCallOnlyContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendContract.js
var require_MultiSendContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/MultiSendContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/SignMessageLibContract.js
var require_SignMessageLibContract = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/contracts/SignMessageLibContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/ethereumLibs/EthAdapter.js
var require_EthAdapter = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/ethereumLibs/EthAdapter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/types.js
var require_types = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperationType = void 0;
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["Call"] = 0] = "Call";
      OperationType2[OperationType2["DelegateCall"] = 1] = "DelegateCall";
    })(OperationType = exports.OperationType || (exports.OperationType = {}));
  }
});

// node_modules/@safe-global/safe-core-sdk-types/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-types/dist/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CompatibilityFallbackHandlerContract(), exports);
    __exportStar(require_CreateCallContract(), exports);
    __exportStar(require_GnosisSafeContract(), exports);
    __exportStar(require_GnosisSafeProxyFactoryContract(), exports);
    __exportStar(require_MultiSendCallOnlyContract(), exports);
    __exportStar(require_MultiSendContract(), exports);
    __exportStar(require_SignMessageLibContract(), exports);
    __exportStar(require_EthAdapter(), exports);
    __exportStar(require_types(), exports);
  }
});

// node_modules/@safe-global/safe-deployments/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/simulate_tx_accessor.json
var require_simulate_tx_accessor = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/simulate_tx_accessor.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SimulateTxAccessor",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da",
          codeHash: "0xb3fb9763869f2c09a2ac5a425d2dd6060bf7ef46b3899049d71a711e71e00f04"
        },
        eip155: {
          address: "0x727a77a074D1E6c4530e814F89E618a3298FC044",
          codeHash: "0x66712e1d9161706f826d8d74a3cc03db0289b2530a1202f24d52986952b69a02"
        },
        zksync: {
          address: "0x4191E2e12E8BC5002424CE0c51f9947b02675a44",
          codeHash: "0x18c486b76cb76981360e96ca4f90fc745fde6a8575b8c2b35ac98eab3856fd72"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "uint256",
              name: "estimate",
              type: "uint256"
            },
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/simulate_tx_accessor.json
var require_simulate_tx_accessor2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/simulate_tx_accessor.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SimulateTxAccessor",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x3d4BA2E0884aa488718476ca2FB8Efc291A46199",
          codeHash: "0x91f82615581fc73b190b83d72e883608b25e392f72322035df1b13d51766cf8d"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "uint256",
              name: "estimate",
              type: "uint256"
            },
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/proxy_factory.json
var require_proxy_factory = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/proxy_factory.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "ProxyFactory",
      version: "1.0.0",
      deployments: {
        canonical: {
          address: "0x12302fE9c02ff50939BaAaaf415fc226C078613C",
          codeHash: "0x84a375ad96ab395850d46cd601ed6354d3cf3fb67cec0caf18f34af5c9d1a7f0"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "100": "canonical"
      },
      abi: [
        {
          constant: false,
          inputs: [
            {
              name: "_mastercopy",
              type: "address"
            },
            {
              name: "initializer",
              type: "bytes"
            },
            {
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "masterCopy",
              type: "address"
            },
            {
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "proxy",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/proxy_factory.json
var require_proxy_factory2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/proxy_factory.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "ProxyFactory",
      version: "1.1.1",
      deployments: {
        canonical: {
          address: "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B",
          codeHash: "0x0f0bb9c13be3b595d6f0fde841d5247a96f7e315bd8b97e1363553bee9a7d995"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "88": "canonical",
        "100": "canonical",
        "246": "canonical",
        "73799": "canonical"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "masterCopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "pure",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_mastercopy",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "calculateCreateProxyWithNonceAddress",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/proxy_factory.json
var require_proxy_factory3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/proxy_factory.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafeProxyFactory",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2",
          codeHash: "0x337d7f54be11b6ed55fef7b667ea5488db53db8320a05d1146aa4bd169a39a9b"
        },
        eip155: {
          address: "0xC22834581EbC8527d974F8a1c97E1bEA4EF910BC",
          codeHash: "0x337d7f54be11b6ed55fef7b667ea5488db53db8320a05d1146aa4bd169a39a9b"
        },
        zksync: {
          address: "0xDAec33641865E4651fB43181C6DB6f7232Ee91c2",
          codeHash: "0x55daa5d390d283edbc5fa835bd53befce45179c758feaac8c149a95850d0a6b6"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "calculateCreateProxyWithNonceAddress",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          name: "createProxy",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract GnosisSafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyRuntimeCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_proxy_factory.json
var require_safe_proxy_factory = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_proxy_factory.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SafeProxyFactory",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
          codeHash: "0x50c3cdc4074750a7a974204a716c999edd37482f907608d960b2b025ee0b3317"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ProxyCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createChainSpecificProxyWithNonce",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            },
            {
              internalType: "contract IProxyCreationCallback",
              name: "callback",
              type: "address"
            }
          ],
          name: "createProxyWithCallback",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_singleton",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "initializer",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "saltNonce",
              type: "uint256"
            }
          ],
          name: "createProxyWithNonce",
          outputs: [
            {
              internalType: "contract SafeProxy",
              name: "proxy",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "proxyCreationCode",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/default_callback_handler.json
var require_default_callback_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/default_callback_handler.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "DefaultCallbackHandler",
      version: "1.1.1",
      deployments: {
        canonical: {
          address: "0xd5D82B6aDDc9027B22dCA772Aa68D5d74cdBdF44",
          codeHash: "0x919a9f5dd111a01f7a8e4b1f5c6a972bb2d1441c67bdec71de6a09d0be92f5b9"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "88": "canonical",
        "100": "canonical",
        "246": "canonical",
        "73799": "canonical"
      },
      abi: [
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/compatibility_fallback_handler.json
var require_compatibility_fallback_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/compatibility_fallback_handler.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "CompatibilityFallbackHandler",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4",
          codeHash: "0x03e69f7ce809e81687c69b19a7d7cca45b6d551ffdec73d9bb87178476de1abf"
        },
        eip155: {
          address: "0x017062a1dE2FE6b99BE3d9d37841FeD19F573804",
          codeHash: "0x03e69f7ce809e81687c69b19a7d7cca45b6d551ffdec73d9bb87178476de1abf"
        },
        zksync: {
          address: "0x2f870a80647BbC554F3a0EBD093f11B4d2a7492A",
          codeHash: "0x017e9a83d5513f503fb85274f4d1ad1811040d7caa31772750ffb08638c28fbb"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract GnosisSafe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHashForSafe",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "bytes",
              name: "response",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/compatibility_fallback_handler.json
var require_compatibility_fallback_handler2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/compatibility_fallback_handler.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "CompatibilityFallbackHandler",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0xfd0732Dc9E303f09fCEf3a7388Ad10A83459Ec99",
          codeHash: "0x7c6007a5d711cea8dfd5d91f5940ec29c7f200fe511eb1fc1397b367af3c42f9"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "contract Safe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "encodeMessageDataForSafe",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract Safe",
              name: "safe",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHashForSafe",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "uint256[]",
              name: "",
              type: "uint256[]"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155BatchReceived",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC1155Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "onERC721Received",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulate",
          outputs: [
            {
              internalType: "bytes",
              name: "response",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "interfaceId",
              type: "bytes4"
            }
          ],
          name: "supportsInterface",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          name: "tokensReceived",
          outputs: [],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe.json
var require_safe = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "Safe",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x41675C099F32341bf84BFc5382aF534df5C7461a",
          codeHash: "0x1fe2df852ba3299d6534ef416eefa406e56ced995bca886ab7a553e6d0c5e1c4"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe.json
var require_gnosis_safe = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafe",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552",
          codeHash: "0xbba688fbdb21ad2bb58bc320638b43d94e7d100f6f3ebaab0a4e4de6304b1c2e"
        },
        eip155: {
          address: "0x69f4D1788e39c87893C980c06EdF4b7f686e2938",
          codeHash: "0xbba688fbdb21ad2bb58bc320638b43d94e7d100f6f3ebaab0a4e4de6304b1c2e"
        },
        zksync: {
          address: "0xB00ce5CCcdEf57e539ddcEd01DF43a13855d9910",
          codeHash: "0x551b7fdfd2dbcec4f785059e1ef6e0b40ca2e44d792158c4e825bc0b092f15e9"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.2.0/gnosis_safe.json
var require_gnosis_safe2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.2.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafe",
      version: "1.2.0",
      deployments: {
        canonical: {
          address: "0x6851D6fDFAfD08c0295C392436245E5bc78B0185",
          codeHash: "0x2ae2d1231f0d754a7fa4f5e5d0e5554085e1b500d8e09f95aaaaa3f49c0db922"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "88": "canonical",
        "100": "canonical",
        "246": "canonical",
        "73799": "canonical"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "masterCopy",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          payable: true,
          stateMutability: "payable",
          type: "fallback"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_masterCopy",
              type: "address"
            }
          ],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: true,
          stateMutability: "payable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/gnosis_safe.json
var require_gnosis_safe3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/gnosis_safe.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafe",
      version: "1.1.1",
      deployments: {
        canonical: {
          address: "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F",
          codeHash: "0x56b8be58b5ad629a621593a2e5e5e8e9a28408dc06e95597497b303902772e45"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "88": "canonical",
        "100": "canonical",
        "246": "canonical",
        "73799": "canonical"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "masterCopy",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          payable: true,
          stateMutability: "payable",
          type: "fallback"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "_masterCopy",
              type: "address"
            }
          ],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "contract Module",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/gnosis_safe.json
var require_gnosis_safe4 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.0.0/gnosis_safe.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafe",
      version: "1.0.0",
      deployments: {
        canonical: {
          address: "0xb6029EA3B2c51D09a50B53CA8012FeEB05bDa35A",
          codeHash: "0xe1f1593df76e69abc2d692792c80f329457551d5e83dde597546a1d58764da80"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "100": "canonical"
      },
      abi: [
        {
          constant: false,
          inputs: [
            {
              name: "owner",
              type: "address"
            },
            {
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "DOMAIN_SEPARATOR_TYPEHASH",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              name: "",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "value",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "",
              type: "address"
            },
            {
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "_masterCopy",
              type: "address"
            }
          ],
          name: "changeMasterCopy",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SENTINEL_MODULES",
          outputs: [
            {
              name: "",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SENTINEL_OWNERS",
          outputs: [
            {
              name: "",
              type: "address"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "NAME",
          outputs: [
            {
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "nonce",
          outputs: [
            {
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getModules",
          outputs: [
            {
              name: "",
              type: "address[]"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SAFE_MSG_TYPEHASH",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "SAFE_TX_TYPEHASH",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "prevModule",
              type: "address"
            },
            {
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "prevOwner",
              type: "address"
            },
            {
              name: "oldOwner",
              type: "address"
            },
            {
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "prevOwner",
              type: "address"
            },
            {
              name: "owner",
              type: "address"
            },
            {
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              name: "",
              type: "string"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          payable: true,
          stateMutability: "payable",
          type: "fallback"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "txHash",
              type: "bytes32"
            }
          ],
          name: "ExecutionFailed",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              name: "newContract",
              type: "address"
            }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          constant: false,
          inputs: [
            {
              name: "_owners",
              type: "address[]"
            },
            {
              name: "_threshold",
              type: "uint256"
            },
            {
              name: "to",
              type: "address"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "paymentToken",
              type: "address"
            },
            {
              name: "payment",
              type: "uint256"
            },
            {
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "value",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "operation",
              type: "uint8"
            },
            {
              name: "safeTxGas",
              type: "uint256"
            },
            {
              name: "baseGas",
              type: "uint256"
            },
            {
              name: "gasPrice",
              type: "uint256"
            },
            {
              name: "gasToken",
              type: "address"
            },
            {
              name: "refundReceiver",
              type: "address"
            },
            {
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              name: "success",
              type: "bool"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "value",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              name: "",
              type: "uint256"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: false,
          inputs: [
            {
              name: "_data",
              type: "bytes"
            },
            {
              name: "_signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              name: "",
              type: "bytes4"
            }
          ],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "value",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "operation",
              type: "uint8"
            },
            {
              name: "safeTxGas",
              type: "uint256"
            },
            {
              name: "baseGas",
              type: "uint256"
            },
            {
              name: "gasPrice",
              type: "uint256"
            },
            {
              name: "gasToken",
              type: "address"
            },
            {
              name: "refundReceiver",
              type: "address"
            },
            {
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              name: "",
              type: "bytes"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        },
        {
          constant: true,
          inputs: [
            {
              name: "to",
              type: "address"
            },
            {
              name: "value",
              type: "uint256"
            },
            {
              name: "data",
              type: "bytes"
            },
            {
              name: "operation",
              type: "uint8"
            },
            {
              name: "safeTxGas",
              type: "uint256"
            },
            {
              name: "baseGas",
              type: "uint256"
            },
            {
              name: "gasPrice",
              type: "uint256"
            },
            {
              name: "gasToken",
              type: "address"
            },
            {
              name: "refundReceiver",
              type: "address"
            },
            {
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              name: "",
              type: "bytes32"
            }
          ],
          payable: false,
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_l2.json
var require_safe_l2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_l2.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SafeL2",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
          codeHash: "0xb1f926978a0f44a2c0ec8fe822418ae969bd8c3f18d61e5103100339894f81ff"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "SafeModuleTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "additionalInfo",
              type: "bytes"
            }
          ],
          name: "SafeMultiSigTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe_l2.json
var require_gnosis_safe_l2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/gnosis_safe_l2.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "GnosisSafeL2",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0x3E5c63644E683549055b9Be8653de26E0B4CD36E",
          codeHash: "0x21842597390c4c6e3c1239e434a682b054bd9548eee5e9b1d6a4482731023c0f"
        },
        eip155: {
          address: "0xfb1bffC9d739B8D520DaF37dF666da4C687191EA",
          codeHash: "0x21842597390c4c6e3c1239e434a682b054bd9548eee5e9b1d6a4482731023c0f"
        },
        zksync: {
          address: "0x1727c2c531cf966f902E5927b98490fDFb3b2b70",
          codeHash: "0xe2ca068330339d608367d83a0b25545efe39e619098597699ab8ff828cb1ddd8"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "AddedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "approvedHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "ApproveHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "ChangedFallbackHandler",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "ChangedGuard",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            }
          ],
          name: "ChangedThreshold",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "DisabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "EnabledModule",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleFailure",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "ExecutionFromModuleSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            }
          ],
          name: "ExecutionSuccess",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "RemovedOwner",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "module",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "SafeModuleTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "additionalInfo",
              type: "bytes"
            }
          ],
          name: "SafeMultiSigTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "sender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "SafeReceived",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          stateMutability: "nonpayable",
          type: "fallback"
        },
        {
          inputs: [],
          name: "VERSION",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "addOwnerWithThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hashToApprove",
              type: "bytes32"
            }
          ],
          name: "approveHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "approvedHashes",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "changeThreshold",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "requiredSignatures",
              type: "uint256"
            }
          ],
          name: "checkNSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "dataHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "checkSignatures",
          outputs: [],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevModule",
              type: "address"
            },
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "disableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "domainSeparator",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "enableModule",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "encodeTransactionData",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            }
          ],
          name: "execTransaction",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModule",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "execTransactionFromModuleReturnData",
          outputs: [
            {
              internalType: "bool",
              name: "success",
              type: "bool"
            },
            {
              internalType: "bytes",
              name: "returnData",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getChainId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "start",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "pageSize",
              type: "uint256"
            }
          ],
          name: "getModulesPaginated",
          outputs: [
            {
              internalType: "address[]",
              name: "array",
              type: "address[]"
            },
            {
              internalType: "address",
              name: "next",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getOwners",
          outputs: [
            {
              internalType: "address[]",
              name: "",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "offset",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "length",
              type: "uint256"
            }
          ],
          name: "getStorageAt",
          outputs: [
            {
              internalType: "bytes",
              name: "",
              type: "bytes"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getThreshold",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              internalType: "address",
              name: "refundReceiver",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_nonce",
              type: "uint256"
            }
          ],
          name: "getTransactionHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "module",
              type: "address"
            }
          ],
          name: "isModuleEnabled",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            }
          ],
          name: "isOwner",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "nonce",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            }
          ],
          name: "removeOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            }
          ],
          name: "requiredTxGas",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "handler",
              type: "address"
            }
          ],
          name: "setFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "guard",
              type: "address"
            }
          ],
          name: "setGuard",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_owners",
              type: "address[]"
            },
            {
              internalType: "uint256",
              name: "_threshold",
              type: "uint256"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            },
            {
              internalType: "address",
              name: "paymentToken",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "payment",
              type: "uint256"
            },
            {
              internalType: "address payable",
              name: "paymentReceiver",
              type: "address"
            }
          ],
          name: "setup",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          name: "signedMessages",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "targetContract",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "calldataPayload",
              type: "bytes"
            }
          ],
          name: "simulateAndRevert",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "prevOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "oldOwner",
              type: "address"
            },
            {
              internalType: "address",
              name: "newOwner",
              type: "address"
            }
          ],
          name: "swapOwner",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          stateMutability: "payable",
          type: "receive"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/multi_send.json
var require_multi_send = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.1.1/multi_send.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "MultiSend",
      version: "1.1.1",
      deployments: {
        canonical: {
          address: "0x8D29bE29923b68abfDD21e541b9374737B49cdAD",
          codeHash: "0xe4e9b4d4c1e3ff06cd51afe0b51eb1b22c0bab51eab38d428ee74540a5ff603e"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "4": "canonical",
        "5": "canonical",
        "42": "canonical",
        "88": "canonical",
        "100": "canonical",
        "246": "canonical",
        "73799": "canonical"
      },
      abi: [
        {
          inputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          constant: false,
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          payable: false,
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send.json
var require_multi_send2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "MultiSend",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761",
          codeHash: "0x0208282bd262360d0320862c5ac70f375f5ed3b9d89a83a615b4d398415bdc83"
        },
        eip155: {
          address: "0x998739BFdAAdde7C933B942a68053933098f9EDa",
          codeHash: "0x81db0e4afdf5178583537b58c5ad403bd47a4ac7f9bde2442ef3e341d433126a"
        },
        zksync: {
          address: "0x0dFcccB95225ffB03c6FBB2559B530C2B7C8A912",
          codeHash: "0xd9aa004a59b3738a108e747e578ae409b84e9f3ffd689d81b10f4d96000c5f5c"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send.json
var require_multi_send3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "MultiSend",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
          codeHash: "0x0e4f7fc66550a322d1e7688e181b75e217e662a4f3f4d6a29b22bc61217c4b77"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send_call_only.json
var require_multi_send_call_only = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/multi_send_call_only.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "MultiSendCallOnly",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0x40A2aCCbd92BCA938b02010E17A5b8929b49130D",
          codeHash: "0xa9865ac2d9c7a1591619b188c4d88167b50df6cc0c5327fcbd1c8c75f7c066ad"
        },
        eip155: {
          address: "0xA1dabEF33b3B82c7814B6D82A79e50F4AC44102B",
          codeHash: "0xa9865ac2d9c7a1591619b188c4d88167b50df6cc0c5327fcbd1c8c75f7c066ad"
        },
        zksync: {
          address: "0xf220D3b4DFb23C4ade8C88E526C1353AbAcbC38F",
          codeHash: "0x064ddbf252714bcd4cb79f679e8c12df96d998ce07bbb13b3118c1dbf4a31942"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send_call_only.json
var require_multi_send_call_only2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/multi_send_call_only.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "MultiSendCallOnly",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x9641d764fc13c8B624c04430C7356C1C7C8102e2",
          codeHash: "0xecd5bd14a08c5d2122379900b2f272bdf107a7e92423c10dd5fe3254386c9939"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "bytes",
              name: "transactions",
              type: "bytes"
            }
          ],
          name: "multiSend",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/create_call.json
var require_create_call = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/create_call.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "CreateCall",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4",
          codeHash: "0x8155d988823a4f6f1bcbc76a64af8e510c4ce68819290d43cf24956bd24dee82"
        },
        eip155: {
          address: "0xB19D6FFc2182150F8Eb585b79D4ABcd7C5640A9d",
          codeHash: "0x8155d988823a4f6f1bcbc76a64af8e510c4ce68819290d43cf24956bd24dee82"
        },
        zksync: {
          address: "0xcB8e5E438c5c2b45FbE17B02Ca9aF91509a8ad56",
          codeHash: "0x98095337deb9718f4e5ccb1b25a53be5f5e0093502b29df9e857f5e3e12aa194"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            }
          ],
          name: "performCreate",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            },
            {
              internalType: "bytes32",
              name: "salt",
              type: "bytes32"
            }
          ],
          name: "performCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/create_call.json
var require_create_call2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/create_call.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "CreateCall",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x9b35Af71d77eaf8d7e40252370304687390A1A52",
          codeHash: "0x2b3060c55fcb8275653e99ad511a71f67ba76934ed66a7d74d6e68b52afff889"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          name: "ContractCreation",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            }
          ],
          name: "performCreate",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "deploymentData",
              type: "bytes"
            },
            {
              internalType: "bytes32",
              name: "salt",
              type: "bytes32"
            }
          ],
          name: "performCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newContract",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/sign_message_lib.json
var require_sign_message_lib = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.3.0/sign_message_lib.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SignMessageLib",
      version: "1.3.0",
      deployments: {
        canonical: {
          address: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
          codeHash: "0x3ac65dea3cc9dd0d7b7b800f834e3d73415b4e944bb94555c3e4a08fb137e918"
        },
        eip155: {
          address: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
          codeHash: "0x3ac65dea3cc9dd0d7b7b800f834e3d73415b4e944bb94555c3e4a08fb137e918"
        },
        zksync: {
          address: "0x357147caf9C0cCa67DfA0CF5369318d8193c8407",
          codeHash: "0x9da86f7e32ef976bd442a8eeb353e16d683b53e30e926ae7adce7c609f75b1fc"
        }
      },
      networkAddresses: {
        "1": ["canonical", "eip155"],
        "3": "canonical",
        "4": "canonical",
        "5": "canonical",
        "10": ["eip155", "canonical"],
        "11": "canonical",
        "12": "canonical",
        "14": "canonical",
        "16": "eip155",
        "18": "eip155",
        "19": "eip155",
        "25": ["eip155", "canonical"],
        "28": "eip155",
        "30": "canonical",
        "31": "canonical",
        "39": "canonical",
        "40": "canonical",
        "41": "canonical",
        "42": "canonical",
        "43": ["eip155", "canonical"],
        "44": ["eip155", "canonical"],
        "46": ["eip155", "canonical"],
        "50": "canonical",
        "51": "canonical",
        "56": ["canonical", "eip155"],
        "57": "eip155",
        "61": "eip155",
        "63": "eip155",
        "69": "eip155",
        "71": "canonical",
        "81": "eip155",
        "82": "eip155",
        "83": ["eip155", "canonical"],
        "97": "canonical",
        "100": ["canonical", "eip155"],
        "106": "eip155",
        "108": "eip155",
        "109": "eip155",
        "111": "eip155",
        "114": "canonical",
        "122": "canonical",
        "123": "canonical",
        "137": ["canonical", "eip155"],
        "148": "eip155",
        "155": "eip155",
        "169": "canonical",
        "179": "eip155",
        "195": "eip155",
        "196": ["eip155", "canonical"],
        "204": ["eip155", "canonical"],
        "240": "zksync",
        "246": "canonical",
        "250": ["canonical", "eip155"],
        "252": ["eip155", "canonical"],
        "255": "eip155",
        "280": "zksync",
        "282": "zksync",
        "288": "eip155",
        "291": "canonical",
        "300": "canonical",
        "321": "canonical",
        "322": "canonical",
        "324": "zksync",
        "336": ["canonical", "eip155"],
        "338": "eip155",
        "360": "eip155",
        "369": "canonical",
        "388": "zksync",
        "420": "eip155",
        "424": "canonical",
        "480": ["canonical", "eip155"],
        "570": "eip155",
        "588": "eip155",
        "592": "canonical",
        "595": "eip155",
        "599": "eip155",
        "648": ["canonical", "eip155"],
        "686": "eip155",
        "690": ["eip155", "canonical"],
        "787": "eip155",
        "919": ["canonical", "eip155"],
        "943": "canonical",
        "1001": "eip155",
        "1008": "canonical",
        "1030": "canonical",
        "1088": ["eip155", "canonical"],
        "1101": ["canonical", "eip155"],
        "1111": "eip155",
        "1112": "eip155",
        "1115": "canonical",
        "1116": "canonical",
        "1135": ["canonical", "eip155"],
        "1230": "eip155",
        "1231": "eip155",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1294": "eip155",
        "1329": "canonical",
        "1337": "eip155",
        "1442": "eip155",
        "1513": ["eip155", "canonical"],
        "1516": "eip155",
        "1559": "eip155",
        "1663": "eip155",
        "1729": "canonical",
        "1807": "canonical",
        "1890": "canonical",
        "1891": "canonical",
        "1984": "canonical",
        "1998": "canonical",
        "2001": "canonical",
        "2002": "canonical",
        "2008": "canonical",
        "2019": "canonical",
        "2020": "canonical",
        "2021": "canonical",
        "2039": "canonical",
        "2192": ["canonical", "eip155"],
        "2221": ["canonical", "eip155"],
        "2222": ["canonical", "eip155"],
        "2331": "canonical",
        "2358": "eip155",
        "2810": ["eip155", "canonical"],
        "2818": ["canonical", "eip155"],
        "3338": "canonical",
        "3737": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4078": "canonical",
        "4157": "eip155",
        "4202": "canonical",
        "4337": "canonical",
        "4460": "canonical",
        "4653": "eip155",
        "4689": "eip155",
        "4918": "canonical",
        "4919": "canonical",
        "5000": ["eip155", "canonical"],
        "5001": "eip155",
        "5003": ["eip155", "canonical"],
        "5165": "canonical",
        "5700": ["eip155", "canonical"],
        "6001": "canonical",
        "6102": "eip155",
        "6398": "eip155",
        "7000": ["eip155", "canonical"],
        "7001": "eip155",
        "7332": "eip155",
        "7341": "canonical",
        "7560": ["canonical", "eip155"],
        "7700": "eip155",
        "8192": "eip155",
        "8194": "eip155",
        "8217": "eip155",
        "8329": "canonical",
        "8453": ["eip155", "canonical"],
        "8822": "eip155",
        "9000": ["canonical", "eip155"],
        "9001": ["canonical", "eip155"],
        "9728": "eip155",
        "10000": "eip155",
        "10001": "eip155",
        "10081": "eip155",
        "10200": "canonical",
        "10242": "eip155",
        "10243": "eip155",
        "10849": "canonical",
        "11011": "eip155",
        "11111": "canonical",
        "11235": "canonical",
        "11437": "canonical",
        "11891": "canonical",
        "12324": "canonical",
        "12325": "canonical",
        "12357": "canonical",
        "12553": "canonical",
        "13337": "canonical",
        "13371": "eip155",
        "13473": "eip155",
        "14800": "eip155",
        "17000": ["canonical", "eip155"],
        "17069": ["eip155", "canonical"],
        "17172": "eip155",
        "18231": "canonical",
        "18233": "canonical",
        "22776": "canonical",
        "23294": "eip155",
        "23295": "eip155",
        "25327": "eip155",
        "28979": "canonical",
        "33139": "eip155",
        "33401": "canonical",
        "34443": ["canonical", "eip155"],
        "35441": "canonical",
        "35443": "canonical",
        "41455": ["canonical", "eip155"],
        "42161": ["canonical", "eip155"],
        "42170": "canonical",
        "42220": ["eip155", "canonical"],
        "42793": "eip155",
        "43113": ["canonical", "eip155"],
        "43114": ["eip155", "canonical"],
        "43288": "eip155",
        "44787": "canonical",
        "45000": "canonical",
        "47763": "canonical",
        "47805": "canonical",
        "48899": "eip155",
        "48900": ["canonical", "eip155"],
        "53457": "canonical",
        "54211": "eip155",
        "56288": "eip155",
        "57000": "eip155",
        "58008": "canonical",
        "59140": ["canonical", "eip155"],
        "59144": ["canonical", "eip155"],
        "60808": ["canonical", "eip155"],
        "71401": "eip155",
        "71402": "eip155",
        "73799": "canonical",
        "80001": "canonical",
        "80002": "canonical",
        "80084": "canonical",
        "80085": ["canonical", "eip155"],
        "81457": ["canonical", "eip155"],
        "83291": "canonical",
        "84531": "eip155",
        "84532": ["eip155", "canonical"],
        "97435": "canonical",
        "103454": "eip155",
        "111188": "canonical",
        "128123": ["eip155", "canonical"],
        "167000": ["eip155", "canonical"],
        "167008": "canonical",
        "167009": ["eip155", "canonical"],
        "200101": "canonical",
        "200202": "canonical",
        "200810": "canonical",
        "328527": "canonical",
        "333999": "canonical",
        "421611": "canonical",
        "421613": "canonical",
        "421614": "canonical",
        "490000": ["canonical", "eip155"],
        "534351": ["canonical", "eip155"],
        "534352": ["canonical", "eip155"],
        "534353": "eip155",
        "555666": "canonical",
        "622277": "canonical",
        "656476": ["eip155", "canonical"],
        "660279": "canonical",
        "713715": ["eip155", "canonical"],
        "763373": "eip155",
        "764984": "canonical",
        "808813": "eip155",
        "810180": "zksync",
        "978657": "canonical",
        "4457845": "zksync",
        "6038361": ["eip155", "canonical"],
        "7225878": "eip155",
        "7777777": ["canonical", "eip155"],
        "11155111": ["eip155", "canonical"],
        "11155420": "eip155",
        "12227332": "canonical",
        "94204209": ["canonical", "eip155"],
        "111557560": ["canonical", "eip155"],
        "123420111": ["canonical", "eip155"],
        "161221135": "canonical",
        "168587773": "canonical",
        "222000222": "canonical",
        "245022926": "eip155",
        "245022934": "eip155",
        "328527624": "canonical",
        "333000333": "canonical",
        "476462898": "canonical",
        "666666666": ["canonical", "eip155"],
        "888888888": "canonical",
        "999999999": ["canonical", "eip155"],
        "1313161554": ["canonical", "eip155"],
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "eip155",
        "1666700000": "eip155",
        "11297108099": "canonical",
        "11297108109": "canonical",
        "37714555429": "canonical",
        "88153591557": ["canonical", "eip155"]
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/sign_message_lib.json
var require_sign_message_lib2 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/sign_message_lib.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SignMessageLib",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0xd53cd0aB83D845Ac265BE939c57F53AD838012c9",
          codeHash: "0x525c754a46b79e05543a59bb61e8de3c9eee0d955a59352409cbe67ea1077528"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "5": "canonical",
        "10": "canonical",
        "14": "canonical",
        "16": "canonical",
        "19": "canonical",
        "25": "canonical",
        "31": "canonical",
        "40": "canonical",
        "41": "canonical",
        "56": "canonical",
        "71": "canonical",
        "81": "canonical",
        "88": "canonical",
        "97": "canonical",
        "100": "canonical",
        "114": "canonical",
        "137": "canonical",
        "155": "canonical",
        "169": "canonical",
        "196": "canonical",
        "250": "canonical",
        "252": "canonical",
        "255": "canonical",
        "314": "canonical",
        "336": "canonical",
        "338": "canonical",
        "369": "canonical",
        "480": "canonical",
        "530": "canonical",
        "592": "canonical",
        "690": "canonical",
        "919": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1030": "canonical",
        "1101": "canonical",
        "1111": "canonical",
        "1112": "canonical",
        "1135": "canonical",
        "1284": "canonical",
        "1285": "canonical",
        "1287": "canonical",
        "1329": "canonical",
        "1337": "canonical",
        "1442": "canonical",
        "1516": "canonical",
        "1625": "canonical",
        "1729": "canonical",
        "1811": "canonical",
        "2000": "canonical",
        "2039": "canonical",
        "2187": "canonical",
        "2192": "canonical",
        "2358": "canonical",
        "2442": "canonical",
        "2810": "canonical",
        "2818": "canonical",
        "3338": "canonical",
        "3636": "canonical",
        "3776": "canonical",
        "4002": "canonical",
        "4062": "canonical",
        "4157": "canonical",
        "4162": "canonical",
        "4202": "canonical",
        "4337": "canonical",
        "4653": "canonical",
        "5000": "canonical",
        "5003": "canonical",
        "5115": "canonical",
        "6001": "canonical",
        "6321": "canonical",
        "6322": "canonical",
        "6688": "canonical",
        "7000": "canonical",
        "7001": "canonical",
        "7171": "canonical",
        "7560": "canonical",
        "7771": "canonical",
        "8192": "canonical",
        "8194": "canonical",
        "8453": "canonical",
        "9001": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "10242": "canonical",
        "10243": "canonical",
        "11235": "canonical",
        "11501": "canonical",
        "11503": "canonical",
        "13337": "canonical",
        "13746": "canonical",
        "17000": "canonical",
        "17069": "canonical",
        "18233": "canonical",
        "23294": "canonical",
        "23295": "canonical",
        "32769": "canonical",
        "33101": "canonical",
        "34443": "canonical",
        "35441": "canonical",
        "35443": "canonical",
        "41455": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "54211": "canonical",
        "59140": "canonical",
        "59141": "canonical",
        "59144": "canonical",
        "80001": "canonical",
        "80085": "canonical",
        "81457": "canonical",
        "84531": "canonical",
        "84532": "canonical",
        "90001": "canonical",
        "105105": "canonical",
        "111188": "canonical",
        "167000": "canonical",
        "167009": "canonical",
        "205205": "canonical",
        "314159": "canonical",
        "421614": "canonical",
        "444444": "canonical",
        "534351": "canonical",
        "534352": "canonical",
        "555666": "canonical",
        "713715": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "6038361": "canonical",
        "7225878": "canonical",
        "7777777": "canonical",
        "9999999": "canonical",
        "11155111": "canonical",
        "11155420": "canonical",
        "52164803": "canonical",
        "94204209": "canonical",
        "111557560": "canonical",
        "123420111": "canonical",
        "168587773": "canonical",
        "476462898": "canonical",
        "666666666": "canonical",
        "999999999": "canonical",
        "1313161554": "canonical",
        "1313161555": "canonical",
        "1511670449": "canonical",
        "1666600000": "canonical",
        "1666700000": "canonical",
        "88153591557": "canonical",
        "123420000220": "canonical"
      },
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "msgHash",
              type: "bytes32"
            }
          ],
          name: "SignMsg",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "message",
              type: "bytes"
            }
          ],
          name: "getMessageHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "signMessage",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_migration.json
var require_safe_migration = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_migration.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SafeMigration",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0x526643F69b81B008F46d95CD5ced5eC0edFFDaC6",
          codeHash: "0xc00d7921460cd5a05393e7772e634bd7d212f356356aa3a77f0120a9b8e25e99"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "10": "canonical",
        "56": "canonical",
        "81": "canonical",
        "88": "canonical",
        "100": "canonical",
        "137": "canonical",
        "196": "canonical",
        "480": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1101": "canonical",
        "1337": "canonical",
        "1516": "canonical",
        "2187": "canonical",
        "2442": "canonical",
        "2818": "canonical",
        "5000": "canonical",
        "5115": "canonical",
        "8453": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "13746": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "59144": "canonical",
        "81457": "canonical",
        "84532": "canonical",
        "534352": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "11155111": "canonical",
        "1313161554": "canonical"
      },
      abi: [
        {
          inputs: [
            {
              internalType: "address",
              name: "safeSingleton",
              type: "address"
            },
            {
              internalType: "address",
              name: "safeL2Singleton",
              type: "address"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          inputs: [],
          name: "MIGRATION_SINGLETON",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "SAFE_FALLBACK_HANDLER",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "SAFE_L2_SINGLETON",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "SAFE_SINGLETON",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "migrateL2Singleton",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "migrateL2WithFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "migrateSingleton",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "migrateWithFallbackHandler",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_to_l2_migration.json
var require_safe_to_l2_migration = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_to_l2_migration.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SafeToL2Migration",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0xfF83F6335d8930cBad1c0D439A841f01888D9f69",
          codeHash: "0xa83e7be2fa20c96dc9575e3937239d552f3831ea437d7c96397eec8736f0cba0"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "10": "canonical",
        "56": "canonical",
        "81": "canonical",
        "88": "canonical",
        "100": "canonical",
        "137": "canonical",
        "196": "canonical",
        "480": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1101": "canonical",
        "1337": "canonical",
        "1516": "canonical",
        "2187": "canonical",
        "2442": "canonical",
        "2818": "canonical",
        "5000": "canonical",
        "5115": "canonical",
        "8453": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "13746": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "59144": "canonical",
        "81457": "canonical",
        "84532": "canonical",
        "534352": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "11155111": "canonical",
        "1313161554": "canonical"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "data",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "enum Enum.Operation",
              name: "operation",
              type: "uint8"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "safeTxGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "baseGas",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "gasPrice",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "gasToken",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address payable",
              name: "refundReceiver",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "signatures",
              type: "bytes"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "additionalInfo",
              type: "bytes"
            }
          ],
          name: "SafeMultiSigTransaction",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "initiator",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address[]",
              name: "owners",
              type: "address[]"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "threshold",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "address",
              name: "initializer",
              type: "address"
            },
            {
              indexed: false,
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "SafeSetup",
          type: "event"
        },
        {
          inputs: [],
          name: "MIGRATION_SINGLETON",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "l2Singleton",
              type: "address"
            },
            {
              internalType: "address",
              name: "fallbackHandler",
              type: "address"
            }
          ],
          name: "migrateFromV111",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "l2Singleton",
              type: "address"
            }
          ],
          name: "migrateToL2",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_to_l2_setup.json
var require_safe_to_l2_setup = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/assets/v1.4.1/safe_to_l2_setup.json"(exports, module) {
    module.exports = {
      released: true,
      contractName: "SafeToL2Setup",
      version: "1.4.1",
      deployments: {
        canonical: {
          address: "0xBD89A1CE4DDe368FFAB0eC35506eEcE0b1fFdc54",
          codeHash: "0x2f25df28caf984366ee584e13241707e85dcd5a6ea0c14267928dafc1fd6274b"
        }
      },
      networkAddresses: {
        "1": "canonical",
        "10": "canonical",
        "56": "canonical",
        "81": "canonical",
        "88": "canonical",
        "100": "canonical",
        "137": "canonical",
        "196": "canonical",
        "480": "canonical",
        "970": "canonical",
        "995": "canonical",
        "1101": "canonical",
        "1337": "canonical",
        "1516": "canonical",
        "2187": "canonical",
        "2442": "canonical",
        "2818": "canonical",
        "5000": "canonical",
        "5115": "canonical",
        "8453": "canonical",
        "9700": "canonical",
        "10081": "canonical",
        "13746": "canonical",
        "42161": "canonical",
        "42220": "canonical",
        "42421": "canonical",
        "43114": "canonical",
        "44787": "canonical",
        "59144": "canonical",
        "81457": "canonical",
        "84532": "canonical",
        "534352": "canonical",
        "743111": "canonical",
        "3441006": "canonical",
        "11155111": "canonical",
        "1313161554": "canonical"
      },
      abi: [
        {
          inputs: [],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "singleton",
              type: "address"
            }
          ],
          name: "ChangedMasterCopy",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "l2Singleton",
              type: "address"
            }
          ],
          name: "setupToL2",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/@safe-global/safe-deployments/dist/deployments.js
var require_deployments = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/deployments.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._SAFE_TO_L2_SETUP_DEPLOYMENTS = exports._SAFE_TO_L2_MIGRATION_DEPLOYMENTS = exports._SAFE_MIGRATION_DEPLOYMENTS = exports._SIGN_MESSAGE_LIB_DEPLOYMENTS = exports._CREATE_CALL_DEPLOYMENTS = exports._MULTI_SEND_CALL_ONLY_DEPLOYMENTS = exports._MULTI_SEND_DEPLOYMENTS = exports._SAFE_L2_DEPLOYMENTS = exports._SAFE_DEPLOYMENTS = exports._COMPAT_FALLBACK_HANDLER_DEPLOYMENTS = exports._DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS = exports._FACTORY_DEPLOYMENTS = exports._ACCESSOR_DEPLOYMENTS = void 0;
    var simulate_tx_accessor_json_1 = __importDefault(require_simulate_tx_accessor());
    var simulate_tx_accessor_json_2 = __importDefault(require_simulate_tx_accessor2());
    var _ACCESSOR_DEPLOYMENTS = [simulate_tx_accessor_json_2.default, simulate_tx_accessor_json_1.default];
    exports._ACCESSOR_DEPLOYMENTS = _ACCESSOR_DEPLOYMENTS;
    var proxy_factory_json_1 = __importDefault(require_proxy_factory());
    var proxy_factory_json_2 = __importDefault(require_proxy_factory2());
    var proxy_factory_json_3 = __importDefault(require_proxy_factory3());
    var safe_proxy_factory_json_1 = __importDefault(require_safe_proxy_factory());
    var _FACTORY_DEPLOYMENTS = [
      safe_proxy_factory_json_1.default,
      proxy_factory_json_3.default,
      proxy_factory_json_2.default,
      proxy_factory_json_1.default
    ];
    exports._FACTORY_DEPLOYMENTS = _FACTORY_DEPLOYMENTS;
    var default_callback_handler_json_1 = __importDefault(require_default_callback_handler());
    var _DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS = [default_callback_handler_json_1.default];
    exports._DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS = _DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS;
    var compatibility_fallback_handler_json_1 = __importDefault(require_compatibility_fallback_handler());
    var compatibility_fallback_handler_json_2 = __importDefault(require_compatibility_fallback_handler2());
    var _COMPAT_FALLBACK_HANDLER_DEPLOYMENTS = [
      compatibility_fallback_handler_json_2.default,
      compatibility_fallback_handler_json_1.default
    ];
    exports._COMPAT_FALLBACK_HANDLER_DEPLOYMENTS = _COMPAT_FALLBACK_HANDLER_DEPLOYMENTS;
    var safe_json_1 = __importDefault(require_safe());
    var gnosis_safe_json_1 = __importDefault(require_gnosis_safe());
    var gnosis_safe_json_2 = __importDefault(require_gnosis_safe2());
    var gnosis_safe_json_3 = __importDefault(require_gnosis_safe3());
    var gnosis_safe_json_4 = __importDefault(require_gnosis_safe4());
    var _SAFE_DEPLOYMENTS = [
      safe_json_1.default,
      gnosis_safe_json_1.default,
      gnosis_safe_json_2.default,
      gnosis_safe_json_3.default,
      gnosis_safe_json_4.default
    ];
    exports._SAFE_DEPLOYMENTS = _SAFE_DEPLOYMENTS;
    var safe_l2_json_1 = __importDefault(require_safe_l2());
    var gnosis_safe_l2_json_1 = __importDefault(require_gnosis_safe_l2());
    var _SAFE_L2_DEPLOYMENTS = [safe_l2_json_1.default, gnosis_safe_l2_json_1.default];
    exports._SAFE_L2_DEPLOYMENTS = _SAFE_L2_DEPLOYMENTS;
    var multi_send_json_1 = __importDefault(require_multi_send());
    var multi_send_json_2 = __importDefault(require_multi_send2());
    var multi_send_json_3 = __importDefault(require_multi_send3());
    var _MULTI_SEND_DEPLOYMENTS = [multi_send_json_3.default, multi_send_json_2.default, multi_send_json_1.default];
    exports._MULTI_SEND_DEPLOYMENTS = _MULTI_SEND_DEPLOYMENTS;
    var multi_send_call_only_json_1 = __importDefault(require_multi_send_call_only());
    var multi_send_call_only_json_2 = __importDefault(require_multi_send_call_only2());
    var _MULTI_SEND_CALL_ONLY_DEPLOYMENTS = [multi_send_call_only_json_2.default, multi_send_call_only_json_1.default];
    exports._MULTI_SEND_CALL_ONLY_DEPLOYMENTS = _MULTI_SEND_CALL_ONLY_DEPLOYMENTS;
    var create_call_json_1 = __importDefault(require_create_call());
    var create_call_json_2 = __importDefault(require_create_call2());
    var _CREATE_CALL_DEPLOYMENTS = [create_call_json_2.default, create_call_json_1.default];
    exports._CREATE_CALL_DEPLOYMENTS = _CREATE_CALL_DEPLOYMENTS;
    var sign_message_lib_json_1 = __importDefault(require_sign_message_lib());
    var sign_message_lib_json_2 = __importDefault(require_sign_message_lib2());
    var _SIGN_MESSAGE_LIB_DEPLOYMENTS = [sign_message_lib_json_2.default, sign_message_lib_json_1.default];
    exports._SIGN_MESSAGE_LIB_DEPLOYMENTS = _SIGN_MESSAGE_LIB_DEPLOYMENTS;
    var safe_migration_json_1 = __importDefault(require_safe_migration());
    var _SAFE_MIGRATION_DEPLOYMENTS = [safe_migration_json_1.default];
    exports._SAFE_MIGRATION_DEPLOYMENTS = _SAFE_MIGRATION_DEPLOYMENTS;
    var safe_to_l2_migration_json_1 = __importDefault(require_safe_to_l2_migration());
    var _SAFE_TO_L2_MIGRATION_DEPLOYMENTS = [safe_to_l2_migration_json_1.default];
    exports._SAFE_TO_L2_MIGRATION_DEPLOYMENTS = _SAFE_TO_L2_MIGRATION_DEPLOYMENTS;
    var safe_to_l2_setup_json_1 = __importDefault(require_safe_to_l2_setup());
    var _SAFE_TO_L2_SETUP_DEPLOYMENTS = [safe_to_l2_setup_json_1.default];
    exports._SAFE_TO_L2_SETUP_DEPLOYMENTS = _SAFE_TO_L2_SETUP_DEPLOYMENTS;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/lrucache.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/parse-options.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/constants.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/debug.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/re.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/internal/identifiers.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/classes/semver.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/compare.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/eq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/neq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/gt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/gte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/lt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/lte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/cmp.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/classes/comparator.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/classes/range.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@safe-global/safe-deployments/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/@safe-global/safe-deployments/node_modules/semver/functions/satisfies.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/@safe-global/safe-deployments/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findDeployment = findDeployment;
    var satisfies_1 = __importDefault(require_satisfies());
    var DEFAULT_FILTER = { released: true };
    var DEFAULT_NETWORK_CHAIN_ID = "1";
    var mapJsonToDeploymentsFormatV1 = (deployment) => {
      const defaultAddressType = Array.isArray(deployment.networkAddresses[DEFAULT_NETWORK_CHAIN_ID]) ? deployment.networkAddresses[DEFAULT_NETWORK_CHAIN_ID][0] : deployment.networkAddresses[DEFAULT_NETWORK_CHAIN_ID];
      const defaultAddress = deployment.deployments[defaultAddressType].address;
      const networkAddresses = Object.fromEntries(Object.entries(deployment.networkAddresses).map(([chainId, addressTypes]) => [
        chainId,
        Array.isArray(addressTypes) ? deployment.deployments[addressTypes[0]].address : deployment.deployments[addressTypes].address
      ]));
      return Object.assign(Object.assign({}, deployment), { defaultAddress, networkAddresses });
    };
    var mapJsonToDeploymentsFormatV2 = (deployment) => Object.assign(Object.assign({}, deployment), { networkAddresses: Object.fromEntries(Object.entries(deployment.networkAddresses).map(([chainId, addressTypes]) => [
      chainId,
      Array.isArray(addressTypes) ? (
        // The usage of non-null assertion below is safe, because we validate that the asset files are properly formed in tests
        addressTypes.map((addressType) => deployment.deployments[addressType].address)
      ) : deployment.deployments[addressTypes].address
    ])) });
    function findDeployment(criteria = DEFAULT_FILTER, deployments, format2 = "singleton") {
      const { version, released, network } = Object.assign(Object.assign({}, DEFAULT_FILTER), criteria);
      const deploymentJson = deployments.find((deployment) => {
        if (version && !(0, satisfies_1.default)(deployment.version, version))
          return false;
        if (typeof released === "boolean" && deployment.released !== released)
          return false;
        if (network && !deployment.networkAddresses[network])
          return false;
        return true;
      });
      if (!deploymentJson)
        return void 0;
      if (format2 === "multiple") {
        return mapJsonToDeploymentsFormatV2(deploymentJson);
      } else {
        return mapJsonToDeploymentsFormatV1(deploymentJson);
      }
    }
  }
});

// node_modules/@safe-global/safe-deployments/dist/safes.js
var require_safes = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/safes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSafeL2SingletonDeployments = exports.getSafeL2SingletonDeployment = exports.getSafeSingletonDeployments = exports.getSafeSingletonDeployment = void 0;
    var deployments_1 = require_deployments();
    var utils_1 = require_utils3();
    var getSafeSingletonDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SAFE_DEPLOYMENTS);
    };
    exports.getSafeSingletonDeployment = getSafeSingletonDeployment;
    var getSafeSingletonDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SAFE_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSafeSingletonDeployments = getSafeSingletonDeployments;
    var getSafeL2SingletonDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SAFE_L2_DEPLOYMENTS);
    };
    exports.getSafeL2SingletonDeployment = getSafeL2SingletonDeployment;
    var getSafeL2SingletonDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SAFE_L2_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSafeL2SingletonDeployments = getSafeL2SingletonDeployments;
  }
});

// node_modules/@safe-global/safe-deployments/dist/factories.js
var require_factories = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/factories.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProxyFactoryDeployments = exports.getProxyFactoryDeployment = void 0;
    var utils_1 = require_utils3();
    var deployments_1 = require_deployments();
    var getProxyFactoryDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._FACTORY_DEPLOYMENTS);
    };
    exports.getProxyFactoryDeployment = getProxyFactoryDeployment;
    var getProxyFactoryDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._FACTORY_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getProxyFactoryDeployments = getProxyFactoryDeployments;
  }
});

// node_modules/@safe-global/safe-deployments/dist/libs.js
var require_libs = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/libs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSafeToL2SetupDeployments = exports.getSafeToL2SetupDeployment = exports.getSafeToL2MigrationDeployments = exports.getSafeToL2MigrationDeployment = exports.getSafeMigrationDeployments = exports.getSafeMigrationDeployment = exports.getSignMessageLibDeployments = exports.getSignMessageLibDeployment = exports.getCreateCallDeployments = exports.getCreateCallDeployment = exports.getMultiSendCallOnlyDeployments = exports.getMultiSendCallOnlyDeployment = exports.getMultiSendDeployments = exports.getMultiSendDeployment = void 0;
    var deployments_1 = require_deployments();
    var utils_1 = require_utils3();
    var getMultiSendDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._MULTI_SEND_DEPLOYMENTS);
    };
    exports.getMultiSendDeployment = getMultiSendDeployment;
    var getMultiSendDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._MULTI_SEND_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getMultiSendDeployments = getMultiSendDeployments;
    var getMultiSendCallOnlyDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._MULTI_SEND_CALL_ONLY_DEPLOYMENTS);
    };
    exports.getMultiSendCallOnlyDeployment = getMultiSendCallOnlyDeployment;
    var getMultiSendCallOnlyDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._MULTI_SEND_CALL_ONLY_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getMultiSendCallOnlyDeployments = getMultiSendCallOnlyDeployments;
    var getCreateCallDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._CREATE_CALL_DEPLOYMENTS);
    };
    exports.getCreateCallDeployment = getCreateCallDeployment;
    var getCreateCallDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._CREATE_CALL_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getCreateCallDeployments = getCreateCallDeployments;
    var getSignMessageLibDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SIGN_MESSAGE_LIB_DEPLOYMENTS);
    };
    exports.getSignMessageLibDeployment = getSignMessageLibDeployment;
    var getSignMessageLibDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SIGN_MESSAGE_LIB_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSignMessageLibDeployments = getSignMessageLibDeployments;
    var getSafeMigrationDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SAFE_MIGRATION_DEPLOYMENTS);
    };
    exports.getSafeMigrationDeployment = getSafeMigrationDeployment;
    var getSafeMigrationDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SAFE_MIGRATION_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSafeMigrationDeployments = getSafeMigrationDeployments;
    var getSafeToL2MigrationDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SAFE_TO_L2_MIGRATION_DEPLOYMENTS);
    };
    exports.getSafeToL2MigrationDeployment = getSafeToL2MigrationDeployment;
    var getSafeToL2MigrationDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SAFE_TO_L2_MIGRATION_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSafeToL2MigrationDeployments = getSafeToL2MigrationDeployments;
    var getSafeToL2SetupDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._SAFE_TO_L2_SETUP_DEPLOYMENTS);
    };
    exports.getSafeToL2SetupDeployment = getSafeToL2SetupDeployment;
    var getSafeToL2SetupDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._SAFE_TO_L2_SETUP_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSafeToL2SetupDeployments = getSafeToL2SetupDeployments;
  }
});

// node_modules/@safe-global/safe-deployments/dist/handler.js
var require_handler = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/handler.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFallbackHandlerDeployment = exports.getCompatibilityFallbackHandlerDeployments = exports.getCompatibilityFallbackHandlerDeployment = exports.getDefaultCallbackHandlerDeployments = exports.getDefaultCallbackHandlerDeployment = void 0;
    var utils_1 = require_utils3();
    var deployments_1 = require_deployments();
    var getDefaultCallbackHandlerDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS);
    };
    exports.getDefaultCallbackHandlerDeployment = getDefaultCallbackHandlerDeployment;
    var getDefaultCallbackHandlerDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._DEFAULT_CALLBACK_HANDLER_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getDefaultCallbackHandlerDeployments = getDefaultCallbackHandlerDeployments;
    var getCompatibilityFallbackHandlerDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._COMPAT_FALLBACK_HANDLER_DEPLOYMENTS);
    };
    exports.getCompatibilityFallbackHandlerDeployment = getCompatibilityFallbackHandlerDeployment;
    var getCompatibilityFallbackHandlerDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._COMPAT_FALLBACK_HANDLER_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getCompatibilityFallbackHandlerDeployments = getCompatibilityFallbackHandlerDeployments;
    exports.getFallbackHandlerDeployment = exports.getCompatibilityFallbackHandlerDeployment;
  }
});

// node_modules/@safe-global/safe-deployments/dist/accessors.js
var require_accessors = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/accessors.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSimulateTxAccessorDeployments = exports.getSimulateTxAccessorDeployment = void 0;
    var utils_1 = require_utils3();
    var deployments_1 = require_deployments();
    var getSimulateTxAccessorDeployment = (filter2) => {
      return (0, utils_1.findDeployment)(filter2, deployments_1._ACCESSOR_DEPLOYMENTS);
    };
    exports.getSimulateTxAccessorDeployment = getSimulateTxAccessorDeployment;
    var getSimulateTxAccessorDeployments = (filter2) => {
      return (0, utils_1.findDeployment)(
        filter2,
        deployments_1._ACCESSOR_DEPLOYMENTS,
        "multiple"
        /* DeploymentFormats.MULTIPLE */
      );
    };
    exports.getSimulateTxAccessorDeployments = getSimulateTxAccessorDeployments;
  }
});

// node_modules/@safe-global/safe-deployments/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@safe-global/safe-deployments/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types2(), exports);
    __exportStar(require_safes(), exports);
    __exportStar(require_factories(), exports);
    __exportStar(require_libs(), exports);
    __exportStar(require_handler(), exports);
    __exportStar(require_accessors(), exports);
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js
var require_utils4 = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapReceipt = exports.createLibInterface = exports.createLibAddress = exports.createLibDeployment = void 0;
    var abi_1 = (init_lib5(), __toCommonJS(lib_exports5));
    var address_1 = (init_lib3(), __toCommonJS(lib_exports3));
    var safe_deployments_1 = require_dist5();
    exports.createLibDeployment = (0, safe_deployments_1.getCreateCallDeployment)();
    exports.createLibAddress = exports.createLibDeployment.defaultAddress;
    exports.createLibInterface = new abi_1.Interface(exports.createLibDeployment.abi);
    var mapStatus = (receipt) => {
      const success = receipt.logs.find((log) => log.topics[0] === "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e");
      return !!success ? 1 : 0;
    };
    var mapContractAddress = (receipt, safeTx) => {
      if (safeTx.to.toLowerCase() === exports.createLibAddress.toLowerCase()) {
        const creationLog = receipt.logs.find((log) => log.topics[0] === "0x4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511");
        if (creationLog)
          return (0, address_1.getAddress)("0x" + creationLog.data.slice(creationLog.data.length - 40));
      }
      return receipt.contractAddress;
    };
    var mapReceipt = (receipt, safeTx) => {
      receipt.status = mapStatus(receipt);
      receipt.contractAddress = mapContractAddress(receipt, safeTx);
      return receipt;
    };
    exports.mapReceipt = mapReceipt;
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js
var require_signer = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/signer.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeEthersSigner = void 0;
    var abstract_signer_1 = (init_lib6(), __toCommonJS(lib_exports6));
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    var utils_1 = require_utils4();
    var sleep = (duration) => new Promise((resolve2) => setTimeout(resolve2, duration));
    var SafeEthersSigner2 = class extends abstract_signer_1.VoidSigner {
      /**
       * Creates an instance of the SafeEthersSigner.
       * @param safe - Safe that should be used
       * @param service - Services to which the transactions should be proposed to
       * @param provider - (Optional) Provider that should be used for blockchain interactions. By default the provider from the signer is used.
       * @param options - (Optional) Additional options (e.g. polling delay when waiting for a transaction to be mined)
       * @returns The SafeEthersSigner instance
       */
      constructor(safe, service, provider, options) {
        super(safe.getAddress(), provider);
        this.service = service;
        this.safe = safe;
        this.options = options;
      }
      async buildTransactionResponse(safeTxHash, safeTx) {
        const connectedSafe = await this.safe;
        const connectedService = this.service;
        return {
          to: safeTx.to,
          value: bignumber_1.BigNumber.from(safeTx.value),
          data: safeTx.data,
          operation: safeTx.operation,
          gasLimit: bignumber_1.BigNumber.from(safeTx.safeTxGas),
          gasPrice: bignumber_1.BigNumber.from(0),
          nonce: safeTx.nonce,
          chainId: await connectedSafe.getChainId(),
          hash: safeTxHash,
          from: this.address,
          confirmations: 0,
          wait: async (confirmations) => {
            var _a, _b;
            while (true) {
              try {
                const txDetails = await connectedService.getSafeTxDetails(safeTxHash);
                if (txDetails.transactionHash) {
                  this._checkProvider("sendTransaction");
                  const receipt = await this.provider.waitForTransaction(txDetails.transactionHash, confirmations);
                  return (0, utils_1.mapReceipt)(receipt, safeTx);
                }
              } catch (e) {
              }
              await sleep((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.pollingDelay) !== null && _b !== void 0 ? _b : 5e3);
            }
          }
        };
      }
      /**
       * Populates all fields in a transaction, signs it and sends it to the Safe transaction service
       *
       * @param transaction - The transaction what should be send
       * @returns A promise that resolves to a SafeTransactionReponse, that contains all the information of the transaction.
       */
      async sendTransaction(transaction) {
        var _a, _b, _c;
        const tx = await transaction;
        let operation = safe_core_sdk_types_1.OperationType.Call;
        let to = await tx.to;
        let data = (_b = (_a = await tx.data) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "0x";
        let value = bignumber_1.BigNumber.from((_c = await tx.value) !== null && _c !== void 0 ? _c : 0);
        if (!to) {
          to = utils_1.createLibAddress;
          data = utils_1.createLibInterface.encodeFunctionData("performCreate", [value, data]);
          value = bignumber_1.BigNumber.from(0);
          operation = safe_core_sdk_types_1.OperationType.DelegateCall;
        }
        const baseTx = {
          to,
          data,
          value: value.toString(),
          operation
        };
        const safeTxGas = await this.service.estimateSafeTx(this.address, baseTx);
        const connectedSafe = await this.safe;
        const safeTransactionData = {
          ...baseTx,
          safeTxGas: safeTxGas.toNumber()
        };
        const safeTx = await connectedSafe.createTransaction({ safeTransactionData });
        const safeTxHash = await connectedSafe.getTransactionHash(safeTx);
        const signature = await connectedSafe.signTransactionHash(safeTxHash);
        await this.service.proposeTx(this.address, safeTxHash, safeTx, signature);
        return this.buildTransactionResponse(safeTxHash, safeTx.data);
      }
    };
    exports.SafeEthersSigner = SafeEthersSigner2;
  }
});

// node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@safe-global/safe-ethers-adapters/dist/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_service(), exports);
    __exportStar(require_signer(), exports);
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/contracts/config.js
var require_config = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/contracts/config.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeDeploymentsL1ChainIds = exports.safeDeploymentsVersions = exports.SAFE_BASE_VERSION = exports.SAFE_LAST_VERSION = void 0;
    exports.SAFE_LAST_VERSION = "1.3.0";
    exports.SAFE_BASE_VERSION = "1.0.0";
    exports.safeDeploymentsVersions = {
      "1.3.0": {
        safeMasterCopyVersion: "1.3.0",
        safeMasterCopyL2Version: "1.3.0",
        safeProxyFactoryVersion: "1.3.0",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.3.0",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.2.0": {
        safeMasterCopyVersion: "1.2.0",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.1.1",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.1.1": {
        safeMasterCopyVersion: "1.1.1",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.1.1",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      },
      "1.0.0": {
        safeMasterCopyVersion: "1.0.0",
        safeMasterCopyL2Version: void 0,
        safeProxyFactoryVersion: "1.0.0",
        compatibilityFallbackHandler: "1.3.0",
        multiSendVersion: "1.1.1",
        multiSendCallOnlyVersion: "1.3.0",
        signMessageLibVersion: "1.3.0",
        createCallVersion: "1.3.0"
      }
    };
    exports.safeDeploymentsL1ChainIds = [
      1
      // Ethereum Mainnet
    ];
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/contracts/safeDeploymentContracts.js
var require_safeDeploymentContracts = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/contracts/safeDeploymentContracts.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreateCallContract = exports.getSignMessageLibContract = exports.getMultiSendCallOnlyContract = exports.getMultiSendContract = exports.getCompatibilityFallbackHandlerContract = exports.getProxyFactoryContract = exports.getSafeContract = exports.getCreateCallContractDeployment = exports.getSignMessageLibContractDeployment = exports.getSafeProxyFactoryContractDeployment = exports.getMultiSendContractDeployment = exports.getMultiSendCallOnlyContractDeployment = exports.getCompatibilityFallbackHandlerContractDeployment = exports.getSafeContractDeployment = void 0;
    var safe_deployments_1 = require_dist5();
    var config_1 = require_config();
    function getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy = false) {
      const version = config_1.safeDeploymentsVersions[safeVersion].safeMasterCopyVersion;
      const filters = { version, network: chainId.toString(), released: true };
      if (config_1.safeDeploymentsL1ChainIds.includes(chainId) || isL1SafeMasterCopy) {
        return (0, safe_deployments_1.getSafeSingletonDeployment)(filters);
      }
      return (0, safe_deployments_1.getSafeL2SingletonDeployment)(filters);
    }
    exports.getSafeContractDeployment = getSafeContractDeployment;
    function getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].compatibilityFallbackHandler;
      return (0, safe_deployments_1.getCompatibilityFallbackHandlerDeployment)({
        version,
        network: chainId.toString(),
        released: true
      });
    }
    exports.getCompatibilityFallbackHandlerContractDeployment = getCompatibilityFallbackHandlerContractDeployment;
    function getMultiSendCallOnlyContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].multiSendCallOnlyVersion;
      return (0, safe_deployments_1.getMultiSendCallOnlyDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getMultiSendCallOnlyContractDeployment = getMultiSendCallOnlyContractDeployment;
    function getMultiSendContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].multiSendVersion;
      return (0, safe_deployments_1.getMultiSendDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getMultiSendContractDeployment = getMultiSendContractDeployment;
    function getSafeProxyFactoryContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].safeProxyFactoryVersion;
      return (0, safe_deployments_1.getProxyFactoryDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getSafeProxyFactoryContractDeployment = getSafeProxyFactoryContractDeployment;
    function getSignMessageLibContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].signMessageLibVersion;
      return (0, safe_deployments_1.getSignMessageLibDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getSignMessageLibContractDeployment = getSignMessageLibContractDeployment;
    function getCreateCallContractDeployment(safeVersion, chainId) {
      const version = config_1.safeDeploymentsVersions[safeVersion].createCallVersion;
      return (0, safe_deployments_1.getCreateCallDeployment)({ version, network: chainId.toString(), released: true });
    }
    exports.getCreateCallContractDeployment = getCreateCallContractDeployment;
    async function getSafeContract({ ethAdapter, safeVersion, chainId, customSafeAddress, isL1SafeMasterCopy, customContracts }) {
      const singletonDeployment = getSafeContractDeployment(safeVersion, chainId, isL1SafeMasterCopy);
      const gnosisSafeContract = ethAdapter.getSafeContract({
        safeVersion,
        chainId,
        singletonDeployment,
        customContractAddress: customSafeAddress !== null && customSafeAddress !== void 0 ? customSafeAddress : customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeMasterCopyAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeMasterCopyAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(gnosisSafeContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SafeProxy contract is not deployed on the current network");
      }
      return gnosisSafeContract;
    }
    exports.getSafeContract = getSafeContract;
    async function getProxyFactoryContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const proxyFactoryDeployment = getSafeProxyFactoryContractDeployment(safeVersion, chainId);
      const safeProxyFactoryContract = await ethAdapter.getSafeProxyFactoryContract({
        safeVersion,
        chainId,
        singletonDeployment: proxyFactoryDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeProxyFactoryAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.safeProxyFactoryAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(safeProxyFactoryContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SafeProxyFactory contract is not deployed on the current network");
      }
      return safeProxyFactoryContract;
    }
    exports.getProxyFactoryContract = getProxyFactoryContract;
    async function getCompatibilityFallbackHandlerContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const fallbackHandlerDeployment = getCompatibilityFallbackHandlerContractDeployment(safeVersion, chainId);
      const fallbackHandlerContract = await ethAdapter.getCompatibilityFallbackHandlerContract({
        safeVersion,
        chainId,
        singletonDeployment: fallbackHandlerDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.fallbackHandlerAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.fallbackHandlerAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(fallbackHandlerContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("CompatibilityFallbackHandler contract is not deployed on the current network");
      }
      return fallbackHandlerContract;
    }
    exports.getCompatibilityFallbackHandlerContract = getCompatibilityFallbackHandlerContract;
    async function getMultiSendContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const multiSendDeployment = getMultiSendContractDeployment(safeVersion, chainId);
      const multiSendContract = await ethAdapter.getMultiSendContract({
        safeVersion,
        chainId,
        singletonDeployment: multiSendDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(multiSendContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("MultiSend contract is not deployed on the current network");
      }
      return multiSendContract;
    }
    exports.getMultiSendContract = getMultiSendContract;
    async function getMultiSendCallOnlyContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const multiSendCallOnlyDeployment = getMultiSendCallOnlyContractDeployment(safeVersion, chainId);
      const multiSendCallOnlyContract = await ethAdapter.getMultiSendCallOnlyContract({
        safeVersion,
        chainId,
        singletonDeployment: multiSendCallOnlyDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendCallOnlyAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.multiSendCallOnlyAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(multiSendCallOnlyContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("MultiSendCallOnly contract is not deployed on the current network");
      }
      return multiSendCallOnlyContract;
    }
    exports.getMultiSendCallOnlyContract = getMultiSendCallOnlyContract;
    async function getSignMessageLibContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const signMessageLibDeployment = getSignMessageLibContractDeployment(safeVersion, chainId);
      const signMessageLibContract = await ethAdapter.getSignMessageLibContract({
        safeVersion,
        chainId,
        singletonDeployment: signMessageLibDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.signMessageLibAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.signMessageLibAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(signMessageLibContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("SignMessageLib contract is not deployed on the current network");
      }
      return signMessageLibContract;
    }
    exports.getSignMessageLibContract = getSignMessageLibContract;
    async function getCreateCallContract({ ethAdapter, safeVersion, chainId, customContracts }) {
      const createCallDeployment = getCreateCallContractDeployment(safeVersion, chainId);
      const createCallContract = await ethAdapter.getCreateCallContract({
        safeVersion,
        chainId,
        singletonDeployment: createCallDeployment,
        customContractAddress: customContracts === null || customContracts === void 0 ? void 0 : customContracts.createCallAddress,
        customContractAbi: customContracts === null || customContracts === void 0 ? void 0 : customContracts.createCallAbi
      });
      const isContractDeployed = await ethAdapter.isContractDeployed(createCallContract.getAddress());
      if (!isContractDeployed) {
        throw new Error("CreateCall contract is not deployed on the current network");
      }
      return createCallContract;
    }
    exports.getCreateCallContract = getCreateCallContract;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/managers/contractManager.js
var require_contractManager = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/managers/contractManager.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ContractManager_contractNetworks;
    var _ContractManager_isL1SafeMasterCopy;
    var _ContractManager_safeContract;
    var _ContractManager_multiSendContract;
    var _ContractManager_multiSendCallOnlyContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var config_1 = require_config();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var ContractManager = class _ContractManager {
      constructor() {
        _ContractManager_contractNetworks.set(this, void 0);
        _ContractManager_isL1SafeMasterCopy.set(this, void 0);
        _ContractManager_safeContract.set(this, void 0);
        _ContractManager_multiSendContract.set(this, void 0);
        _ContractManager_multiSendCallOnlyContract.set(this, void 0);
      }
      static async create({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {
        const contractManager = new _ContractManager();
        await contractManager.init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks });
        return contractManager;
      }
      async init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {
        const chainId = await ethAdapter.getChainId();
        const customContracts = contractNetworks === null || contractNetworks === void 0 ? void 0 : contractNetworks[chainId];
        __classPrivateFieldSet(this, _ContractManager_contractNetworks, contractNetworks, "f");
        __classPrivateFieldSet(this, _ContractManager_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        const temporarySafeContract = await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter,
          safeVersion: config_1.SAFE_LAST_VERSION,
          chainId,
          isL1SafeMasterCopy,
          customSafeAddress: safeAddress,
          customContracts
        });
        const safeVersion = await temporarySafeContract.getVersion();
        __classPrivateFieldSet(this, _ContractManager_safeContract, await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter,
          safeVersion,
          chainId,
          isL1SafeMasterCopy,
          customSafeAddress: safeAddress,
          customContracts
        }), "f");
        __classPrivateFieldSet(this, _ContractManager_multiSendContract, await (0, safeDeploymentContracts_1.getMultiSendContract)({
          ethAdapter,
          safeVersion,
          chainId,
          customContracts
        }), "f");
        __classPrivateFieldSet(this, _ContractManager_multiSendCallOnlyContract, await (0, safeDeploymentContracts_1.getMultiSendCallOnlyContract)({
          ethAdapter,
          safeVersion,
          chainId,
          customContracts
        }), "f");
      }
      get contractNetworks() {
        return __classPrivateFieldGet(this, _ContractManager_contractNetworks, "f");
      }
      get isL1SafeMasterCopy() {
        return __classPrivateFieldGet(this, _ContractManager_isL1SafeMasterCopy, "f");
      }
      get safeContract() {
        return __classPrivateFieldGet(this, _ContractManager_safeContract, "f");
      }
      get multiSendContract() {
        return __classPrivateFieldGet(this, _ContractManager_multiSendContract, "f");
      }
      get multiSendCallOnlyContract() {
        return __classPrivateFieldGet(this, _ContractManager_multiSendCallOnlyContract, "f");
      }
    };
    _ContractManager_contractNetworks = /* @__PURE__ */ new WeakMap(), _ContractManager_isL1SafeMasterCopy = /* @__PURE__ */ new WeakMap(), _ContractManager_safeContract = /* @__PURE__ */ new WeakMap(), _ContractManager_multiSendContract = /* @__PURE__ */ new WeakMap(), _ContractManager_multiSendCallOnlyContract = /* @__PURE__ */ new WeakMap();
    exports.default = ContractManager;
  }
});

// node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src3 = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src4 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var isHexPrefixed = require_src3();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/number-to-bn/src/index.js
var require_src5 = __commonJS({
  "node_modules/number-to-bn/src/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BN = require_bn3();
    var stripHexPrefix = require_src4();
    module.exports = function numberToBN(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1);
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString);
        if (stringArg.substr(0, 1) === "-") {
          stringArg = stripHexPrefix(stringArg.slice(1));
          multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
          return new BN(stringArg, 16).mul(multiplier);
        }
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
          return new BN(stringArg, 10).mul(multiplier);
        }
      } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
          return new BN(arg.toString(10), 10);
        }
      }
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
    };
  }
});

// node_modules/ethjs-unit/lib/index.js
var require_lib = __commonJS({
  "node_modules/ethjs-unit/lib/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BN = require_bn2();
    var numberToBN = require_src5();
    var zero = new BN(0);
    var negative1 = new BN(-1);
    var unitMap = {
      "noether": "0",
      // eslint-disable-line
      "wei": "1",
      // eslint-disable-line
      "kwei": "1000",
      // eslint-disable-line
      "Kwei": "1000",
      // eslint-disable-line
      "babbage": "1000",
      // eslint-disable-line
      "femtoether": "1000",
      // eslint-disable-line
      "mwei": "1000000",
      // eslint-disable-line
      "Mwei": "1000000",
      // eslint-disable-line
      "lovelace": "1000000",
      // eslint-disable-line
      "picoether": "1000000",
      // eslint-disable-line
      "gwei": "1000000000",
      // eslint-disable-line
      "Gwei": "1000000000",
      // eslint-disable-line
      "shannon": "1000000000",
      // eslint-disable-line
      "nanoether": "1000000000",
      // eslint-disable-line
      "nano": "1000000000",
      // eslint-disable-line
      "szabo": "1000000000000",
      // eslint-disable-line
      "microether": "1000000000000",
      // eslint-disable-line
      "micro": "1000000000000",
      // eslint-disable-line
      "finney": "1000000000000000",
      // eslint-disable-line
      "milliether": "1000000000000000",
      // eslint-disable-line
      "milli": "1000000000000000",
      // eslint-disable-line
      "ether": "1000000000000000000",
      // eslint-disable-line
      "kether": "1000000000000000000000",
      // eslint-disable-line
      "grand": "1000000000000000000000",
      // eslint-disable-line
      "mether": "1000000000000000000000000",
      // eslint-disable-line
      "gether": "1000000000000000000000000000",
      // eslint-disable-line
      "tether": "1000000000000000000000000000000"
    };
    function getValueOfUnit(unitInput) {
      var unit = unitInput ? unitInput.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (typeof unitValue !== "string") {
        throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
      }
      return new BN(unitValue, 10);
    }
    function numberToString(arg) {
      if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) {
          throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        }
        return arg;
      } else if (typeof arg === "number") {
        return String(arg);
      } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) {
          return String(arg.toPrecision());
        } else {
          return arg.toString(10);
        }
      }
      throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
    }
    function fromWei(weiInput, unit, optionsInput) {
      var wei = numberToBN(weiInput);
      var negative = wei.lt(zero);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var options = optionsInput || {};
      if (negative) {
        wei = wei.mul(negative1);
      }
      var fraction = wei.mod(base).toString(10);
      while (fraction.length < baseLength) {
        fraction = "0" + fraction;
      }
      if (!options.pad) {
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      }
      var whole = wei.div(base).toString(10);
      if (options.commify) {
        whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    function toWei(etherInput, unit) {
      var ether = numberToString(etherInput);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var negative = ether.substring(0, 1) === "-";
      if (negative) {
        ether = ether.substring(1);
      }
      if (ether === ".") {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
      }
      var comps = ether.split(".");
      if (comps.length > 2) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      if (fraction.length > baseLength) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
      }
      while (fraction.length < baseLength) {
        fraction += "0";
      }
      whole = new BN(whole);
      fraction = new BN(fraction);
      var wei = whole.mul(base).add(fraction);
      if (negative) {
        wei = wei.mul(negative1);
      }
      return new BN(wei.toString(10), 10);
    }
    module.exports = {
      unitMap,
      numberToString,
      getValueOfUnit,
      fromWei,
      toWei
    };
  }
});

// node_modules/utf8/utf8.js
var require_utf8 = __commonJS({
  "node_modules/utf8/utf8.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root) {
      var stringFromCharCode = String.fromCharCode;
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = "";
        while (++index < length) {
          value = array[index];
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343) {
          throw Error(
            "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
          );
        }
      }
      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 63 | 128);
      }
      function encodeCodePoint(codePoint) {
        if ((codePoint & 4294967168) == 0) {
          return stringFromCharCode(codePoint);
        }
        var symbol = "";
        if ((codePoint & 4294965248) == 0) {
          symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
        } else if ((codePoint & 4294901760) == 0) {
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 4292870144) == 0) {
          symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 63 | 128);
        return symbol;
      }
      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = "";
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }
      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error("Invalid byte index");
        }
        var continuationByte = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((continuationByte & 192) == 128) {
          return continuationByte & 63;
        }
        throw Error("Invalid continuation byte");
      }
      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error("Invalid byte index");
        }
        if (byteIndex == byteCount) {
          return false;
        }
        byte1 = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((byte1 & 128) == 0) {
          return byte1;
        }
        if ((byte1 & 224) == 192) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 31) << 6 | byte2;
          if (codePoint >= 128) {
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 240) == 224) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 2048) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 248) == 240) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (codePoint >= 65536 && codePoint <= 1114111) {
            return codePoint;
          }
        }
        throw Error("Invalid UTF-8 detected");
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      root.version = "3.0.0";
      root.encode = utf8encode;
      root.decode = utf8decode;
    })(typeof exports === "undefined" ? exports.utf8 = {} : exports);
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/utils.js
var require_utils5 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert2();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils5();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils5();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils5();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/utils.js
var require_utils6 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitMask = void 0;
    exports.isBytes = isBytes;
    exports.abytes = abytes;
    exports.bytesToHex = bytesToHex;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.hexToBytes = hexToBytes;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.concatBytes = concatBytes;
    exports.equalBytes = equalBytes;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils6();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = wNAF;
    exports.validateBasic = validateBasic;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils6();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = void 0;
    exports.weierstrassPoints = weierstrassPoints;
    exports.weierstrass = weierstrass;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve();
    var mod = require_modular();
    var ut = require_utils6();
    var utils_js_1 = require_utils6();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils5();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils6();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils5();
    var _shortw_utils_js_1 = require_shortw_utils();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils6();
    var weierstrass_js_1 = require_weierstrass();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.secp256k1;
    } });
  }
});

// node_modules/@ethereumjs/util/dist/constants.js
var require_constants2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    var secp256k1_1 = require_secp256k12();
    exports.MAX_UINT64 = BigInt("0xffffffffffffffff");
    exports.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
    exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
    exports.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
    exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([128]);
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  }
});

// node_modules/@ethereumjs/util/dist/units.js
var require_units = __commonJS({
  "node_modules/@ethereumjs/util/dist/units.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GWEI_TO_WEI = void 0;
    exports.GWEI_TO_WEI = BigInt(1e9);
  }
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@ethereumjs/rlp/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RLP = exports.utils = exports.decode = exports.encode = void 0;
    function encode(input) {
      if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i = 0; i < input.length; i++) {
          const encoded = encode(input[i]);
          output.push(encoded);
          outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
    }
    exports.encode = encode;
    function safeSlice(input, start, end) {
      if (end > input.length) {
        throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
      }
      return input.slice(start, end);
    }
    function decodeLength(v) {
      if (v[0] === 0) {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseHexByte(bytesToHex(v));
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
    }
    function decode(input, stream = false) {
      if (typeof input === "undefined" || input === null || input.length === 0) {
        return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid RLP: remainder must be zero");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function _decode(input) {
      let length, llength, data, innerRemainder, d;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Uint8Array.from([]);
        } else {
          data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = safeSlice(input, llength, length + llength);
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
          throw new Error("invalid RLP: encoded list too short");
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid RLP: total length is larger than the data");
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
      }
      return hex;
    }
    function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
        throw new Error("Invalid byte sequence");
      return byte;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
      }
      return array;
    }
    function concatBytes(...arrays) {
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
    }
    function numberToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      const hex = integer.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? `0${a}` : a;
    }
    function isHexPrefixed(str) {
      return str.length >= 2 && str[0] === "0" && str[1] === "x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function toBytes(v) {
      if (v instanceof Uint8Array) {
        return v;
      }
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
      }
      if (typeof v === "number" || typeof v === "bigint") {
        if (!v) {
          return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
      }
      if (v === null || v === void 0) {
        return Uint8Array.from([]);
      }
      throw new Error("toBytes: received unsupported type " + typeof v);
    }
    exports.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes
    };
    exports.RLP = { encode, decode };
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils5();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js
var require_utils7 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.hexToBytes = hexToBytes;
    exports.equalsBytes = equalsBytes;
    exports.wrapHash = wrapHash;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils5();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils5();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha3();
    var utils_js_1 = require_utils7();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/@ethereumjs/util/dist/internal.js
var require_internal = __commonJS({
  "node_modules/@ethereumjs/util/dist/internal.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = (str) => {
      if (typeof str !== "string")
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      let a = value;
      if (typeof a !== "string") {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
      }
      if (a.length % 2)
        a = `0${a}`;
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? "some" : "every"]((value) => superset.indexOf(value) >= 0);
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      let str = "";
      let i = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      const str = Buffer.from(stringValue, "utf8");
      return `0x${padToEven(str.toString("hex")).replace(/^0+|0+$/g, "")}`;
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      let hex = "";
      for (let i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
      }
      return `0x${hex}`;
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== "string") {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i = 0; i < params.length; i++) {
        let value = params[i][key];
        if (allowEmpty === true && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/@ethereumjs/util/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/@ethereumjs/util/dist/helpers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/@ethereumjs/util/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/@ethereumjs/util/dist/bytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error(`Received an invalid integer type: ${i}`);
      }
      return `0x${i.toString(16)}`;
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i) {
      const hex = (0, exports.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length, right) {
      const buf = (0, exports.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      let first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return "0x" + stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (typeof v === "bigint") {
        if (v < BigInt(0)) {
          throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
        }
        let n = v.toString(16);
        if (n.length % 2)
          n = "0" + n;
        return Buffer.from(n, "hex");
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    function bufferToBigInt(buf) {
      const hex = (0, exports.bufferToHex)(buf);
      if (hex === "0x") {
        return BigInt(0);
      }
      return BigInt(hex);
    }
    exports.bufferToBigInt = bufferToBigInt;
    function bigIntToBuffer(num) {
      return (0, exports.toBuffer)("0x" + num.toString(16));
    }
    exports.bigIntToBuffer = bigIntToBuffer;
    var bufferToInt = function(buf) {
      const res = Number(bufferToBigInt(buf));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports.bufferToInt = bufferToInt;
    var fromSigned = function(num) {
      return BigInt.asIntN(256, bufferToBigInt(num));
    };
    exports.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return bigIntToBuffer(BigInt.asUintN(256, num));
    };
    exports.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix;
    function short(buffer, maxLength = 50) {
      const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString("hex") : buffer;
      if (bufferStr.length <= maxLength) {
        return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + "…";
    }
    exports.short = short;
    var toUtf8 = function(hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      const bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return `0x${ba.toString("hex")}`;
      } else if (ba instanceof Array) {
        const array = [];
        for (let i = 0; i < ba.length; i++) {
          array.push((0, exports.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      for (const [k, v] of Object.entries(values)) {
        if (v !== void 0 && v.length > 0 && v[0] === 0) {
          throw new Error(`${k} cannot have leading zeroes, received: ${v.toString("hex")}`);
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map((a) => arrToBufArr(a));
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr ?? []);
      }
      return arr.map((a) => bufArrToArr(a));
    }
    exports.bufArrToArr = bufArrToArr;
    var bigIntToHex = (num) => {
      return "0x" + num.toString(16);
    };
    exports.bigIntToHex = bigIntToHex;
    function bigIntToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)(bigIntToBuffer(value));
    }
    exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
    function intToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));
    }
    exports.intToUnpaddedBuffer = intToUnpaddedBuffer;
  }
});

// node_modules/@ethereumjs/util/dist/account.js
var require_account = __commonJS({
  "node_modules/@ethereumjs/util/dist/account.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var rlp_1 = require_dist6();
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var utils_1 = require_utils7();
    var bytes_1 = require_bytes();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var _0n = BigInt(0);
    var Account = class _Account {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
        this.nonce = nonce;
        this.balance = balance;
        this.storageRoot = storageRoot;
        this.codeHash = codeHash;
        this._validate();
      }
      static fromAccountData(accountData) {
        const { nonce, balance, storageRoot, codeHash } = accountData;
        return new _Account(nonce !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : void 0, balance !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_1.toBuffer)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_1.toBuffer)(codeHash) : void 0);
      }
      static fromRlpSerializedAccount(serialized) {
        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized account input. Must be array");
        }
        return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
        const [nonce, balance, storageRoot, codeHash] = values;
        return new _Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
      }
      _validate() {
        if (this.nonce < _0n) {
          throw new Error("nonce must be greater than zero");
        }
        if (this.balance < _0n) {
          throw new Error("balance must be greater than zero");
        }
        if (this.storageRoot.length !== 32) {
          throw new Error("storageRoot must have a length of 32");
        }
        if (this.codeHash.length !== 32) {
          throw new Error("codeHash must have a length of 32");
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
        return [
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
          this.storageRoot,
          this.codeHash
        ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    };
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = "";
      if (eip1191ChainId !== void 0) {
        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
        prefix = chainId.toString() + "0x";
      }
      const buf = Buffer.from(prefix + address, "utf8");
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = "0x";
      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
        throw new Error("Expected from to be of length 20");
      }
      if (salt.length !== 32) {
        throw new Error("Expected salt to be of length 32");
      }
      const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        try {
          secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
          return true;
        } catch (e) {
          return false;
        }
      }
      if (!sanitize) {
        return false;
      }
      try {
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
        return true;
      } catch (e) {
        return false;
      }
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
        throw new Error("Expected pubKey to be of length 64");
      }
      return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      const zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
    function accountBodyFromSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash
      ];
    }
    exports.accountBodyFromSlim = accountBodyFromSlim;
    var emptyUint8Arr = new Uint8Array(0);
    function accountBodyToSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash
      ];
    }
    exports.accountBodyToSlim = accountBodyToSlim;
    function accountBodyToRLP(body, couldBeSlim = true) {
      const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
      return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
    }
    exports.accountBodyToRLP = accountBodyToRLP;
  }
});

// node_modules/@ethereumjs/util/dist/address.js
var require_address = __commonJS({
  "node_modules/@ethereumjs/util/dist/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var account_1 = require_account();
    var bytes_1 = require_bytes();
    var Address = class _Address {
      constructor(buf) {
        if (buf.length !== 20) {
          throw new Error("Invalid address length");
        }
        this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
        return new _Address((0, bytes_1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
          throw new Error("Invalid address");
        }
        return new _Address((0, bytes_1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
          throw new Error("Public key should be Buffer");
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new _Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
          throw new Error("Private key should be Buffer");
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new _Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
        if (typeof nonce !== "bigint") {
          throw new Error("Expected nonce to be a bigint");
        }
        return new _Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
          throw new Error("Expected salt to be a Buffer");
        }
        if (!Buffer.isBuffer(initCode)) {
          throw new Error("Expected initCode to be a Buffer");
        }
        return new _Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
        return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
        return this.equals(_Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
        const address = (0, bytes_1.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt("0xffff");
        return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
        return "0x" + this.buf.toString("hex");
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
        return Buffer.from(this.buf);
      }
    };
    exports.Address = Address;
  }
});

// node_modules/@ethereumjs/util/dist/types.js
var require_types3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = void 0;
    var bytes_1 = require_bytes();
    var internal_1 = require_internal();
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
        case TypeOutput.Buffer:
          return output;
        case TypeOutput.BigInt:
          return (0, bytes_1.bufferToBigInt)(output);
        case TypeOutput.Number: {
          const bigInt = (0, bytes_1.bufferToBigInt)(output);
          if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          }
          return Number(bigInt);
        }
        case TypeOutput.PrefixedHexString:
          return (0, bytes_1.bufferToHex)(output);
        default:
          throw new Error("unknown outputType");
      }
    }
    exports.toType = toType;
  }
});

// node_modules/@ethereumjs/util/dist/withdrawal.js
var require_withdrawal = __commonJS({
  "node_modules/@ethereumjs/util/dist/withdrawal.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Withdrawal = void 0;
    var address_1 = require_address();
    var bytes_1 = require_bytes();
    var types_1 = require_types3();
    var Withdrawal = class _Withdrawal {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
       * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
       */
      constructor(index, validatorIndex, address, amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
      }
      static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);
        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));
        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);
        return new _Withdrawal(index, validatorIndex, address, amount);
      }
      static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
          throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return _Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
      }
      /**
       * Convert a withdrawal to a buffer array
       * @param withdrawal the withdrawal to convert
       * @returns buffer array of the withdrawal
       */
      static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1.Address) {
          addressBuffer = address.buf;
        } else {
          addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
      }
      raw() {
        return _Withdrawal.toBufferArray(this);
      }
      toValue() {
        return {
          index: this.index,
          validatorIndex: this.validatorIndex,
          address: this.address.buf,
          amount: this.amount
        };
      }
      toJSON() {
        return {
          index: (0, bytes_1.bigIntToHex)(this.index),
          validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),
          address: "0x" + this.address.buf.toString("hex"),
          amount: (0, bytes_1.bigIntToHex)(this.amount)
        };
      }
    };
    exports.Withdrawal = Withdrawal;
  }
});

// node_modules/@ethereumjs/util/dist/signature.js
var require_signature = __commonJS({
  "node_modules/@ethereumjs/util/dist/signature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var bytes_1 = require_bytes();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers();
    function ecsign(msgHash, privateKey, chainId) {
      const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
      const buf = sig.toCompactRawBytes();
      const r = Buffer.from(buf.slice(0, 32));
      const s = Buffer.from(buf.slice(32, 64));
      const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r, s, v };
    }
    exports.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      if (v === BigInt(0) || v === BigInt(1))
        return v;
      if (chainId === void 0) {
        return v - BigInt(27);
      }
      return v - (chainId * BigInt(2) + BigInt(35));
    }
    function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
      const senderPubKey = sig.recoverPublicKey(msgHash);
      return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      let ss = s;
      if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r;
      let s;
      let v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v = v + BigInt(27);
      }
      return {
        v,
        r,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s);
      if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {
        return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      const prefix = Buffer.from(`Ethereum Signed Message:
${message.length}`, "utf-8");
      return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
    };
    exports.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/@ethereumjs/util/dist/encoding.js
var require_encoding = __commonJS({
  "node_modules/@ethereumjs/util/dist/encoding.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;
    var hasTerminator = (nibbles) => {
      return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
    };
    exports.hasTerminator = hasTerminator;
    var nibblesToBytes = (nibbles, bytes) => {
      for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];
      }
    };
    exports.nibblesToBytes = nibblesToBytes;
    var nibblesToCompactBytes = (nibbles) => {
      let terminator = 0;
      if ((0, exports.hasTerminator)(nibbles)) {
        terminator = 1;
        nibbles = nibbles.subarray(0, nibbles.length - 1);
      }
      const buf = new Uint8Array(nibbles.length / 2 + 1);
      buf[0] = terminator << 5;
      if ((nibbles.length & 1) === 1) {
        buf[0] |= 1 << 4;
        buf[0] |= nibbles[0];
        nibbles = nibbles.subarray(1);
      }
      (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));
      return buf;
    };
    exports.nibblesToCompactBytes = nibblesToCompactBytes;
    var bytesToNibbles = (str) => {
      const l = str.length * 2 + 1;
      const nibbles = new Uint8Array(l);
      for (let i = 0; i < str.length; i++) {
        const b = str[i];
        nibbles[i * 2] = b / 16;
        nibbles[i * 2 + 1] = b % 16;
      }
      nibbles[l - 1] = 16;
      return nibbles;
    };
    exports.bytesToNibbles = bytesToNibbles;
    var compactBytesToNibbles = (compact) => {
      if (compact.length === 0) {
        return compact;
      }
      let base = (0, exports.bytesToNibbles)(compact);
      if (base[0] < 2) {
        base = base.subarray(0, base.length - 1);
      }
      const chop = 2 - (base[0] & 1);
      return base.subarray(chop);
    };
    exports.compactBytesToNibbles = compactBytesToNibbles;
  }
});

// node_modules/@ethereumjs/util/dist/asyncEventEmitter.js
var require_asyncEventEmitter = __commonJS({
  "node_modules/@ethereumjs/util/dist/asyncEventEmitter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncEventEmitter = void 0;
    var events_1 = require_events();
    async function runInSeries(context, tasks, data) {
      let error;
      for await (const task of tasks) {
        try {
          if (task.length < 2) {
            task.call(context, data);
          } else {
            await new Promise((resolve2, reject) => {
              task.call(context, data, (error2) => {
                if (error2) {
                  reject(error2);
                } else {
                  resolve2();
                }
              });
            });
          }
        } catch (e) {
          error = e;
        }
      }
      if (error) {
        throw error;
      }
    }
    var AsyncEventEmitter = class extends events_1.EventEmitter {
      emit(event, ...args) {
        let [data, callback] = args;
        const self2 = this;
        let listeners = self2._events[event] ?? [];
        if (callback === void 0 && typeof data === "function") {
          callback = data;
          data = void 0;
        }
        if (event === "newListener" || event === "removeListener") {
          data = {
            event: data,
            fn: callback
          };
          callback = void 0;
        }
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
        return self2.listenerCount(event) > 0;
      }
      once(event, listener) {
        const self2 = this;
        let g;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (listener.length >= 2) {
          g = function(e, next) {
            self2.removeListener(event, g);
            void listener(e, next);
          };
        } else {
          g = function(e) {
            self2.removeListener(event, g);
            void listener(e, g);
          };
        }
        self2.on(event, g);
        return self2;
      }
      first(event, listener) {
        let listeners = this._events[event] ?? [];
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
      }
      before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
      }
      after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, "after");
      }
      beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i;
        let index;
        const add = beforeOrAfter === "after" ? 1 : 0;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (typeof target !== "function") {
          throw new TypeError("target must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i = listeners.length; i--; ) {
          if (listeners[i] === target) {
            index = i + add;
            break;
          }
        }
        listeners.splice(index, 0, listener);
        return this;
      }
      on(event, listener) {
        return super.on(event, listener);
      }
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      eventNames() {
        return super.eventNames();
      }
      listeners(event) {
        return super.listeners(event);
      }
      listenerCount(event) {
        return super.listenerCount(event);
      }
      getMaxListeners() {
        return super.getMaxListeners();
      }
      setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
      }
    };
    exports.AsyncEventEmitter = AsyncEventEmitter;
  }
});

// node_modules/@ethereumjs/util/dist/lock.js
var require_lock = __commonJS({
  "node_modules/@ethereumjs/util/dist/lock.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lock = void 0;
    var Lock = class {
      constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
      }
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      async acquire() {
        if (this.permits > 0) {
          this.permits -= 1;
          return Promise.resolve(true);
        }
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
      }
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          console.warn("Lock.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          const nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      }
    };
    exports.Lock = Lock;
  }
});

// node_modules/stream-http/lib/capability.js
var require_capability = __commonJS({
  "node_modules/stream-http/lib/capability.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
    exports.writableStream = isFunction(global.WritableStream);
    exports.abortController = isFunction(global.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0) return xhr;
      if (global.XMLHttpRequest) {
        xhr = new global.XMLHttpRequest();
        try {
          xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    function checkTypeSupport(type) {
      var xhr2 = getXHR();
      if (!xhr2) return false;
      try {
        xhr2.responseType = type;
        return xhr2.responseType === type;
      } catch (e) {
      }
      return false;
    }
    exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");
    exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
    exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
    function isFunction(value) {
      return typeof value === "function";
    }
    xhr = null;
  }
});

// node_modules/stream-http/lib/response.js
var require_response = __commonJS({
  "node_modules/stream-http/lib/response.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var stream = require_readable_browser();
    var rStates = exports.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read2 = function() {
          reader.read().then(function(result) {
            if (self2._destroyed)
              return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer.from(result.value));
            read2();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
        };
        var read = read2;
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve2, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer.from(chunk))) {
                  resolve2();
                } else {
                  self2._resumeFetch = resolve2;
                }
              });
            },
            close: function() {
              resetTimers(true);
              if (!self2._destroyed)
                self2.push(null);
            },
            abort: function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            }
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            });
            return;
          } catch (e) {
          }
        }
        var reader = response.body.getReader();
        read2();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset)
            self2._charset = "utf-8";
        }
      }
    };
    inherits(IncomingMessage, stream.Readable);
    IncomingMessage.prototype._read = function() {
      var self2 = this;
      var resolve2 = self2._resumeFetch;
      if (resolve2) {
        self2._resumeFetch = null;
        resolve2();
      }
    };
    IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = Buffer.alloc(newData.length);
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response)
            break;
          response = xhr.response;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response)
            break;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING)
            break;
          var reader = new global.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
  }
});

// node_modules/stream-http/lib/request.js
var require_request = __commonJS({
  "node_modules/stream-http/lib/request.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var response = require_response();
    var stream = require_readable_browser();
    var IncomingMessage = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    var ClientRequest = module.exports = function(opts) {
      var self2 = this;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth)
        self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name) {
        self2.setHeader(name, opts.headers[name]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits(ClientRequest, stream.Writable);
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var header = this._headers[name.toLowerCase()];
      if (header)
        return header.value;
      return null;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v) {
            headersList.push([name, v]);
          });
        } else {
          headersList.push([name, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = global.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        global.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new global.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr)
          xhr.responseType = self2._mode;
        if ("withCredentials" in xhr)
          xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed)
            return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e) {
        return false;
      }
    }
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype._resetTimers = function(done) {
      var self2 = this;
      global.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        global.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = global.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
      var self2 = this;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
      else if (self2._fetchAbortController)
        self2._fetchAbortController.abort();
      if (err)
        self2.emit("error", err);
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.setTimeout = function(timeout, cb) {
      var self2 = this;
      if (cb)
        self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
  }
});

// node_modules/builtin-status-codes/browser.js
var require_browser3 = __commonJS({
  "node_modules/builtin-status-codes/browser.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(exports);
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils8 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var getSideChannel = require_side_channel();
    var utils = require_utils8();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format2) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format2))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter2)) {
        objKeys = filter2;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format2,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format2 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format2 = opts.format;
      }
      var formatter = formats.formatters[format2];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter2 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format: format2,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_utils8();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// node_modules/node-stdlib-browser/esm/proxy/url.js
var url_exports = {};
__export(url_exports, {
  URL: () => URL2,
  URLSearchParams: () => URLSearchParams,
  Url: () => UrlImport,
  default: () => api,
  domainToASCII: () => domainToASCII,
  domainToUnicode: () => domainToUnicode,
  fileURLToPath: () => fileURLToPath,
  format: () => formatImportWithOverloads,
  parse: () => parseImport,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolveImport,
  resolveObject: () => resolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === "object" && url instanceof Url) {
    return url;
  }
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source) {
    return relative;
  }
  return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      var third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var import_dist, import_dist2, import_dist3, import_punycode, import_qs, punycode, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, parse, resolve$1, resolveObject, format, Url_1, _globalThis, formatImport, parseImport, resolveImport, UrlImport, URL2, URLSearchParams, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, CHAR_FORWARD_SLASH, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, formatImportWithOverloads, api;
var init_url = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/url.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    import_punycode = __toESM(require_punycode());
    import_qs = __toESM(require_lib2());
    punycode = import_punycode.default;
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    querystring = import_qs.default;
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    parse = urlParse;
    resolve$1 = urlResolve;
    resolveObject = urlResolveObject;
    format = urlFormat;
    Url_1 = Url;
    _globalThis = function(Object2) {
      function get() {
        var _global2 = this || self;
        delete Object2.prototype.__magic__;
        return _global2;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global = __magic__;
        return _global;
      }
    }(Object);
    formatImport = /** @type {formatImport}*/
    format;
    parseImport = /** @type {parseImport}*/
    parse;
    resolveImport = /** @type {resolveImport}*/
    resolve$1;
    UrlImport = /** @type {UrlImport}*/
    Url_1;
    URL2 = _globalThis.URL;
    URLSearchParams = _globalThis.URLSearchParams;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    CHAR_FORWARD_SLASH = 47;
    domainToASCII = /**
     * @type {domainToASCII}
     */
    function domainToASCII2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    domainToUnicode = /**
     * @type {domainToUnicode}
     */
    function domainToUnicode2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    pathToFileURL = /**
     * @type {(url: string) => URL}
     */
    function pathToFileURL2(filepath) {
      var outURL = new URL2("file://");
      var resolved = resolve(filepath);
      var filePathLast = filepath.charCodeAt(filepath.length - 1);
      if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
        resolved += "/";
      }
      outURL.pathname = encodePathChars(resolved);
      return outURL;
    };
    fileURLToPath = /**
     * @type {fileURLToPath & ((path: string | URL) => string)}
     */
    function fileURLToPath2(path) {
      if (!isURLInstance(path) && typeof path !== "string") {
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + " (" + path + ")");
      }
      var resolved = new URL2(path);
      if (resolved.protocol !== "file:") {
        throw new TypeError("The URL must be of scheme file");
      }
      return getPathFromURLPosix(resolved);
    };
    formatImportWithOverloads = /**
     * @type {(
     *   ((urlObject: URL, options?: URLFormatOptions) => string) &
     *   ((urlObject: UrlObject | string, options?: never) => string)
     * )}
     */
    function formatImportWithOverloads2(urlObject, options) {
      var _options$auth, _options$fragment, _options$search, _options$unicode;
      if (options === void 0) {
        options = {};
      }
      if (!(urlObject instanceof URL2)) {
        return formatImport(urlObject);
      }
      if (typeof options !== "object" || options === null) {
        throw new TypeError('The "options" argument must be of type object.');
      }
      var auth = (_options$auth = options.auth) != null ? _options$auth : true;
      var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
      var search = (_options$search = options.search) != null ? _options$search : true;
      (_options$unicode = options.unicode) != null ? _options$unicode : false;
      var parsed = new URL2(urlObject.toString());
      if (!auth) {
        parsed.username = "";
        parsed.password = "";
      }
      if (!fragment) {
        parsed.hash = "";
      }
      if (!search) {
        parsed.search = "";
      }
      return parsed.toString();
    };
    api = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL: URL2,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL,
      fileURLToPath
    };
  }
});

// node_modules/stream-http/index.js
var require_stream_http = __commonJS({
  "node_modules/stream-http/index.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ClientRequest = require_request();
    var response = require_response();
    var extend = require_immutable();
    var statusCodes = require_browser3();
    var url = (init_url(), __toCommonJS(url_exports));
    var http = exports;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url.parse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest(opts);
      if (cb)
        req.on("response", cb);
      return req;
    };
    http.get = function get(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }
});

// node_modules/https-browserify/index.js
var require_https_browserify = __commonJS({
  "node_modules/https-browserify/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var http = require_stream_http();
    var url = (init_url(), __toCommonJS(url_exports));
    var https = module.exports;
    for (key in http) {
      if (http.hasOwnProperty(key)) https[key] = http[key];
    }
    var key;
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants3 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/browserify-zlib/lib/binding.js
var require_binding = __commonJS({
  "node_modules/browserify-zlib/lib/binding.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var assert = require_assert();
    var Zstream = require_zstream();
    var zlib_deflate = require_deflate();
    var zlib_inflate = require_inflate();
    var constants = require_constants3();
    for (key in constants) {
      exports[key] = constants[key];
    }
    var key;
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert(this.init_done, "close before init");
      assert(this.mode <= exports.UNZIP);
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert.equal(arguments.length, 8);
      assert(this.init_done, "write before init");
      assert(this.mode !== exports.NONE, "already finalized");
      assert.equal(false, this.write_in_progress, "write already in progress");
      assert.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports.GUNZIP;
              } else {
                this.mode = exports.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports.Z_DATA_ERROR) {
              this.err = exports.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert(level >= -1 && level <= 9, "invalid compression level");
      assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports.Z_NO_FLUSH;
      this.err = exports.Z_OK;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports.Zlib = Zlib;
  }
});

// node_modules/browserify-zlib/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/browserify-zlib/lib/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var Transform = require_stream_browserify().Transform;
    var binding = require_binding();
    var util = require_util();
    var assert = require_assert().ok;
    var kMaxLength = (init_dist(), __toCommonJS(dist_exports)).kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = 16 * 1024;
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding);
    for (bk = 0; bk < bkeys.length; bk++) {
      bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports, bkey, {
          enumerable: true,
          value: binding[bkey],
          writable: false
        });
      }
    }
    var bkey;
    var bk;
    var codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes);
    for (ck = 0; ck < ckeys.length; ck++) {
      ckey = ckeys[ck];
      codes[codes[ckey]] = ckey;
    }
    var ckey;
    var ck;
    Object.defineProperty(exports, "codes", {
      enumerable: true,
      value: Object.freeze(codes),
      writable: false
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") buffer = Buffer2.from(buffer);
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
    }
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno) {
        _close(self2);
        self2._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self2.emit("error", error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: function() {
          return !_this._handle;
        },
        configurable: true,
        enumerable: true
      });
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          assert(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback) process.nextTick(callback);
      } else if (ws.ending) {
        if (callback) this.once("end", callback);
      } else if (ws.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback) process.nextTick(callback);
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
      if (!this._handle) return cb(new Error("zlib binding closed"));
      if (last) flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on("error", function(er) {
          error = er;
        });
        assert(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  }
});

// node_modules/micro-ftch/index.js
var require_micro_ftch = __commonJS({
  "node_modules/micro-ftch/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStatusCodeError = exports.InvalidCertError = void 0;
    var DEFAULT_OPT = Object.freeze({
      redirect: true,
      expectStatusCode: 200,
      headers: {},
      full: false,
      keepAlive: true,
      cors: false,
      referrer: false,
      sslAllowSelfSigned: false,
      _redirectCount: 0
    });
    var InvalidCertError = class extends Error {
      constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
      }
    };
    exports.InvalidCertError = InvalidCertError;
    var InvalidStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    exports.InvalidStatusCodeError = InvalidStatusCodeError;
    function detectType(b, type) {
      if (!type || type === "text" || type === "json") {
        try {
          let text = new TextDecoder("utf8", { fatal: true }).decode(b);
          if (type === "text")
            return text;
          try {
            return JSON.parse(text);
          } catch (err) {
            if (type === "json")
              throw err;
            return text;
          }
        } catch (err) {
          if (type === "text" || type === "json")
            throw err;
        }
      }
      return b;
    }
    var agents = {};
    function fetchNode(url, _options) {
      var _a;
      let options = { ...DEFAULT_OPT, ..._options };
      const http = require_stream_http();
      const https = require_https_browserify();
      const zlib = require_lib3();
      const { promisify } = require_util();
      const { resolve: urlResolve2 } = (init_url(), __toCommonJS(url_exports));
      const isSecure = !!/^https/.test(url);
      let opts = {
        method: options.method || "GET",
        headers: { "Accept-Encoding": "gzip, deflate, br" }
      };
      const compactFP = (s) => s.replace(/:| /g, "").toLowerCase();
      if (options.keepAlive) {
        const agentOpt = {
          keepAlive: true,
          keepAliveMsecs: 30 * 1e3,
          maxFreeSockets: 1024,
          maxCachedSessions: 1024
        };
        const agentKey = [
          isSecure,
          isSecure && ((_a = options.sslPinnedCertificates) == null ? void 0 : _a.map((i) => compactFP(i)).sort())
        ].join();
        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
      }
      if (options.type === "json")
        opts.headers["Content-Type"] = "application/json";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      opts.headers = { ...opts.headers, ...options.headers };
      if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
      const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers["location"]) {
          if (options._redirectCount == 10)
            throw new Error("Request failed. Too much redirects.");
          options._redirectCount += 1;
          return await fetchNode(urlResolve2(url, res.headers["location"]), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
          res.resume();
          throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
          buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers["content-encoding"];
        if (encoding === "br")
          bytes = await promisify(zlib.brotliDecompress)(bytes);
        if (encoding === "gzip" || encoding === "deflate")
          bytes = await promisify(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
          return { headers: res.headers, status, body };
        return body;
      };
      return new Promise((resolve2, reject) => {
        var _a2;
        const handleError = async (err) => {
          if (err && err.code === "DEPTH_ZERO_SELF_SIGNED_CERT") {
            try {
              await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
            } catch (e) {
              if (e && e.fingerprint256) {
                err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);
              }
            }
          }
          reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
          res.on("error", handleError);
          (async () => {
            try {
              resolve2(await handleRes(res));
            } catch (error) {
              reject(error);
            }
          })();
        });
        req.on("error", handleError);
        const pinned = (_a2 = options.sslPinnedCertificates) == null ? void 0 : _a2.map((i) => compactFP(i));
        const mfetchSecureConnect = (socket) => {
          var _a3;
          const fp256 = compactFP(((_a3 = socket.getPeerCertificate()) == null ? void 0 : _a3.fingerprint256) || "");
          if (!fp256 && socket.isSessionReused())
            return;
          if (pinned.includes(fp256))
            return;
          req.emit("error", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
          return req.abort();
        };
        if (options.sslPinnedCertificates) {
          req.on("socket", (socket) => {
            const hasListeners = socket.listeners("secureConnect").map((i) => (i.name || "").replace("bound ", "")).includes("mfetchSecureConnect");
            if (hasListeners)
              return;
            socket.on("secureConnect", mfetchSecureConnect.bind(null, socket));
          });
        }
        if (options.keepAlive)
          req.setNoDelay(true);
        if (opts.body)
          req.write(opts.body);
        req.end();
      });
    }
    var SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((i) => i.toLowerCase()));
    var FORBIDDEN_HEADERS = new Set([
      "Accept-Charset",
      "Accept-Encoding",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Connection",
      "Content-Length",
      "Cookie",
      "Cookie2",
      "Date",
      "DNT",
      "Expect",
      "Host",
      "Keep-Alive",
      "Origin",
      "Referer",
      "TE",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Via"
    ].map((i) => i.toLowerCase()));
    async function fetchBrowser(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const headers = new Headers();
      if (options.type === "json")
        headers.set("Content-Type", "application/json");
      let parsed = new URL(url);
      if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set("Authorization", `Basic ${auth}`);
        parsed.username = "";
        parsed.password = "";
      }
      url = "" + parsed;
      for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name))
          headers.set(k, options.headers[k]);
      }
      let opts = { headers, redirect: options.redirect ? "follow" : "manual" };
      if (!options.referrer)
        opts.referrerPolicy = "no-referrer";
      if (options.cors)
        opts.mode = "cors";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      const res = await fetch(url, opts);
      if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
      const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
      if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
      return body;
    }
    var IS_NODE = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    function fetchUrl(url, options) {
      const fn = IS_NODE ? fetchNode : fetchBrowser;
      return fn(url, options);
    }
    exports.default = fetchUrl;
  }
});

// node_modules/@ethereumjs/util/dist/provider.js
var require_provider = __commonJS({
  "node_modules/@ethereumjs/util/dist/provider.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProvider = exports.fetchFromProvider = void 0;
    var micro_ftch_1 = require_micro_ftch();
    var fetchFromProvider = async (url, params) => {
      const res = await (0, micro_ftch_1.default)(url, {
        headers: {
          "content-type": "application/json"
        },
        type: "json",
        data: {
          method: params.method,
          params: params.params,
          jsonrpc: "2.0",
          id: 1
        }
      });
      return res.result;
    };
    exports.fetchFromProvider = fetchFromProvider;
    var getProvider = (provider) => {
      var _a;
      if (typeof provider === "string") {
        return provider;
      } else if (((_a = provider == null ? void 0 : provider.connection) == null ? void 0 : _a.url) !== void 0) {
        return provider.connection.url;
      } else {
        throw new Error("Must provide valid provider URL or Web3Provider");
      }
    };
    exports.getProvider = getProvider;
  }
});

// node_modules/@ethereumjs/util/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@ethereumjs/util/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
    __exportStar(require_constants2(), exports);
    __exportStar(require_units(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_address(), exports);
    __exportStar(require_withdrawal(), exports);
    __exportStar(require_signature(), exports);
    __exportStar(require_bytes(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_encoding(), exports);
    __exportStar(require_asyncEventEmitter(), exports);
    var internal_1 = require_internal();
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    __exportStar(require_lock(), exports);
    __exportStar(require_provider(), exports);
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert3 = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = isBytes;
    exports.number = number;
    exports.bool = bool;
    exports.bytes = bytes;
    exports.hash = hash;
    exports.exists = exists;
    exports.output = output;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u642 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = void 0;
    exports.fromBig = fromBig;
    exports.split = split;
    exports.add = add;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils9 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    exports.isBytes = isBytes;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.toBytes = toBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.wrapConstructor = wrapConstructor;
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto2();
    var _assert_js_1 = require_assert3();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha32 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
    exports.keccakP = keccakP;
    var _assert_js_1 = require_assert3();
    var _u64_js_1 = require_u642();
    var utils_js_1 = require_utils9();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/ethereum-bloom-filters/dist/utils.js
var require_utils10 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha3_1 = require_sha32();
    var utils_1 = require_utils9();
    function keccak256(data) {
      return bytesToHex(sha3_1.keccak_256(toByteArray(data)));
    }
    exports.keccak256 = keccak256;
    exports.padLeft = (value, chars) => {
      const hasPrefix = /^0x/i.test(value) || typeof value === "number";
      value = value.toString().replace(/^0x/i, "");
      const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join("0") + value;
    };
    function bytesToHex(bytes) {
      return "0x" + utils_1.bytesToHex(bytes);
    }
    exports.bytesToHex = bytesToHex;
    function toByteArray(value) {
      if (value == null) {
        throw new Error("cannot convert null value to array");
      }
      if (typeof value === "string") {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
          throw new Error("invalid hexidecimal string");
        }
        if (match[1] !== "0x") {
          throw new Error("hex string must have 0x prefix");
        }
        value = value.substring(2);
        if (value.length % 2) {
          value = "0" + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
          result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
      }
      throw new Error("invalid arrayify value");
    }
    exports.toByteArray = toByteArray;
    function isByteArray(value) {
      if (!value || // tslint:disable-next-line: radix
      parseInt(String(value.length)) != value.length || typeof value === "string") {
        return false;
      }
      for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
          return false;
        }
      }
      return true;
    }
    function addSlice(array) {
      if (array.slice !== void 0) {
        return array;
      }
      array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
  }
});

// node_modules/ethereum-bloom-filters/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils10();
    function isBloom(bloom) {
      if (typeof bloom !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
      }
      if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
      }
      return false;
    }
    exports.isBloom = isBloom;
    function isInBloom(bloom, value) {
      if (typeof value === "object" && value.constructor === Uint8Array) {
        value = utils_1.bytesToHex(value);
      }
      const hash = utils_1.keccak256(value).replace("0x", "");
      for (let i = 0; i < 12; i += 4) {
        const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
          return false;
        }
      }
      return true;
    }
    exports.isInBloom = isInBloom;
    function codePointToInt(codePoint) {
      if (codePoint >= 48 && codePoint <= 57) {
        return codePoint - 48;
      }
      if (codePoint >= 65 && codePoint <= 70) {
        return codePoint - 55;
      }
      if (codePoint >= 97 && codePoint <= 102) {
        return codePoint - 87;
      }
      throw new Error("invalid bloom");
    }
    function isUserEthereumAddressInBloom(bloom, ethereumAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
      }
      const address = utils_1.padLeft(ethereumAddress, 64);
      return isInBloom(bloom, address);
    }
    exports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;
    function isContractAddressInBloom(bloom, contractAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
      }
      return isInBloom(bloom, contractAddress);
    }
    exports.isContractAddressInBloom = isContractAddressInBloom;
    function isTopicInBloom(bloom, topic) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isTopic(topic)) {
        throw new Error("Invalid topic");
      }
      return isInBloom(bloom, topic);
    }
    exports.isTopicInBloom = isTopicInBloom;
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
      }
      return false;
    }
    exports.isTopic = isTopic;
    function isAddress(address) {
      if (typeof address !== "string") {
        return false;
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
      }
      if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
      }
      return false;
    }
    exports.isAddress = isAddress;
  }
});

// node_modules/web3-utils/node_modules/@noble/hashes/_assert.js
var require_assert4 = __commonJS({
  "node_modules/web3-utils/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/web3-utils/node_modules/@noble/hashes/_u64.js
var require_u643 = __commonJS({
  "node_modules/web3-utils/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/web3-utils/node_modules/@noble/hashes/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/web3-utils/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/web3-utils/node_modules/@noble/hashes/utils.js
var require_utils11 = __commonJS({
  "node_modules/web3-utils/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto3();
    var _assert_js_1 = require_assert4();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/web3-utils/node_modules/@noble/hashes/sha3.js
var require_sha33 = __commonJS({
  "node_modules/web3-utils/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert4();
    var _u64_js_1 = require_u643();
    var utils_js_1 = require_utils11();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js
var require_utils12 = __commonJS({
  "node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.hexToBytes = hexToBytes;
    exports.equalsBytes = equalsBytes;
    exports.wrapHash = wrapHash;
    var _assert_1 = __importDefault(require_assert4());
    var utils_1 = require_utils11();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils11();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha33();
    var utils_js_1 = require_utils12();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/web3-utils/lib/utils.js
var require_utils13 = __commonJS({
  "node_modules/web3-utils/lib/utils.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BN = require_bn();
    var numberToBN = require_src5();
    var utf8 = require_utf8();
    var ethereumjsUtil = require_dist7();
    var ethereumBloomFilters = require_dist8();
    var { keccak256 } = require_keccak2();
    var isBN = function(object) {
      return BN.isBN(object);
    };
    var isBigNumber = function(object) {
      return object && object.constructor && object.constructor.name === "BigNumber";
    };
    var toBN = function(number) {
      try {
        return numberToBN.apply(null, arguments);
      } catch (e) {
        throw new Error(e + ' Given value: "' + number + '"');
      }
    };
    var toTwosComplement = function(number) {
      return "0x" + toBN(number).toTwos(256).toString(16, 64);
    };
    var isAddress = function(address) {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return checkAddressChecksum(address);
      }
    };
    var checkAddressChecksum = function(address) {
      address = address.replace(/^0x/i, "");
      var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, "");
      for (var i = 0; i < 40; i++) {
        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
          return false;
        }
      }
      return true;
    };
    var leftPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join(sign ? sign : "0") + string;
    };
    var rightPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + string + new Array(padding).join(sign ? sign : "0");
    };
    var utf8ToHex = function(str) {
      str = utf8.encode(str);
      var hex = "";
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var hexToUtf8 = function(hex) {
      if (!isHexStrict(hex))
        throw new Error('The parameter "' + hex + '" must be a valid HEX string.');
      var str = "";
      var code = 0;
      hex = hex.replace(/^0x/i, "");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      var l = hex.length;
      for (var i = 0; i < l; i += 2) {
        code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return utf8.decode(str);
    };
    var hexToNumber = function(value, bigIntOnOverflow = false) {
      if (!value) {
        return value;
      }
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      const n = toBN(value);
      if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {
        return BigInt(n);
      }
      return n.toNumber();
    };
    var hexToNumberString = function(value) {
      if (!value)
        return value;
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      return toBN(value).toString(10);
    };
    var numberToHex = function(value) {
      if (value === null || value === void 0) {
        return value;
      }
      if (!isFinite(value) && !isHexStrict(value)) {
        throw new Error('Given input "' + value + '" is not a number.');
      }
      var number = toBN(value);
      var result = number.toString(16);
      return number.lt(new BN(0)) ? "-0x" + result.slice(1) : "0x" + result;
    };
    var bytesToHex = function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return "0x" + hex.join("");
    };
    var hexToBytes = function(hex) {
      hex = hex.toString(16);
      if (!isHexStrict(hex)) {
        throw new Error('Given value "' + hex + '" is not a valid hex string.');
      }
      hex = hex.replace(/^0x/i, "");
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.slice(c, c + 2), 16));
      return bytes;
    };
    var toHex = function(value, returnType) {
      if (isAddress(value)) {
        return returnType ? "address" : "0x" + value.toLowerCase().replace(/^0x/i, "");
      }
      if (typeof value === "boolean") {
        return returnType ? "bool" : value ? "0x01" : "0x00";
      }
      if (Buffer.isBuffer(value)) {
        return "0x" + value.toString("hex");
      }
      if (typeof value === "object" && !!value && !isBigNumber(value) && !isBN(value)) {
        return returnType ? "string" : utf8ToHex(JSON.stringify(value));
      }
      if (typeof value === "string") {
        if (value.indexOf("-0x") === 0 || value.indexOf("-0X") === 0) {
          return returnType ? "int256" : numberToHex(value);
        } else if (value.indexOf("0x") === 0 || value.indexOf("0X") === 0) {
          return returnType ? "bytes" : value;
        } else if (!isFinite(value)) {
          return returnType ? "string" : utf8ToHex(value);
        }
      }
      return returnType ? value < 0 ? "int256" : "uint256" : numberToHex(value);
    };
    var isHexStrict = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    var isHex = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
    };
    var stripHexPrefix = function(str) {
      if (str !== 0 && isHex(str))
        return str.replace(/^(-)?0x/i, "$1");
      return str;
    };
    var isBloom = function(bloom) {
      return ethereumBloomFilters.isBloom(bloom);
    };
    var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {
      return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);
    };
    var isContractAddressInBloom = function(bloom, contractAddress) {
      return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);
    };
    var isTopic = function(topic) {
      return ethereumBloomFilters.isTopic(topic);
    };
    var isTopicInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isTopicInBloom(bloom, topic);
    };
    var isInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isInBloom(bloom, topic);
    };
    var SHA3_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    var sha3 = function(value) {
      if (isBN(value)) {
        value = value.toString();
      }
      if (isHexStrict(value) && /^0x/i.test(value.toString())) {
        value = ethereumjsUtil.toBuffer(value);
      } else if (typeof value === "string") {
        value = Buffer.from(value, "utf-8");
      }
      var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));
      if (returnValue === SHA3_NULL_S) {
        return null;
      } else {
        return returnValue;
      }
    };
    sha3._Hash = keccak256;
    var sha3Raw = function(value) {
      value = sha3(value);
      if (value === null) {
        return SHA3_NULL_S;
      }
      return value;
    };
    var toNumber = function(value, bigIntOnOverflow = false) {
      return typeof value === "number" ? value : hexToNumber(toHex(value), bigIntOnOverflow);
    };
    var BNwrapped = function(value) {
      if (typeof value == "string" && value.includes("0x")) {
        const [negative, hexValue] = value.toLocaleLowerCase().startsWith("-") ? ["-", value.slice(3)] : ["", value.slice(2)];
        return new BN(negative + hexValue, 16);
      } else {
        return new BN(value);
      }
    };
    Object.setPrototypeOf(BNwrapped, BN);
    Object.setPrototypeOf(BNwrapped.prototype, BN.prototype);
    module.exports = {
      BN: BNwrapped,
      isBN,
      isBigNumber,
      toBN,
      isAddress,
      isBloom,
      isUserEthereumAddressInBloom,
      isContractAddressInBloom,
      isTopic,
      isTopicInBloom,
      isInBloom,
      checkAddressChecksum,
      utf8ToHex,
      hexToUtf8,
      hexToNumber,
      hexToNumberString,
      numberToHex,
      toHex,
      hexToBytes,
      bytesToHex,
      isHex,
      isHexStrict,
      stripHexPrefix,
      leftPad,
      rightPad,
      toTwosComplement,
      sha3,
      sha3Raw,
      toNumber
    };
  }
});

// node_modules/web3-utils/lib/soliditySha3.js
var require_soliditySha3 = __commonJS({
  "node_modules/web3-utils/lib/soliditySha3.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils13();
    var _elementaryName = function(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    };
    var _parseTypeN = function(type) {
      var typesize = /^\D+(\d+).*$/.exec(type);
      return typesize ? parseInt(typesize[1], 10) : null;
    };
    var _parseTypeNArray = function(type) {
      var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
      return arraySize ? parseInt(arraySize[1], 10) : null;
    };
    var _parseNumber = function(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexStrict(arg)) {
          return new BN(arg.replace(/0x/i, ""), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (utils.isBigNumber(arg)) {
        return new BN(arg.toString(10));
      } else if (utils.isBN(arg)) {
        return arg;
      } else {
        throw new Error(arg + " is not a number");
      }
    };
    var _solidityPack = function(type, value, arraySize) {
      var size, num;
      type = _elementaryName(type);
      if (type === "bytes") {
        if (value.replace(/^0x/i, "").length % 2 !== 0) {
          throw new Error("Invalid bytes characters " + value.length);
        }
        return value;
      } else if (type === "string") {
        return utils.utf8ToHex(value);
      } else if (type === "bool") {
        return value ? "01" : "00";
      } else if (type.startsWith("address")) {
        if (arraySize) {
          size = 64;
        } else {
          size = 40;
        }
        if (!utils.isAddress(value)) {
          throw new Error(value + " is not a valid address, or the checksum is invalid.");
        }
        return utils.leftPad(value.toLowerCase(), size);
      }
      size = _parseTypeN(type);
      if (type.startsWith("bytes")) {
        if (!size) {
          throw new Error("bytes[] not yet supported in solidity");
        }
        if (arraySize) {
          size = 32;
        }
        if (size < 1 || size > 32 || size < value.replace(/^0x/i, "").length / 2) {
          throw new Error("Invalid bytes" + size + " for " + value);
        }
        return utils.rightPad(value, size * 2);
      } else if (type.startsWith("uint")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          throw new Error("Supplied uint " + num.toString() + " is negative");
        }
        return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
      } else if (type.startsWith("int")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          return num.toTwos(size).toString("hex");
        } else {
          return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
        }
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    var _processSolidityEncodePackedArgs = function(arg) {
      if (Array.isArray(arg)) {
        throw new Error("Autodetection of array types is not supported.");
      }
      var type, value = "";
      var hexArg, arraySize;
      if (!!arg && typeof arg === "object" && (arg.hasOwnProperty("v") || arg.hasOwnProperty("t") || arg.hasOwnProperty("value") || arg.hasOwnProperty("type"))) {
        type = arg.hasOwnProperty("t") ? arg.t : arg.type;
        value = arg.hasOwnProperty("v") ? arg.v : arg.value;
      } else {
        type = utils.toHex(arg, true);
        value = utils.toHex(arg);
        if (!type.startsWith("int") && !type.startsWith("uint")) {
          type = "bytes";
        }
      }
      if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
        value = new BN(value);
      }
      if (Array.isArray(value)) {
        arraySize = _parseTypeNArray(type);
        if (arraySize && value.length !== arraySize) {
          throw new Error(type + " is not matching the given array " + JSON.stringify(value));
        } else {
          arraySize = value.length;
        }
      }
      if (Array.isArray(value)) {
        hexArg = value.map(function(val) {
          return _solidityPack(type, val, arraySize).toString("hex").replace("0x", "");
        });
        return hexArg.join("");
      } else {
        hexArg = _solidityPack(type, value, arraySize);
        return hexArg.toString("hex").replace("0x", "");
      }
    };
    var soliditySha3 = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return utils.sha3("0x" + hexArgs.join(""));
    };
    var soliditySha3Raw = function() {
      return utils.sha3Raw("0x" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(""));
    };
    var encodePacked = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return "0x" + hexArgs.join("").toLowerCase();
    };
    module.exports = {
      soliditySha3,
      soliditySha3Raw,
      encodePacked
    };
  }
});

// node_modules/web3-utils/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/web3-utils/lib/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ethjsUnit = require_lib();
    var utils = require_utils13();
    var soliditySha3 = require_soliditySha3();
    var randombytes = require_browser();
    var BN = require_bn();
    var _fireError = function(error, emitter, reject, callback, optionalData) {
      if (!!error && typeof error === "object" && !(error instanceof Error) && error.data) {
        if (!!error.data && typeof error.data === "object" || Array.isArray(error.data)) {
          error.data = JSON.stringify(error.data, null, 2);
        }
        error = error.message + "\n" + error.data;
      }
      if (typeof error === "string") {
        error = new Error(error);
      }
      if (typeof callback === "function") {
        callback(error, optionalData);
      }
      if (typeof reject === "function") {
        if (emitter && (typeof emitter.listeners === "function" && emitter.listeners("error").length) || typeof callback === "function") {
          emitter.catch(function() {
          });
        }
        setTimeout(function() {
          reject(error);
        }, 1);
      }
      if (emitter && typeof emitter.emit === "function") {
        setTimeout(function() {
          emitter.emit("error", error, optionalData);
          emitter.removeAllListeners();
        }, 1);
      }
      return emitter;
    };
    var _jsonInterfaceMethodToString = function(json) {
      if (!!json && typeof json === "object" && json.name && json.name.indexOf("(") !== -1) {
        return json.name;
      }
      return json.name + "(" + _flattenTypes(false, json.inputs).join(",") + ")";
    };
    var _flattenTypes = function(includeTuple, puts) {
      var types = [];
      puts.forEach(function(param) {
        if (typeof param.components === "object") {
          if (param.type.substring(0, 5) !== "tuple") {
            throw new Error("components found but type is not tuple; report on GitHub");
          }
          var suffix = "";
          var arrayBracket = param.type.indexOf("[");
          if (arrayBracket >= 0) {
            suffix = param.type.substring(arrayBracket);
          }
          var result = _flattenTypes(includeTuple, param.components);
          if (Array.isArray(result) && includeTuple) {
            types.push("tuple(" + result.join(",") + ")" + suffix);
          } else if (!includeTuple) {
            types.push("(" + result.join(",") + ")" + suffix);
          } else {
            types.push("(" + result + ")");
          }
        } else {
          types.push(param.type);
        }
      });
      return types;
    };
    var randomHex = function(size) {
      return "0x" + randombytes(size).toString("hex");
    };
    var hexToAscii = function(hex) {
      if (!utils.isHexStrict(hex))
        throw new Error("The parameter must be a valid HEX string.");
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.slice(i, i + 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    };
    var asciiToHex = function(str) {
      if (!str)
        return "0x00";
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var getUnitValue = function(unit) {
      unit = unit ? unit.toLowerCase() : "ether";
      if (!ethjsUnit.unitMap[unit]) {
        throw new Error('This unit "' + unit + `" doesn't exist, please use the one of the following units` + JSON.stringify(ethjsUnit.unitMap, null, 2));
      }
      return unit;
    };
    var fromWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);
    };
    var toWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);
    };
    var toChecksumAddress = function(address) {
      if (typeof address === "undefined")
        return "";
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address))
        throw new Error('Given address "' + address + '" is not a valid Ethereum address.');
      address = address.toLowerCase().replace(/^0x/i, "");
      var addressHash = utils.sha3(address).replace(/^0x/i, "");
      var checksumAddress = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      return checksumAddress;
    };
    var compareBlockNumbers = function(a, b) {
      if (a === b) {
        return 0;
      } else if (("genesis" === a || "earliest" === a || 0 === a) && ("genesis" === b || "earliest" === b || 0 === b)) {
        return 0;
      } else if ("genesis" === a || "earliest" === a || a === 0) {
        return -1;
      } else if ("genesis" === b || "earliest" === b || b === 0) {
        return 1;
      } else if (a === "latest" || a === "finalized") {
        if (b === "pending") {
          return -1;
        } else {
          return 1;
        }
      } else if (b === "latest" || b === "finalized") {
        if (a === "pending") {
          return 1;
        } else {
          return -1;
        }
      } else if (a === "pending") {
        return 1;
      } else if (b === "pending") {
        return -1;
      } else if (a === "safe" || b === "safe") {
        return void 0;
      } else {
        let bnA = new BN(a);
        let bnB = new BN(b);
        if (bnA.lt(bnB)) {
          return -1;
        } else if (bnA.eq(bnB)) {
          return 0;
        } else {
          return 1;
        }
      }
    };
    module.exports = {
      _fireError,
      _jsonInterfaceMethodToString,
      _flattenTypes,
      // extractDisplayName: extractDisplayName,
      // extractTypeName: extractTypeName,
      randomHex,
      BN: utils.BN,
      isBN: utils.isBN,
      isBigNumber: utils.isBigNumber,
      isHex: utils.isHex,
      isHexStrict: utils.isHexStrict,
      sha3: utils.sha3,
      sha3Raw: utils.sha3Raw,
      keccak256: utils.sha3,
      soliditySha3: soliditySha3.soliditySha3,
      soliditySha3Raw: soliditySha3.soliditySha3Raw,
      encodePacked: soliditySha3.encodePacked,
      isAddress: utils.isAddress,
      checkAddressChecksum: utils.checkAddressChecksum,
      toChecksumAddress,
      toHex: utils.toHex,
      toBN: utils.toBN,
      bytesToHex: utils.bytesToHex,
      hexToBytes: utils.hexToBytes,
      hexToNumberString: utils.hexToNumberString,
      hexToNumber: utils.hexToNumber,
      toDecimal: utils.hexToNumber,
      numberToHex: utils.numberToHex,
      fromDecimal: utils.numberToHex,
      hexToUtf8: utils.hexToUtf8,
      hexToString: utils.hexToUtf8,
      toUtf8: utils.hexToUtf8,
      stripHexPrefix: utils.stripHexPrefix,
      utf8ToHex: utils.utf8ToHex,
      stringToHex: utils.utf8ToHex,
      fromUtf8: utils.utf8ToHex,
      hexToAscii,
      toAscii: hexToAscii,
      asciiToHex,
      fromAscii: asciiToHex,
      unitMap: ethjsUnit.unitMap,
      toWei,
      fromWei,
      padLeft: utils.leftPad,
      leftPad: utils.leftPad,
      padRight: utils.rightPad,
      rightPad: utils.rightPad,
      toTwosComplement: utils.toTwosComplement,
      isBloom: utils.isBloom,
      isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,
      isContractAddressInBloom: utils.isContractAddressInBloom,
      isTopic: utils.isTopic,
      isTopicInBloom: utils.isTopicInBloom,
      isInBloom: utils.isInBloom,
      compareBlockNumbers,
      toNumber: utils.toNumber
    };
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-3770/config.js
var require_config2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-3770/config.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.networks = void 0;
    exports.networks = [
      { chainId: 1, shortName: "eth" },
      { chainId: 3, shortName: "rop" },
      { chainId: 4, shortName: "rin" },
      { chainId: 5, shortName: "gor" },
      { chainId: 10, shortName: "oeth" },
      { chainId: 11, shortName: "meta" },
      { chainId: 12, shortName: "kal" },
      { chainId: 18, shortName: "tst" },
      { chainId: 25, shortName: "cro" },
      { chainId: 28, shortName: "bobarinkeby" },
      { chainId: 39, shortName: "u2u" },
      { chainId: 40, shortName: "telosevm" },
      { chainId: 41, shortName: "telosevmtestnet" },
      { chainId: 42, shortName: "kov" },
      { chainId: 50, shortName: "xdc" },
      { chainId: 51, shortName: "txdc" },
      { chainId: 56, shortName: "bnb" },
      { chainId: 61, shortName: "etc" },
      { chainId: 63, shortName: "metc" },
      { chainId: 69, shortName: "okov" },
      { chainId: 82, shortName: "meter" },
      { chainId: 83, shortName: "meter-test" },
      { chainId: 97, shortName: "bnbt" },
      { chainId: 100, shortName: "gno" },
      { chainId: 106, shortName: "vlx" },
      { chainId: 108, shortName: "tt" },
      { chainId: 111, shortName: "etl" },
      { chainId: 122, shortName: "fuse" },
      { chainId: 123, shortName: "spark" },
      { chainId: 137, shortName: "matic" },
      { chainId: 155, shortName: "tenet-testnet" },
      { chainId: 246, shortName: "ewt" },
      { chainId: 250, shortName: "ftm" },
      { chainId: 280, shortName: "zksync-goerli" },
      { chainId: 288, shortName: "boba" },
      { chainId: 300, shortName: "ogn" },
      { chainId: 321, shortName: "kcs" },
      { chainId: 322, shortName: "kcst" },
      { chainId: 324, shortName: "zksync" },
      { chainId: 336, shortName: "sdn" },
      { chainId: 338, shortName: "tcro" },
      { chainId: 420, shortName: "ogor" },
      { chainId: 588, shortName: "metis-stardust" },
      { chainId: 592, shortName: "astr" },
      { chainId: 595, shortName: "maca" },
      { chainId: 599, shortName: "metis-goerli" },
      { chainId: 686, shortName: "kar" },
      { chainId: 787, shortName: "aca" },
      { chainId: 1001, shortName: "baobab" },
      { chainId: 1008, shortName: "eun" },
      { chainId: 1088, shortName: "metis-andromeda" },
      { chainId: 1101, shortName: "zkevm" },
      { chainId: 1111, shortName: "wemix" },
      { chainId: 1112, shortName: "twemix" },
      { chainId: 1115, shortName: "tcore" },
      { chainId: 1116, shortName: "core" },
      { chainId: 1284, shortName: "mbeam" },
      { chainId: 1285, shortName: "mriver" },
      { chainId: 1287, shortName: "mbase" },
      { chainId: 1294, shortName: "bobabeam" },
      { chainId: 1559, shortName: "tenet" },
      { chainId: 1807, shortName: "rana" },
      { chainId: 1984, shortName: "euntest" },
      { chainId: 2001, shortName: "milkada" },
      { chainId: 2002, shortName: "milkalgo" },
      { chainId: 2008, shortName: "cloudwalk_testnet" },
      { chainId: 2019, shortName: "pmint_test" },
      { chainId: 2020, shortName: "pmint" },
      { chainId: 2221, shortName: "tkava" },
      { chainId: 2222, shortName: "kava" },
      { chainId: 3737, shortName: "csb" },
      { chainId: 4002, shortName: "tftm" },
      { chainId: 4689, shortName: "iotex-mainnet" },
      { chainId: 4918, shortName: "txvm" },
      { chainId: 4919, shortName: "xvm" },
      { chainId: 5001, shortName: "mantle-testnet" },
      { chainId: 7341, shortName: "shyft" },
      { chainId: 7700, shortName: "canto" },
      { chainId: 8217, shortName: "cypress" },
      { chainId: 8453, shortName: "base" },
      { chainId: 9e3, shortName: "evmos-testnet" },
      { chainId: 9001, shortName: "evmos" },
      { chainId: 9728, shortName: "boba-testnet" },
      { chainId: 1e4, shortName: "smartbch" },
      { chainId: 10001, shortName: "smartbchtest" },
      { chainId: 10200, shortName: "chi" },
      { chainId: 11235, shortName: "islm" },
      { chainId: 11437, shortName: "shyftt" },
      { chainId: 12357, shortName: "rei-testnet" },
      { chainId: 23294, shortName: "sapphire" },
      { chainId: 23295, shortName: "sapphire-testnet" },
      { chainId: 42161, shortName: "arb1" },
      { chainId: 42170, shortName: "arb-nova" },
      { chainId: 42220, shortName: "celo" },
      { chainId: 43113, shortName: "fuji" },
      { chainId: 43114, shortName: "avax" },
      { chainId: 43288, shortName: "boba-avax" },
      { chainId: 44787, shortName: "alfa" },
      { chainId: 45e3, shortName: "autobahnnetwork" },
      { chainId: 47805, shortName: "rei" },
      { chainId: 54211, shortName: "islmt" },
      { chainId: 56288, shortName: "boba-bnb" },
      { chainId: 59140, shortName: "linea-testnet" },
      { chainId: 71401, shortName: "gw-testnet-v1" },
      { chainId: 71402, shortName: "gw-mainnet-v1" },
      { chainId: 73799, shortName: "vt" },
      { chainId: 80001, shortName: "maticmum" },
      { chainId: 84531, shortName: "base-gor" },
      { chainId: 200101, shortName: "milktada" },
      { chainId: 200202, shortName: "milktalgo" },
      { chainId: 333999, shortName: "olympus" },
      { chainId: 421611, shortName: "arb-rinkeby" },
      { chainId: 421613, shortName: "arb-goerli" },
      { chainId: 534353, shortName: "scr-alpha" },
      { chainId: 11155111, shortName: "sep" },
      { chainId: 245022926, shortName: "neonevm-devnet" },
      { chainId: 1313161554, shortName: "aurora" },
      { chainId: 1313161555, shortName: "aurora-testnet" },
      { chainId: 16666e5, shortName: "hmy-s0" },
      { chainId: 16667e5, shortName: "hmy-b-s0" },
      { chainId: 11297108099, shortName: "tpalm" },
      { chainId: 11297108109, shortName: "palm" }
    ];
    if (process.env.TEST_NETWORK === "hardhat") {
      exports.networks.push({ shortName: "local", chainId: 31337 });
    } else if (process.env.TEST_NETWORK === "ganache") {
      exports.networks.push({ shortName: "local", chainId: 1337 });
    }
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-3770/index.js
var require_eip_3770 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-3770/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateEip3770Address = exports.validateEthereumAddress = exports.validateEip3770NetworkPrefix = exports.isValidEip3770NetworkPrefix = exports.getEip3770NetworkPrefixFromChainId = exports.parseEip3770Address = void 0;
    var web3_utils_1 = require_lib4();
    var config_1 = require_config2();
    function parseEip3770Address(fullAddress) {
      const parts = fullAddress.split(":");
      const address = parts.length > 1 ? parts[1] : parts[0];
      const prefix = parts.length > 1 ? parts[0] : "";
      return { prefix, address };
    }
    exports.parseEip3770Address = parseEip3770Address;
    function getEip3770NetworkPrefixFromChainId(chainId) {
      const network = config_1.networks.find((network2) => chainId === network2.chainId);
      if (!network) {
        throw new Error("No network prefix supported for the current chainId");
      }
      return network.shortName;
    }
    exports.getEip3770NetworkPrefixFromChainId = getEip3770NetworkPrefixFromChainId;
    function isValidEip3770NetworkPrefix(prefix) {
      return config_1.networks.some(({ shortName }) => shortName === prefix);
    }
    exports.isValidEip3770NetworkPrefix = isValidEip3770NetworkPrefix;
    function validateEip3770NetworkPrefix(prefix, currentChainId) {
      const isCurrentNetworkPrefix = prefix === getEip3770NetworkPrefixFromChainId(currentChainId);
      if (!isValidEip3770NetworkPrefix(prefix) || !isCurrentNetworkPrefix) {
        throw new Error("The network prefix must match the current network");
      }
    }
    exports.validateEip3770NetworkPrefix = validateEip3770NetworkPrefix;
    function validateEthereumAddress(address) {
      const isValidAddress = (0, web3_utils_1.isHexStrict)(address) && (0, web3_utils_1.isAddress)(address);
      if (!isValidAddress) {
        throw new Error(`Invalid Ethereum address ${address}`);
      }
    }
    exports.validateEthereumAddress = validateEthereumAddress;
    function validateEip3770Address(fullAddress, currentChainId) {
      const { address, prefix } = parseEip3770Address(fullAddress);
      validateEthereumAddress(address);
      if (prefix) {
        validateEip3770NetworkPrefix(prefix, currentChainId);
      }
      return { address, prefix };
    }
    exports.validateEip3770Address = validateEip3770Address;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/lrucache.js
var require_lrucache2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/lrucache.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/parse-options.js
var require_parse_options2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/parse-options.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/constants.js
var require_constants4 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/constants.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/debug.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/re.js
var require_re2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/re.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants4();
    var debug = require_debug2();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/identifiers.js
var require_identifiers2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/internal/identifiers.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/semver.js
var require_semver2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/semver.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();
    var { safeRe: re, t } = require_re2();
    var parseOptions = require_parse_options2();
    var { compareIdentifiers } = require_identifiers2();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/compare.js
var require_compare2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/compare.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SemVer = require_semver2();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/eq.js
var require_eq2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/eq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/neq.js
var require_neq2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/neq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/gt.js
var require_gt2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/gt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/gte.js
var require_gte2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/gte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/lt.js
var require_lt2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/lt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/lte.js
var require_lte2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/lte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/cmp.js
var require_cmp2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/cmp.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var eq = require_eq2();
    var neq = require_neq2();
    var gt = require_gt2();
    var gte = require_gte2();
    var lt = require_lt2();
    var lte = require_lte2();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/comparator.js
var require_comparator2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/comparator.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options2();
    var { safeRe: re, t } = require_re2();
    var cmp = require_cmp2();
    var debug = require_debug2();
    var SemVer = require_semver2();
    var Range = require_range2();
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/classes/range.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache2();
    var cache = new LRU();
    var parseOptions = require_parse_options2();
    var Comparator = require_comparator2();
    var debug = require_debug2();
    var SemVer = require_semver2();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re2();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants4();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/satisfies.js
var require_satisfies2 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/node_modules/semver/functions/satisfies.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Range = require_range2();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-712/index.js
var require_eip_712 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/dist/src/eip-712/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateTypedData = exports.getEip712MessageTypes = exports.EIP712_DOMAIN = exports.EIP712_DOMAIN_BEFORE_V130 = void 0;
    var satisfies_1 = __importDefault(require_satisfies2());
    var EQ_OR_GT_1_3_0 = ">=1.3.0";
    exports.EIP712_DOMAIN_BEFORE_V130 = [
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    exports.EIP712_DOMAIN = [
      {
        type: "uint256",
        name: "chainId"
      },
      {
        type: "address",
        name: "verifyingContract"
      }
    ];
    function getEip712MessageTypes(safeVersion) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      return {
        EIP712Domain: eip712WithChainId ? exports.EIP712_DOMAIN : exports.EIP712_DOMAIN_BEFORE_V130,
        SafeTx: [
          { type: "address", name: "to" },
          { type: "uint256", name: "value" },
          { type: "bytes", name: "data" },
          { type: "uint8", name: "operation" },
          { type: "uint256", name: "safeTxGas" },
          { type: "uint256", name: "baseGas" },
          { type: "uint256", name: "gasPrice" },
          { type: "address", name: "gasToken" },
          { type: "address", name: "refundReceiver" },
          { type: "uint256", name: "nonce" }
        ]
      };
    }
    exports.getEip712MessageTypes = getEip712MessageTypes;
    function generateTypedData({ safeAddress, safeVersion, chainId, safeTransactionData }) {
      const eip712WithChainId = (0, satisfies_1.default)(safeVersion, EQ_OR_GT_1_3_0);
      const typedData = {
        types: getEip712MessageTypes(safeVersion),
        domain: {
          verifyingContract: safeAddress
        },
        primaryType: "SafeTx",
        message: {
          ...safeTransactionData,
          value: safeTransactionData.value,
          safeTxGas: safeTransactionData.safeTxGas,
          baseGas: safeTransactionData.baseGas,
          gasPrice: safeTransactionData.gasPrice,
          nonce: safeTransactionData.nonce
        }
      };
      if (eip712WithChainId) {
        typedData.domain.chainId = chainId;
      }
      return typedData;
    }
    exports.generateTypedData = generateTypedData;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/dist/src/safeVersions.js
var require_safeVersions = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/dist/src/safeVersions.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasSafeFeature = exports.SAFE_FEATURES = void 0;
    var satisfies_1 = __importDefault(require_satisfies2());
    var SAFE_FEATURES;
    (function(SAFE_FEATURES2) {
      SAFE_FEATURES2["SAFE_TX_GAS_OPTIONAL"] = "SAFE_TX_GAS_OPTIONAL";
      SAFE_FEATURES2["SAFE_TX_GUARDS"] = "SAFE_TX_GUARDS";
      SAFE_FEATURES2["SAFE_FALLBACK_HANDLER"] = "SAFE_FALLBACK_HANDLER";
      SAFE_FEATURES2["ETH_SIGN"] = "ETH_SIGN";
    })(SAFE_FEATURES = exports.SAFE_FEATURES || (exports.SAFE_FEATURES = {}));
    var SAFE_FEATURES_BY_VERSION = {
      [SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL]: ">=1.3.0",
      [SAFE_FEATURES.SAFE_TX_GUARDS]: ">=1.3.0",
      [SAFE_FEATURES.SAFE_FALLBACK_HANDLER]: ">=1.1.1",
      [SAFE_FEATURES.ETH_SIGN]: ">=1.1.0"
    };
    var hasSafeFeature = (feature, version) => {
      if (!(feature in SAFE_FEATURES_BY_VERSION)) {
        return false;
      }
      return (0, satisfies_1.default)(version, SAFE_FEATURES_BY_VERSION[feature]);
    };
    exports.hasSafeFeature = hasSafeFeature;
  }
});

// node_modules/@safe-global/safe-core-sdk-utils/dist/src/index.js
var require_src6 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk-utils/dist/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_eip_3770(), exports);
    __exportStar(require_eip_712(), exports);
    __exportStar(require_safeVersions(), exports);
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/constants.js
var require_constants5 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENTINEL_ADDRESS = exports.EMPTY_DATA = exports.ZERO_ADDRESS = void 0;
    exports.ZERO_ADDRESS = `0x${"0".repeat(40)}`;
    exports.EMPTY_DATA = "0x";
    exports.SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/index.js
var require_utils14 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSafeMultisigTransactionResponse = exports.isMetaTransactionArray = exports.isRestrictedAddress = exports.isZeroAddress = exports.sameString = void 0;
    var constants_1 = require_constants5();
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports.sameString = sameString;
    function isZeroAddress(address) {
      return sameString(address, constants_1.ZERO_ADDRESS);
    }
    exports.isZeroAddress = isZeroAddress;
    function isSentinelAddress(address) {
      return sameString(address, constants_1.SENTINEL_ADDRESS);
    }
    function isRestrictedAddress(address) {
      return isZeroAddress(address) || isSentinelAddress(address);
    }
    exports.isRestrictedAddress = isRestrictedAddress;
    function isMetaTransactionArray(safeTransactions) {
      return (safeTransactions === null || safeTransactions === void 0 ? void 0 : safeTransactions.length) !== void 0;
    }
    exports.isMetaTransactionArray = isMetaTransactionArray;
    function isSafeMultisigTransactionResponse(safeTransaction) {
      return safeTransaction.isExecuted !== void 0;
    }
    exports.isSafeMultisigTransactionResponse = isSafeMultisigTransactionResponse;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/managers/fallbackHandlerManager.js
var require_fallbackHandlerManager = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/managers/fallbackHandlerManager.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FallbackHandlerManager_ethAdapter;
    var _FallbackHandlerManager_safeContract;
    var _FallbackHandlerManager_slot;
    Object.defineProperty(exports, "__esModule", { value: true });
    var safe_core_sdk_utils_1 = require_src6();
    var utils_1 = require_utils14();
    var constants_1 = require_constants5();
    var FallbackHandlerManager = class {
      constructor(ethAdapter, safeContract) {
        _FallbackHandlerManager_ethAdapter.set(this, void 0);
        _FallbackHandlerManager_safeContract.set(this, void 0);
        _FallbackHandlerManager_slot.set(this, "0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5");
        __classPrivateFieldSet(this, _FallbackHandlerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _FallbackHandlerManager_safeContract, safeContract, "f");
      }
      validateFallbackHandlerAddress(fallbackHandlerAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _FallbackHandlerManager_ethAdapter, "f").isAddress(fallbackHandlerAddress);
        if (!isValidAddress || (0, utils_1.isZeroAddress)(fallbackHandlerAddress)) {
          throw new Error("Invalid fallback handler address provided");
        }
      }
      validateFallbackHandlerIsNotEnabled(currentFallbackHandler, newFallbackHandlerAddress) {
        if ((0, utils_1.sameString)(currentFallbackHandler, newFallbackHandlerAddress)) {
          throw new Error("Fallback handler provided is already enabled");
        }
      }
      validateFallbackHandlerIsEnabled(fallbackHandlerAddress) {
        if ((0, utils_1.isZeroAddress)(fallbackHandlerAddress)) {
          throw new Error("There is no fallback handler enabled yet");
        }
      }
      async getFallbackHandler() {
        const safeVersion = await __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").getVersion();
        if ((0, safe_core_sdk_utils_1.hasSafeFeature)(safe_core_sdk_utils_1.SAFE_FEATURES.SAFE_FALLBACK_HANDLER, safeVersion)) {
          return __classPrivateFieldGet(this, _FallbackHandlerManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").getAddress(), __classPrivateFieldGet(this, _FallbackHandlerManager_slot, "f"));
        } else {
          throw new Error("Current version of the Safe does not support the fallback handler functionality");
        }
      }
      async encodeEnableFallbackHandlerData(fallbackHandlerAddress) {
        this.validateFallbackHandlerAddress(fallbackHandlerAddress);
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsNotEnabled(currentFallbackHandler, fallbackHandlerAddress);
        return __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").encode("setFallbackHandler", [fallbackHandlerAddress]);
      }
      async encodeDisableFallbackHandlerData() {
        const currentFallbackHandler = await this.getFallbackHandler();
        this.validateFallbackHandlerIsEnabled(currentFallbackHandler);
        return __classPrivateFieldGet(this, _FallbackHandlerManager_safeContract, "f").encode("setFallbackHandler", [constants_1.ZERO_ADDRESS]);
      }
    };
    _FallbackHandlerManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _FallbackHandlerManager_safeContract = /* @__PURE__ */ new WeakMap(), _FallbackHandlerManager_slot = /* @__PURE__ */ new WeakMap();
    exports.default = FallbackHandlerManager;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/managers/guardManager.js
var require_guardManager = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/managers/guardManager.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _GuardManager_ethAdapter;
    var _GuardManager_safeContract;
    var _GuardManager_slot;
    Object.defineProperty(exports, "__esModule", { value: true });
    var safe_core_sdk_utils_1 = require_src6();
    var utils_1 = require_utils14();
    var constants_1 = require_constants5();
    var GuardManager = class {
      constructor(ethAdapter, safeContract) {
        _GuardManager_ethAdapter.set(this, void 0);
        _GuardManager_safeContract.set(this, void 0);
        _GuardManager_slot.set(this, "0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8");
        __classPrivateFieldSet(this, _GuardManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _GuardManager_safeContract, safeContract, "f");
      }
      validateGuardAddress(guardAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _GuardManager_ethAdapter, "f").isAddress(guardAddress);
        if (!isValidAddress || (0, utils_1.isZeroAddress)(guardAddress)) {
          throw new Error("Invalid guard address provided");
        }
      }
      validateGuardIsNotEnabled(currentGuard, newGuardAddress) {
        if ((0, utils_1.sameString)(currentGuard, newGuardAddress)) {
          throw new Error("Guard provided is already enabled");
        }
      }
      validateGuardIsEnabled(guardAddress) {
        if ((0, utils_1.isZeroAddress)(guardAddress)) {
          throw new Error("There is no guard enabled yet");
        }
      }
      async getGuard() {
        const safeVersion = await __classPrivateFieldGet(this, _GuardManager_safeContract, "f").getVersion();
        if ((0, safe_core_sdk_utils_1.hasSafeFeature)(safe_core_sdk_utils_1.SAFE_FEATURES.SAFE_TX_GUARDS, safeVersion)) {
          return __classPrivateFieldGet(this, _GuardManager_ethAdapter, "f").getStorageAt(__classPrivateFieldGet(this, _GuardManager_safeContract, "f").getAddress(), __classPrivateFieldGet(this, _GuardManager_slot, "f"));
        } else {
          throw new Error("Current version of the Safe does not support Safe transaction guards functionality");
        }
      }
      async encodeEnableGuardData(guardAddress) {
        this.validateGuardAddress(guardAddress);
        const currentGuard = await this.getGuard();
        this.validateGuardIsNotEnabled(currentGuard, guardAddress);
        return __classPrivateFieldGet(this, _GuardManager_safeContract, "f").encode("setGuard", [guardAddress]);
      }
      async encodeDisableGuardData() {
        const currentGuard = await this.getGuard();
        this.validateGuardIsEnabled(currentGuard);
        return __classPrivateFieldGet(this, _GuardManager_safeContract, "f").encode("setGuard", [constants_1.ZERO_ADDRESS]);
      }
    };
    _GuardManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _GuardManager_safeContract = /* @__PURE__ */ new WeakMap(), _GuardManager_slot = /* @__PURE__ */ new WeakMap();
    exports.default = GuardManager;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/managers/moduleManager.js
var require_moduleManager = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/managers/moduleManager.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ModuleManager_ethAdapter;
    var _ModuleManager_safeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils14();
    var constants_1 = require_constants5();
    var ModuleManager = class {
      constructor(ethAdapter, safeContract) {
        _ModuleManager_ethAdapter.set(this, void 0);
        _ModuleManager_safeContract.set(this, void 0);
        __classPrivateFieldSet(this, _ModuleManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _ModuleManager_safeContract, safeContract, "f");
      }
      validateModuleAddress(moduleAddress) {
        const isValidAddress = __classPrivateFieldGet(this, _ModuleManager_ethAdapter, "f").isAddress(moduleAddress);
        if (!isValidAddress || (0, utils_1.isRestrictedAddress)(moduleAddress)) {
          throw new Error("Invalid module address provided");
        }
      }
      validateModuleIsNotEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module2) => (0, utils_1.sameString)(module2, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (isEnabled) {
          throw new Error("Module provided is already enabled");
        }
      }
      validateModuleIsEnabled(moduleAddress, modules) {
        const moduleIndex = modules.findIndex((module2) => (0, utils_1.sameString)(module2, moduleAddress));
        const isEnabled = moduleIndex >= 0;
        if (!isEnabled) {
          throw new Error("Module provided is not enabled yet");
        }
        return moduleIndex;
      }
      async getModules() {
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").getModules();
      }
      async isModuleEnabled(moduleAddress) {
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").isModuleEnabled(moduleAddress);
      }
      async encodeEnableModuleData(moduleAddress) {
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        this.validateModuleIsNotEnabled(moduleAddress, modules);
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").encode("enableModule", [moduleAddress]);
      }
      async encodeDisableModuleData(moduleAddress) {
        this.validateModuleAddress(moduleAddress);
        const modules = await this.getModules();
        const moduleIndex = this.validateModuleIsEnabled(moduleAddress, modules);
        const prevModuleAddress = moduleIndex === 0 ? constants_1.SENTINEL_ADDRESS : modules[moduleIndex - 1];
        return __classPrivateFieldGet(this, _ModuleManager_safeContract, "f").encode("disableModule", [prevModuleAddress, moduleAddress]);
      }
    };
    _ModuleManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _ModuleManager_safeContract = /* @__PURE__ */ new WeakMap();
    exports.default = ModuleManager;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/managers/ownerManager.js
var require_ownerManager = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/managers/ownerManager.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _OwnerManager_ethAdapter;
    var _OwnerManager_safeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils14();
    var constants_1 = require_constants5();
    var OwnerManager = class {
      constructor(ethAdapter, safeContract) {
        _OwnerManager_ethAdapter.set(this, void 0);
        _OwnerManager_safeContract.set(this, void 0);
        __classPrivateFieldSet(this, _OwnerManager_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _OwnerManager_safeContract, safeContract, "f");
      }
      validateOwnerAddress(ownerAddress, errorMessage) {
        const isValidAddress = __classPrivateFieldGet(this, _OwnerManager_ethAdapter, "f").isAddress(ownerAddress);
        if (!isValidAddress || (0, utils_1.isRestrictedAddress)(ownerAddress)) {
          throw new Error(errorMessage || "Invalid owner address provided");
        }
      }
      validateThreshold(threshold, numOwners) {
        if (threshold <= 0) {
          throw new Error("Threshold needs to be greater than 0");
        }
        if (threshold > numOwners) {
          throw new Error("Threshold cannot exceed owner count");
        }
      }
      validateAddressIsNotOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, utils_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (isOwner) {
          throw new Error(errorMessage || "Address provided is already an owner");
        }
      }
      validateAddressIsOwner(ownerAddress, owners, errorMessage) {
        const ownerIndex = owners.findIndex((owner) => (0, utils_1.sameString)(owner, ownerAddress));
        const isOwner = ownerIndex >= 0;
        if (!isOwner) {
          throw new Error(errorMessage || "Address provided is not an owner");
        }
        return ownerIndex;
      }
      async getOwners() {
        const owners = await __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").getOwners();
        return [...owners];
      }
      async getThreshold() {
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").getThreshold();
      }
      async isOwner(ownerAddress) {
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").isOwner(ownerAddress);
      }
      async encodeAddOwnerWithThresholdData(ownerAddress, threshold) {
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(ownerAddress, owners);
        const newThreshold = threshold !== null && threshold !== void 0 ? threshold : await this.getThreshold();
        this.validateThreshold(newThreshold, owners.length + 1);
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("addOwnerWithThreshold", [ownerAddress, newThreshold]);
      }
      async encodeRemoveOwnerData(ownerAddress, threshold) {
        this.validateOwnerAddress(ownerAddress);
        const owners = await this.getOwners();
        const ownerIndex = this.validateAddressIsOwner(ownerAddress, owners);
        const newThreshold = threshold !== null && threshold !== void 0 ? threshold : await this.getThreshold() - 1;
        this.validateThreshold(newThreshold, owners.length - 1);
        const prevOwnerAddress = ownerIndex === 0 ? constants_1.SENTINEL_ADDRESS : owners[ownerIndex - 1];
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("removeOwner", [prevOwnerAddress, ownerAddress, newThreshold]);
      }
      async encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress) {
        this.validateOwnerAddress(newOwnerAddress, "Invalid new owner address provided");
        this.validateOwnerAddress(oldOwnerAddress, "Invalid old owner address provided");
        const owners = await this.getOwners();
        this.validateAddressIsNotOwner(newOwnerAddress, owners, "New address provided is already an owner");
        const oldOwnerIndex = this.validateAddressIsOwner(oldOwnerAddress, owners, "Old address provided is not an owner");
        const prevOwnerAddress = oldOwnerIndex === 0 ? constants_1.SENTINEL_ADDRESS : owners[oldOwnerIndex - 1];
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("swapOwner", [
          prevOwnerAddress,
          oldOwnerAddress,
          newOwnerAddress
        ]);
      }
      async encodeChangeThresholdData(threshold) {
        const owners = await this.getOwners();
        this.validateThreshold(threshold, owners.length);
        return __classPrivateFieldGet(this, _OwnerManager_safeContract, "f").encode("changeThreshold", [threshold]);
      }
    };
    _OwnerManager_ethAdapter = /* @__PURE__ */ new WeakMap(), _OwnerManager_safeContract = /* @__PURE__ */ new WeakMap();
    exports.default = OwnerManager;
  }
});

// node_modules/ethereumjs-util/dist.browser/externals.js
var require_externals = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/externals.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlp = exports.BN = void 0;
    var bn_js_1 = __importDefault(require_bn());
    exports.BN = bn_js_1.default;
    var rlp = __importStar(require_dist4());
    exports.rlp = rlp;
  }
});

// node_modules/ethereumjs-util/dist.browser/constants.js
var require_constants6 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    var externals_1 = require_externals();
    exports.MAX_UINT64 = new externals_1.BN("ffffffffffffffff", 16);
    exports.MAX_INTEGER = new externals_1.BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new externals_1.BN("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var errors = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond) throw new Error(msg);
    }
    function isUint8Array(name, value, length) {
      assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
      if (length !== void 0) {
        if (Array.isArray(length)) {
          const numbers = length.join(", ");
          const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
          assert(length.includes(value.length), msg);
        } else {
          const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
          assert(value.length === length, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
      if (typeof output === "function") output = output(length);
      isUint8Array("output", output, length);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(
            seed === null || seed instanceof Uint8Array,
            "Expected seed to be an Uint8Array or null"
          );
          if (seed !== null) isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SECKEY_INVALID);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0) isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0) assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors.SIGN);
            case 2:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(
            toTypeString(recid) === "Number" && recid >= 0 && recid <= 3,
            "Expected recovery id to be a Number within interval [0, 3]"
          );
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.SIG_PARSE);
            case 2:
              throw new Error(errors.RECOVER);
            case 3:
              throw new Error(errors.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0) isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0) isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0) isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors.PUBKEY_PARSE);
            case 2:
              throw new Error(errors.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first, xbuf) {
      let x = new BN(xbuf);
      if (x.cmp(ecparams.p) >= 0) return null;
      x = x.toRed(ecparams.red);
      let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y.isOdd()) y = y.redNeg();
      const x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadUncompressedPublicKey(first, xbuf, ybuf) {
      let x = new BN(xbuf);
      let y = new BN(ybuf);
      if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
      x = x.toRed(ecparams.red);
      y = y.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y.isOdd() !== (first === 7)) return null;
      const x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadPublicKey(pubkey) {
      const first = pubkey[0];
      switch (first) {
        case 2:
        case 3:
          if (pubkey.length !== 33) return null;
          return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65) return null;
          return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];
    }
    module.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0) return 1;
        bn.iadd(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
        if (bn.isZero()) return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
        bn.imul(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i = 0; i < pubkeys.length; ++i) {
          pairs[i] = loadPublicKey(pubkeys[i]);
          if (pairs[i] === null) return 1;
        }
        let point = pairs[0].getPublic();
        for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
        if (point.isInfinity()) return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0) return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity()) return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r = new BN(sig.subarray(0, 32));
        const s = new BN(sig.subarray(32, 64));
        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1;
        if (s.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0) return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0) return 1;
        const { output } = obj;
        let r = output.subarray(4, 4 + 33);
        r[0] = 0;
        r.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR) ;
        r = r.subarray(posR);
        if (r[0] & 128) return 1;
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128)) return 1;
        let s = output.subarray(6 + 33, 6 + 33 + 33);
        s[0] = 0;
        s.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS) ;
        s = s.subarray(posS);
        if (s[0] & 128) return 1;
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r.length;
        output.set(r, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s.length;
        output.set(s, 6 + lenR);
        return 0;
      },
      // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
      // Adapted for Uint8Array instead Buffer
      signatureImport(output, sig) {
        if (sig.length < 8) return 1;
        if (sig.length > 72) return 1;
        if (sig[0] !== 48) return 1;
        if (sig[1] !== sig.length - 2) return 1;
        if (sig[2] !== 2) return 1;
        const lenR = sig[3];
        if (lenR === 0) return 1;
        if (5 + lenR >= sig.length) return 1;
        if (sig[4 + lenR] !== 2) return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0) return 1;
        if (6 + lenR + lenS !== sig.length) return 1;
        if (sig[4] & 128) return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128)) return 1;
        if (sig[lenR + 6] & 128) return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128)) return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0) sigR = sigR.subarray(1);
        if (sigR.length > 32) return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0) sigS = sigS.slice(1);
        if (sigS.length > 32) throw new Error("S length is too long");
        let r = new BN(sigR);
        if (r.cmp(ecparams.n) >= 0) r = new BN(0);
        let s = new BN(sig.subarray(6 + lenR));
        if (s.cmp(ecparams.n) >= 0) s = new BN(0);
        output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid) throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d = new BN(seckey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1;
        let sig;
        try {
          sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1;
        if (sigr.isZero() || sigs.isZero()) return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null) return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha256 = ec.hash().update(data2).digest();
          for (let i = 0; i < 32; ++i) output[i] = sha256[i];
        } else {
          if (!xbuf) xbuf = new Uint8Array(32);
          const x = point.getX().toArray("be", 32);
          for (let i = 0; i < 32; ++i) xbuf[i] = x[i];
          if (!ybuf) ybuf = new Uint8Array(32);
          const y = point.getY().toArray("be", 32);
          for (let i = 0; i < 32; ++i) ybuf[i] = y[i];
          const hash = hashfn(xbuf, ybuf, data);
          const isValid = hash instanceof Uint8Array && hash.length === output.length;
          if (!isValid) return 2;
          output.set(hash);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = require_lib5()(require_elliptic2());
  }
});

// node_modules/ethereum-cryptography/random.js
var require_random = __commonJS({
  "node_modules/ethereum-cryptography/random.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var randombytes = require_browser();
    function getRandomBytes(bytes) {
      return new Promise(function(resolve2, reject) {
        randombytes(bytes, function(err, resp) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(resp);
        });
      });
    }
    exports.getRandomBytes = getRandomBytes;
    function getRandomBytesSync(bytes) {
      return randombytes(bytes);
    }
    exports.getRandomBytesSync = getRandomBytesSync;
  }
});

// node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k13 = __commonJS({
  "node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    function __export2(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var secp256k1_1 = require_elliptic3();
    var random_1 = require_random();
    var SECP256K1_PRIVATE_KEY_SIZE = 32;
    function createPrivateKey() {
      return __awaiter(this, void 0, void 0, function() {
        var pk;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (false) return [3, 2];
              return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
            case 1:
              pk = _a.sent();
              if (secp256k1_1.privateKeyVerify(pk)) {
                return [2, pk];
              }
              return [3, 0];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.createPrivateKey = createPrivateKey;
    function createPrivateKeySync() {
      while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
          return pk;
        }
      }
    }
    exports.createPrivateKeySync = createPrivateKeySync;
    __export2(require_elliptic3());
  }
});

// node_modules/ethereumjs-util/dist.browser/internal.js
var require_internal2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/internal.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(typeof str));
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = function(str) {
      if (typeof str !== "string")
        throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(typeof str));
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[padToEven] value must be type 'string', received ".concat(typeof a));
      }
      if (a.length % 2)
        a = "0".concat(a);
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[getBinarySize] method requires input type 'string', recieved ".concat(typeof str));
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'superset' to be an array, got type '".concat(typeof superset, "'"));
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[arrayContainsArray] method requires input 'subset' to be an array, got type '".concat(typeof subset, "'"));
      }
      return subset[some ? "some" : "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      var str = "";
      var i = 0;
      var l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      var str = Buffer.from(stringValue, "utf8");
      return "0x".concat(padToEven(str.toString("hex")).replace(/^0+|0+$/g, ""));
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      var hex = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0".concat(n) : n;
      }
      return "0x".concat(hex);
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[getKeys] method expects input 'params' to be an array, got ".concat(typeof params));
      }
      if (typeof key !== "string") {
        throw new Error("[getKeys] method expects input 'key' to be type 'string', got ".concat(typeof params));
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi - expected type 'string', received ".concat(typeof value));
        }
        result.push(value);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (length && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/ethereumjs-util/dist.browser/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/helpers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal2();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        var msg = "This method only supports 0x-prefixed hex strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        var msg = "This method only supports Buffer but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        var msg = "This method only supports number arrays but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        var msg = "This method only supports strings but input was: ".concat(input);
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/ethereumjs-util/dist.browser/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/bytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal2();
    var helpers_1 = require_helpers2();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error("Received an invalid integer type: ".concat(i));
      }
      return "0x".concat(i.toString(16));
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i) {
      var hex = (0, exports.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length, right) {
      var buf = (0, exports.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ".concat(v));
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (externals_1.BN.isBN(v)) {
        if (v.isNeg()) {
          throw new Error("Cannot convert negative BN to buffer. Given: ".concat(v));
        }
        return v.toArrayLike(Buffer);
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToInt = function(buf) {
      return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();
    };
    exports.bufferToInt = bufferToInt;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    var fromSigned = function(num) {
      return new externals_1.BN(num).fromTwos(256);
    };
    exports.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return Buffer.from(num.toTwos(256).toArray());
    };
    exports.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix;
    var toUtf8 = function(hex) {
      var zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      var bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return "0x".concat(ba.toString("hex"));
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push((0, exports.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      var e_1, _a;
      try {
        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
          if (v !== void 0 && v.length > 0 && v[0] === 0) {
            throw new Error("".concat(k, " cannot have leading zeroes, received: ").concat(v.toString("hex")));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map(function(a) {
        return arrToBufArr(a);
      });
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);
      }
      return arr.map(function(a) {
        return bufArrToArr(a);
      });
    }
    exports.bufArrToArr = bufArrToArr;
  }
});

// node_modules/ethereum-cryptography/hash-utils.js
var require_hash_utils = __commonJS({
  "node_modules/ethereum-cryptography/hash-utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function createHashFunction(hashConstructor) {
      return function(msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
      };
    }
    exports.createHashFunction = createHashFunction;
  }
});

// node_modules/ethereum-cryptography/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_utils_1 = require_hash_utils();
    var createKeccakHash = require_js();
    exports.keccak224 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak224");
    });
    exports.keccak256 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak256");
    });
    exports.keccak384 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak384");
    });
    exports.keccak512 = hash_utils_1.createHashFunction(function() {
      return createKeccakHash("keccak512");
    });
  }
});

// node_modules/ethereumjs-util/dist.browser/hash.js
var require_hash = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/hash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;
    var keccak_1 = require_keccak3();
    var createHash = require_browser2();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes2();
    var helpers_1 = require_helpers2();
    var keccak = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsBuffer)(a);
      switch (bits) {
        case 224: {
          return (0, keccak_1.keccak224)(a);
        }
        case 256: {
          return (0, keccak_1.keccak256)(a);
        }
        case 384: {
          return (0, keccak_1.keccak384)(a);
        }
        case 512: {
          return (0, keccak_1.keccak512)(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak".concat(bits));
        }
      }
    };
    exports.keccak = keccak;
    var keccak256 = function(a) {
      return (0, exports.keccak)(a);
    };
    exports.keccak256 = keccak256;
    var keccakFromString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsString)(a);
      var buf = Buffer.from(a, "utf8");
      return (0, exports.keccak)(buf, bits);
    };
    exports.keccakFromString = keccakFromString;
    var keccakFromHexString = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsHexString)(a);
      return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports.keccakFromHexString = keccakFromHexString;
    var keccakFromArray = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      (0, helpers_1.assertIsArray)(a);
      return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);
    };
    exports.keccakFromArray = keccakFromArray;
    var _sha256 = function(a) {
      a = (0, bytes_1.toBuffer)(a);
      return createHash("sha256").update(a).digest();
    };
    var sha256 = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return _sha256(a);
    };
    exports.sha256 = sha256;
    var sha256FromString = function(a) {
      (0, helpers_1.assertIsString)(a);
      return _sha256(a);
    };
    exports.sha256FromString = sha256FromString;
    var sha256FromArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return _sha256(a);
    };
    exports.sha256FromArray = sha256FromArray;
    var _ripemd160 = function(a, padded) {
      a = (0, bytes_1.toBuffer)(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return (0, bytes_1.setLengthLeft)(hash, 32);
      } else {
        return hash;
      }
    };
    var ripemd160 = function(a, padded) {
      (0, helpers_1.assertIsBuffer)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160 = ripemd160;
    var ripemd160FromString = function(a, padded) {
      (0, helpers_1.assertIsString)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160FromString = ripemd160FromString;
    var ripemd160FromArray = function(a, padded) {
      (0, helpers_1.assertIsArray)(a);
      return _ripemd160(a, padded);
    };
    exports.ripemd160FromArray = ripemd160FromArray;
    var rlphash = function(a) {
      return (0, exports.keccak)(externals_1.rlp.encode(a));
    };
    exports.rlphash = rlphash;
  }
});

// node_modules/ethereumjs-util/dist.browser/types.js
var require_types4 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;
    var externals_1 = require_externals();
    var internal_1 = require_internal2();
    var bytes_1 = require_bytes2();
    function bnToHex(value) {
      return "0x".concat(value.toString(16));
    }
    exports.bnToHex = bnToHex;
    function bnToUnpaddedBuffer(value) {
      return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
    }
    exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
    function bnToRlp(value) {
      return bnToUnpaddedBuffer(value);
    }
    exports.bnToRlp = bnToRlp;
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BN"] = 1] = "BN";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error("A string must be provided with a 0x-prefix, given: ".concat(input));
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      var output = (0, bytes_1.toBuffer)(input);
      if (outputType === TypeOutput.Buffer) {
        return output;
      } else if (outputType === TypeOutput.BN) {
        return new externals_1.BN(output);
      } else if (outputType === TypeOutput.Number) {
        var bn = new externals_1.BN(output);
        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());
        if (bn.gt(max)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return bn.toNumber();
      } else {
        return "0x".concat(output.toString("hex"));
      }
    }
    exports.toType = toType;
  }
});

// node_modules/ethereumjs-util/dist.browser/account.js
var require_account2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/account.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var secp256k1_1 = require_secp256k13();
    var internal_1 = require_internal2();
    var constants_1 = require_constants6();
    var bytes_1 = require_bytes2();
    var hash_1 = require_hash();
    var helpers_1 = require_helpers2();
    var types_1 = require_types4();
    var Account = (
      /** @class */
      function() {
        function Account2(nonce, balance, stateRoot, codeHash) {
          if (nonce === void 0) {
            nonce = new externals_1.BN(0);
          }
          if (balance === void 0) {
            balance = new externals_1.BN(0);
          }
          if (stateRoot === void 0) {
            stateRoot = constants_1.KECCAK256_RLP;
          }
          if (codeHash === void 0) {
            codeHash = constants_1.KECCAK256_NULL;
          }
          this.nonce = nonce;
          this.balance = balance;
          this.stateRoot = stateRoot;
          this.codeHash = codeHash;
          this._validate();
        }
        Account2.fromAccountData = function(accountData) {
          var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;
          return new Account2(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : void 0, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : void 0, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : void 0, codeHash ? (0, bytes_1.toBuffer)(codeHash) : void 0);
        };
        Account2.fromRlpSerializedAccount = function(serialized) {
          var values = externals_1.rlp.decode(serialized);
          if (!Array.isArray(values)) {
            throw new Error("Invalid serialized account input. Must be array");
          }
          return this.fromValuesArray(values);
        };
        Account2.fromValuesArray = function(values) {
          var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];
          return new Account2(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);
        };
        Account2.prototype._validate = function() {
          if (this.nonce.lt(new externals_1.BN(0))) {
            throw new Error("nonce must be greater than zero");
          }
          if (this.balance.lt(new externals_1.BN(0))) {
            throw new Error("balance must be greater than zero");
          }
          if (this.stateRoot.length !== 32) {
            throw new Error("stateRoot must have a length of 32");
          }
          if (this.codeHash.length !== 32) {
            throw new Error("codeHash must have a length of 32");
          }
        };
        Account2.prototype.raw = function() {
          return [
            (0, types_1.bnToUnpaddedBuffer)(this.nonce),
            (0, types_1.bnToUnpaddedBuffer)(this.balance),
            this.stateRoot,
            this.codeHash
          ];
        };
        Account2.prototype.serialize = function() {
          return externals_1.rlp.encode(this.raw());
        };
        Account2.prototype.isContract = function() {
          return !this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        Account2.prototype.isEmpty = function() {
          return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
        };
        return Account2;
      }()
    );
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      var prefix = "";
      if (eip1191ChainId) {
        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
        prefix = chainId.toString() + "0x";
      }
      var hash = (0, hash_1.keccakFromString)(prefix + address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      var nonceBN = new externals_1.BN(nonce);
      if (nonceBN.isZero()) {
        return (0, hash_1.rlphash)([from, null]).slice(-20);
      }
      return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      (0, assert_1.default)(from.length === 20);
      (0, assert_1.default)(salt.length === 32);
      var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, hash_1.keccak256)(initCode)]));
      return address.slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return (0, secp256k1_1.privateKeyVerify)(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return (0, secp256k1_1.publicKeyVerify)(publicKey);
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));
      }
      (0, assert_1.default)(pubKey.length === 64);
      return (0, hash_1.keccak)(pubKey).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      var addressLength = 20;
      var addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      var zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
  }
});

// node_modules/ethereumjs-util/dist.browser/address.js
var require_address2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var assert_1 = __importDefault(require_assert());
    var externals_1 = require_externals();
    var bytes_1 = require_bytes2();
    var account_1 = require_account2();
    var Address = (
      /** @class */
      function() {
        function Address2(buf) {
          (0, assert_1.default)(buf.length === 20, "Invalid address length");
          this.buf = buf;
        }
        Address2.zero = function() {
          return new Address2((0, bytes_1.zeros)(20));
        };
        Address2.fromString = function(str) {
          (0, assert_1.default)((0, account_1.isValidAddress)(str), "Invalid address");
          return new Address2((0, bytes_1.toBuffer)(str));
        };
        Address2.fromPublicKey = function(pubKey) {
          (0, assert_1.default)(Buffer.isBuffer(pubKey), "Public key should be Buffer");
          var buf = (0, account_1.pubToAddress)(pubKey);
          return new Address2(buf);
        };
        Address2.fromPrivateKey = function(privateKey) {
          (0, assert_1.default)(Buffer.isBuffer(privateKey), "Private key should be Buffer");
          var buf = (0, account_1.privateToAddress)(privateKey);
          return new Address2(buf);
        };
        Address2.generate = function(from, nonce) {
          (0, assert_1.default)(externals_1.BN.isBN(nonce));
          return new Address2((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));
        };
        Address2.generate2 = function(from, salt, initCode) {
          (0, assert_1.default)(Buffer.isBuffer(salt));
          (0, assert_1.default)(Buffer.isBuffer(initCode));
          return new Address2((0, account_1.generateAddress2)(from.buf, salt, initCode));
        };
        Address2.prototype.equals = function(address) {
          return this.buf.equals(address.buf);
        };
        Address2.prototype.isZero = function() {
          return this.equals(Address2.zero());
        };
        Address2.prototype.isPrecompileOrSystemAddress = function() {
          var addressBN = new externals_1.BN(this.buf);
          var rangeMin = new externals_1.BN(0);
          var rangeMax = new externals_1.BN("ffff", "hex");
          return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
        };
        Address2.prototype.toString = function() {
          return "0x" + this.buf.toString("hex");
        };
        Address2.prototype.toBuffer = function() {
          return Buffer.from(this.buf);
        };
        return Address2;
      }()
    );
    exports.Address = Address;
  }
});

// node_modules/ethereumjs-util/dist.browser/signature.js
var require_signature2 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/signature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k1_1 = require_secp256k13();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes2();
    var hash_1 = require_hash();
    var helpers_1 = require_helpers2();
    var types_1 = require_types4();
    function ecsign(msgHash, privateKey, chainId) {
      var _a = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;
      var r = Buffer.from(signature.slice(0, 32));
      var s = Buffer.from(signature.slice(32, 64));
      if (!chainId || typeof chainId === "number") {
        if (chainId && !Number.isSafeInteger(chainId)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
        }
        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
        return { r, s, v: v_1 };
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);
      return { r, s, v };
    }
    exports.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (vBN.eqn(0) || vBN.eqn(1))
        return (0, types_1.toType)(v, types_1.TypeOutput.BN);
      if (!chainId) {
        return vBN.subn(27);
      }
      var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);
      return vBN.sub(chainIdBN.muln(2).addn(35));
    }
    function isValidSigRecovery(recovery) {
      var rec = new externals_1.BN(recovery);
      return rec.eqn(0) || rec.eqn(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      var signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);
      return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);
      var ss = s;
      if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      var buf = (0, bytes_1.toBuffer)(sig);
      var r;
      var s;
      var v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new externals_1.BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new externals_1.BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      var rBN = new externals_1.BN(r);
      var sBN = new externals_1.BN(s);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      var prefix = Buffer.from("Ethereum Signed Message:\n".concat(message.length), "utf-8");
      return (0, hash_1.keccak)(Buffer.concat([prefix, message]));
    };
    exports.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/ethereumjs-util/dist.browser/object.js
var require_object = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/object.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert_1 = __importDefault(require_assert());
    var internal_1 = require_internal2();
    var externals_1 = require_externals();
    var bytes_1 = require_bytes2();
    var defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self2._fields.forEach(function(field) {
            obj_1[field] = "0x".concat(self2[field].toString("hex"));
          });
          return obj_1;
        }
        return (0, bytes_1.baToJSON)(self2.raw);
      };
      self2.serialize = function serialize() {
        return externals_1.rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = (0, bytes_1.toBuffer)(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = (0, bytes_1.unpadBuffer)(v);
            (0, assert_1.default)(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            (0, assert_1.default)(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer.from((0, internal_1.stripHexPrefix)(data), "hex");
        }
        if (Buffer.isBuffer(data)) {
          data = externals_1.rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = (0, bytes_1.toBuffer)(d);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
    exports.defineProperties = defineProperties;
  }
});

// node_modules/ethereumjs-util/dist.browser/index.js
var require_dist9 = __commonJS({
  "node_modules/ethereumjs-util/dist.browser/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    __exportStar(require_constants6(), exports);
    __exportStar(require_account2(), exports);
    __exportStar(require_address2(), exports);
    __exportStar(require_hash(), exports);
    __exportStar(require_signature2(), exports);
    __exportStar(require_bytes2(), exports);
    __exportStar(require_object(), exports);
    __exportStar(require_externals(), exports);
    __exportStar(require_types4(), exports);
    var internal_1 = require_internal2();
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/signatures/SafeSignature.js
var require_SafeSignature = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/signatures/SafeSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var EthSignSignature = class {
      /**
       * Creates an instance of a Safe signature.
       *
       * @param signer - Ethers signer
       * @param signature - The Safe signature
       * @returns The Safe signature instance
       */
      constructor(signer, signature) {
        this.signer = signer;
        this.data = signature;
      }
      /**
       * Returns the static part of the Safe signature.
       *
       * @returns The static part of the Safe signature
       */
      staticPart() {
        return this.data;
      }
      /**
       * Returns the dynamic part of the Safe signature.
       *
       * @returns The dynamic part of the Safe signature
       */
      dynamicPart() {
        return "";
      }
    };
    exports.default = EthSignSignature;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/signatures/index.js
var require_signatures = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/signatures/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;
    var ethereumjs_util_1 = require_dist9();
    var utils_1 = require_utils14();
    var SafeSignature_1 = __importDefault(require_SafeSignature());
    function generatePreValidatedSignature(ownerAddress) {
      const signature = "0x000000000000000000000000" + ownerAddress.slice(2) + "000000000000000000000000000000000000000000000000000000000000000001";
      return new SafeSignature_1.default(ownerAddress, signature);
    }
    exports.generatePreValidatedSignature = generatePreValidatedSignature;
    function isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {
      let hasPrefix;
      try {
        const rsvSig = {
          r: Buffer.from(signature.slice(2, 66), "hex"),
          s: Buffer.from(signature.slice(66, 130), "hex"),
          v: parseInt(signature.slice(130, 132), 16)
        };
        const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), "hex"), rsvSig.v, rsvSig.r, rsvSig.s);
        const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));
        hasPrefix = !(0, utils_1.sameString)(recoveredAddress, ownerAddress);
      } catch (e) {
        hasPrefix = true;
      }
      return hasPrefix;
    }
    exports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;
    var adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {
      const ETHEREUM_V_VALUES = [0, 1, 27, 28];
      const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;
      let signatureV = parseInt(signature.slice(-2), 16);
      if (!ETHEREUM_V_VALUES.includes(signatureV)) {
        throw new Error("Invalid signature");
      }
      if (signingMethod === "eth_sign") {
        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
          signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
        }
        const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);
        const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);
        if (signatureHasPrefix) {
          signatureV += 4;
        }
      }
      if (signingMethod === "eth_signTypedData") {
        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
          signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
        }
      }
      signature = signature.slice(0, -2) + signatureV.toString(16);
      return signature;
    };
    exports.adjustVInSignature = adjustVInSignature;
    async function generateSignature(ethAdapter, hash) {
      const signerAddress = await ethAdapter.getSignerAddress();
      if (!signerAddress) {
        throw new Error("EthAdapter must be initialized with a signer to use this method");
      }
      let signature = await ethAdapter.signMessage(hash);
      signature = (0, exports.adjustVInSignature)("eth_sign", signature, hash, signerAddress);
      return new SafeSignature_1.default(signerAddress, signature);
    }
    exports.generateSignature = generateSignature;
    async function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {
      const signerAddress = await ethAdapter.getSignerAddress();
      if (!signerAddress) {
        throw new Error("EthAdapter must be initialized with a signer to use this method");
      }
      let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);
      signature = (0, exports.adjustVInSignature)("eth_signTypedData", signature);
      return new SafeSignature_1.default(signerAddress, signature);
    }
    exports.generateEIP712Signature = generateEIP712Signature;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/SafeTransaction.js
var require_SafeTransaction = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/SafeTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var EthSafeTransaction = class {
      constructor(data) {
        this.signatures = /* @__PURE__ */ new Map();
        this.data = data;
      }
      addSignature(signature) {
        this.signatures.set(signature.signer.toLowerCase(), signature);
      }
      encodedSignatures() {
        const signers = Array.from(this.signatures.keys()).sort();
        const baseOffset = signers.length * 65;
        let staticParts = "";
        let dynamicParts = "";
        signers.forEach((signerAddress) => {
          const signature = this.signatures.get(signerAddress);
          staticParts += signature === null || signature === void 0 ? void 0 : signature.staticPart(
            /*baseOffset + dynamicParts.length / 2*/
          ).slice(2);
          dynamicParts += signature === null || signature === void 0 ? void 0 : signature.dynamicPart();
        });
        return "0x" + staticParts + dynamicParts;
      }
    };
    exports.default = EthSafeTransaction;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/gas.js
var require_gas = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/gas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateTxGas = void 0;
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    function estimateDataGasCosts(data) {
      const reducer = (accumulator, currentValue) => {
        if (currentValue === "0x") {
          return accumulator + 0;
        }
        if (currentValue === "00") {
          return accumulator + 4;
        }
        return accumulator + 16;
      };
      return data.match(/.{2}/g).reduce(reducer, 0);
    }
    async function estimateTxGas(safeContract, ethAdapter, to, valueInWei, data, operation) {
      let txGasEstimation = 0;
      const safeAddress = safeContract.getAddress();
      const estimateData = safeContract.encode("requiredTxGas", [
        to,
        valueInWei,
        data,
        operation
      ]);
      try {
        const estimateResponse = (await ethAdapter.estimateGas({
          to: safeAddress,
          from: safeAddress,
          data: estimateData
        })).toString();
        txGasEstimation = bignumber_1.BigNumber.from("0x" + estimateResponse.substring(138)).toNumber() + 1e4;
      } catch (error) {
      }
      if (txGasEstimation > 0) {
        const dataGasEstimation = estimateDataGasCosts(estimateData);
        let additionalGas = 1e4;
        for (let i = 0; i < 10; i++) {
          try {
            const estimateResponse = await ethAdapter.call({
              to: safeAddress,
              from: safeAddress,
              data: estimateData,
              gasPrice: 0,
              gasLimit: txGasEstimation + dataGasEstimation + additionalGas
            });
            if (estimateResponse !== "0x") {
              break;
            }
          } catch (error) {
          }
          txGasEstimation += additionalGas;
          additionalGas *= 2;
        }
        return txGasEstimation + additionalGas;
      }
      try {
        const estimateGas = await ethAdapter.estimateGas({
          to,
          from: safeAddress,
          value: valueInWei,
          data
        });
        return estimateGas;
      } catch (error) {
        if (operation === safe_core_sdk_types_1.OperationType.DelegateCall) {
          return 0;
        }
        return Promise.reject(error);
      }
    }
    exports.estimateTxGas = estimateTxGas;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/utils.js
var require_utils15 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/utils/transactions/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeMultiSendData = exports.standardizeSafeTransactionData = exports.standardizeMetaTransactionData = void 0;
    var bytes_1 = (init_lib(), __toCommonJS(lib_exports));
    var solidity_1 = (init_lib8(), __toCommonJS(lib_exports8));
    var safe_core_sdk_types_1 = require_src();
    var safe_core_sdk_utils_1 = require_src6();
    var constants_1 = require_constants5();
    var gas_1 = require_gas();
    function standardizeMetaTransactionData(tx) {
      var _a;
      const standardizedTxs = {
        ...tx,
        operation: (_a = tx.operation) !== null && _a !== void 0 ? _a : safe_core_sdk_types_1.OperationType.Call
      };
      return standardizedTxs;
    }
    exports.standardizeMetaTransactionData = standardizeMetaTransactionData;
    async function standardizeSafeTransactionData(safeContract, ethAdapter, tx) {
      var _a, _b, _c, _d;
      const standardizedTxs = {
        to: tx.to,
        value: tx.value,
        data: tx.data,
        operation: (_a = tx.operation) !== null && _a !== void 0 ? _a : safe_core_sdk_types_1.OperationType.Call,
        baseGas: (_b = tx.baseGas) !== null && _b !== void 0 ? _b : 0,
        gasPrice: (_c = tx.gasPrice) !== null && _c !== void 0 ? _c : 0,
        gasToken: tx.gasToken || constants_1.ZERO_ADDRESS,
        refundReceiver: tx.refundReceiver || constants_1.ZERO_ADDRESS,
        nonce: (_d = tx.nonce) !== null && _d !== void 0 ? _d : await safeContract.getNonce()
      };
      let safeTxGas;
      if (typeof tx.safeTxGas !== "undefined") {
        return {
          ...standardizedTxs,
          safeTxGas: tx.safeTxGas
        };
      }
      const safeVersion = await safeContract.getVersion();
      if ((0, safe_core_sdk_utils_1.hasSafeFeature)(safe_core_sdk_utils_1.SAFE_FEATURES.SAFE_TX_GAS_OPTIONAL, safeVersion) && standardizedTxs.gasPrice === 0) {
        safeTxGas = 0;
      } else {
        safeTxGas = await (0, gas_1.estimateTxGas)(safeContract, ethAdapter, standardizedTxs.to, standardizedTxs.value, standardizedTxs.data, standardizedTxs.operation);
      }
      return {
        ...standardizedTxs,
        safeTxGas
      };
    }
    exports.standardizeSafeTransactionData = standardizeSafeTransactionData;
    function encodeMetaTransaction(tx) {
      const data = (0, bytes_1.arrayify)(tx.data);
      const encoded = (0, solidity_1.pack)(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data.length, data]);
      return encoded.slice(2);
    }
    function encodeMultiSendData(txs) {
      return "0x" + txs.map((tx) => encodeMetaTransaction(tx)).join("");
    }
    exports.encodeMultiSendData = encodeMultiSendData;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/Safe.js
var require_Safe = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/Safe.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Safe_ethAdapter;
    var _Safe_contractManager;
    var _Safe_ownerManager;
    var _Safe_moduleManager;
    var _Safe_guardManager;
    var _Safe_fallbackHandlerManager;
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_types_1 = require_src();
    var safe_core_sdk_utils_1 = require_src6();
    var contractManager_1 = __importDefault(require_contractManager());
    var fallbackHandlerManager_1 = __importDefault(require_fallbackHandlerManager());
    var guardManager_1 = __importDefault(require_guardManager());
    var moduleManager_1 = __importDefault(require_moduleManager());
    var ownerManager_1 = __importDefault(require_ownerManager());
    var utils_1 = require_utils14();
    var signatures_1 = require_signatures();
    var SafeSignature_1 = __importDefault(require_SafeSignature());
    var SafeTransaction_1 = __importDefault(require_SafeTransaction());
    var utils_2 = require_utils15();
    var Safe = class _Safe {
      constructor() {
        _Safe_ethAdapter.set(this, void 0);
        _Safe_contractManager.set(this, void 0);
        _Safe_ownerManager.set(this, void 0);
        _Safe_moduleManager.set(this, void 0);
        _Safe_guardManager.set(this, void 0);
        _Safe_fallbackHandlerManager.set(this, void 0);
      }
      /**
       * Creates an instance of the Safe Core SDK.
       * @param config - Ethers Safe configuration
       * @returns The Safe Core SDK instance
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      static async create({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {
        const safeSdk = new _Safe();
        await safeSdk.init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks });
        return safeSdk;
      }
      /**
       * Initializes the Safe Core SDK instance.
       * @param config - Safe configuration
       * @throws "Signer must be connected to a provider"
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      async init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {
        __classPrivateFieldSet(this, _Safe_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({
          ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          safeAddress,
          isL1SafeMasterCopy,
          contractNetworks
        }), "f");
        __classPrivateFieldSet(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
        __classPrivateFieldSet(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract), "f");
      }
      /**
       * Returns a new instance of the Safe Core SDK.
       * @param config - Connect Safe configuration
       * @throws "SafeProxy contract is not deployed on the current network"
       * @throws "MultiSend contract is not deployed on the current network"
       * @throws "MultiSendCallOnly contract is not deployed on the current network"
       */
      async connect({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {
        return await _Safe.create({
          ethAdapter: ethAdapter || __classPrivateFieldGet(this, _Safe_ethAdapter, "f"),
          safeAddress: safeAddress || this.getAddress(),
          isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet(this, _Safe_contractManager, "f").isL1SafeMasterCopy,
          contractNetworks: contractNetworks || __classPrivateFieldGet(this, _Safe_contractManager, "f").contractNetworks
        });
      }
      /**
       * Returns the address of the current SafeProxy contract.
       *
       * @returns The address of the SafeProxy contract
       */
      getAddress() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getAddress();
      }
      /**
       * Returns the ContractManager
       *
       * @returns The current ContractManager
       * */
      getContractManager() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f");
      }
      /**
       * Returns the current EthAdapter.
       *
       * @returns The current EthAdapter
       */
      getEthAdapter() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f");
      }
      /**
       * Returns the address of the MultiSend contract.
       *
       * @returns The address of the MultiSend contract
       */
      getMultiSendAddress() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendContract.getAddress();
      }
      /**
       * Returns the address of the MultiSendCallOnly contract.
       *
       * @returns The address of the MultiSendCallOnly contract
       */
      getMultiSendCallOnlyAddress() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendCallOnlyContract.getAddress();
      }
      /**
       * Returns the Safe Master Copy contract version.
       *
       * @returns The Safe Master Copy contract version
       */
      async getContractVersion() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getVersion();
      }
      /**
       * Returns the list of Safe owner accounts.
       *
       * @returns The list of owners
       */
      async getOwners() {
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").getOwners();
      }
      /**
       * Returns the Safe nonce.
       *
       * @returns The Safe nonce
       */
      async getNonce() {
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getNonce();
      }
      /**
       * Returns the Safe threshold.
       *
       * @returns The Safe threshold
       */
      async getThreshold() {
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").getThreshold();
      }
      /**
       * Returns the chainId of the connected network.
       *
       * @returns The chainId of the connected network
       */
      async getChainId() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getChainId();
      }
      /**
       * Returns the ETH balance of the Safe.
       *
       * @returns The ETH balance of the Safe
       */
      async getBalance() {
        return __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getBalance(this.getAddress());
      }
      /**
       * Returns the address of the FallbackHandler contract.
       *
       * @returns The address of the FallbackHandler contract
       */
      getFallbackHandler() {
        return __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").getFallbackHandler();
      }
      /**
       * Returns the enabled Safe guard or 0x address if no guards are enabled.
       *
       * @returns The address of the enabled Safe guard
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async getGuard() {
        return __classPrivateFieldGet(this, _Safe_guardManager, "f").getGuard();
      }
      /**
       * Returns the list of addresses of all the enabled Safe modules.
       *
       * @returns The list of addresses of all the enabled Safe modules
       */
      async getModules() {
        return __classPrivateFieldGet(this, _Safe_moduleManager, "f").getModules();
      }
      /**
       * Checks if a specific Safe module is enabled for the current Safe.
       *
       * @param moduleAddress - The desired module address
       * @returns TRUE if the module is enabled
       */
      async isModuleEnabled(moduleAddress) {
        return __classPrivateFieldGet(this, _Safe_moduleManager, "f").isModuleEnabled(moduleAddress);
      }
      /**
       * Checks if a specific address is an owner of the current Safe.
       *
       * @param ownerAddress - The account address
       * @returns TRUE if the account is an owner
       */
      async isOwner(ownerAddress) {
        return __classPrivateFieldGet(this, _Safe_ownerManager, "f").isOwner(ownerAddress);
      }
      /**
       * Returns a Safe transaction ready to be signed by the owners.
       *
       * @param createTransactionProps - The createTransaction props
       * @returns The Safe transaction
       * @throws "Invalid empty array of transactions"
       */
      async createTransaction({ safeTransactionData, onlyCalls = false, options }) {
        if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {
          throw new Error("Invalid empty array of transactions");
        }
        let newTransaction;
        if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {
          const multiSendContract = onlyCalls ? __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendCallOnlyContract : __classPrivateFieldGet(this, _Safe_contractManager, "f").multiSendContract;
          const multiSendData = (0, utils_2.encodeMultiSendData)(safeTransactionData.map(utils_2.standardizeMetaTransactionData));
          const multiSendTransaction = {
            ...options,
            to: multiSendContract.getAddress(),
            value: "0",
            data: multiSendContract.encode("multiSend", [multiSendData]),
            operation: safe_core_sdk_types_1.OperationType.DelegateCall
          };
          newTransaction = multiSendTransaction;
        } else {
          newTransaction = (0, utils_1.isMetaTransactionArray)(safeTransactionData) ? { ...options, ...safeTransactionData[0] } : safeTransactionData;
        }
        const standardizedTransaction = await (0, utils_2.standardizeSafeTransactionData)(__classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract, __classPrivateFieldGet(this, _Safe_ethAdapter, "f"), newTransaction);
        return new SafeTransaction_1.default(standardizedTransaction);
      }
      /**
       * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.
       *
       * @param nonce - The nonce of the transaction/s that are going to be rejected
       * @returns The Safe transaction that invalidates the pending Safe transaction/s
       */
      async createRejectionTransaction(nonce) {
        const safeTransactionData = {
          to: this.getAddress(),
          nonce,
          value: "0",
          data: "0x",
          safeTxGas: 0
        };
        return this.createTransaction({ safeTransactionData });
      }
      /**
       * Copies a Safe transaction
       *
       * @param safeTransaction - The Safe transaction
       * @returns The new Safe transaction
       */
      async copyTransaction(safeTransaction) {
        const signedSafeTransaction = await this.createTransaction({
          safeTransactionData: safeTransaction.data
        });
        safeTransaction.signatures.forEach((signature) => {
          signedSafeTransaction.addSignature(signature);
        });
        return signedSafeTransaction;
      }
      /**
       * Returns the transaction hash of a Safe transaction.
       *
       * @param safeTransaction - The Safe transaction
       * @returns The transaction hash of the Safe transaction
       */
      async getTransactionHash(safeTransaction) {
        const safeTransactionData = safeTransaction.data;
        const txHash = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.getTransactionHash(safeTransactionData);
        return txHash;
      }
      /**
       * Signs a hash using the current signer account.
       *
       * @param hash - The hash to sign
       * @returns The Safe signature
       */
      async signTransactionHash(hash) {
        return (0, signatures_1.generateSignature)(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), hash);
      }
      /**
       * Signs a transaction according to the EIP-712 using the current signer account.
       *
       * @param safeTransaction - The Safe transaction to be signed
       * @param methodVersion - EIP-712 version. Optional
       * @returns The Safe signature
       */
      async signTypedData(safeTransaction, methodVersion) {
        const safeTransactionEIP712Args = {
          safeAddress: this.getAddress(),
          safeVersion: await this.getContractVersion(),
          chainId: await this.getEthAdapter().getChainId(),
          safeTransactionData: safeTransaction.data
        };
        return (0, signatures_1.generateEIP712Signature)(__classPrivateFieldGet(this, _Safe_ethAdapter, "f"), safeTransactionEIP712Args, methodVersion);
      }
      /**
       * Adds the signature of the current signer to the Safe transaction object.
       *
       * @param safeTransaction - The Safe transaction to be signed
       * @param signingMethod - Method followed to sign a transaction. Optional. Default value is "eth_sign"
       * @returns The signed Safe transaction
       * @throws "Transactions can only be signed by Safe owners"
       */
      async signTransaction(safeTransaction, signingMethod = "eth_signTypedData_v4") {
        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const addressIsOwner = owners.find((owner) => signerAddress && (0, utils_1.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
          throw new Error("Transactions can only be signed by Safe owners");
        }
        let signature;
        if (signingMethod === "eth_signTypedData_v4") {
          signature = await this.signTypedData(transaction, "v4");
        } else if (signingMethod === "eth_signTypedData_v3") {
          signature = await this.signTypedData(transaction, "v3");
        } else if (signingMethod === "eth_signTypedData") {
          signature = await this.signTypedData(transaction);
        } else {
          const safeVersion = await this.getContractVersion();
          if (!(0, safe_core_sdk_utils_1.hasSafeFeature)(safe_core_sdk_utils_1.SAFE_FEATURES.ETH_SIGN, safeVersion)) {
            throw new Error("eth_sign is only supported by Safes >= v1.1.0");
          }
          const txHash = await this.getTransactionHash(transaction);
          signature = await this.signTransactionHash(txHash);
        }
        const signedSafeTransaction = await this.createTransaction({
          safeTransactionData: transaction.data
        });
        transaction.signatures.forEach((signature2) => {
          signedSafeTransaction.addSignature(signature2);
        });
        signedSafeTransaction.addSignature(signature);
        return signedSafeTransaction;
      }
      /**
       * Approves on-chain a hash using the current signer account.
       *
       * @param hash - The hash to approve
       * @param options - The Safe transaction execution options. Optional
       * @returns The Safe transaction response
       * @throws "Transaction hashes can only be approved by Safe owners"
       * @throws "Cannot specify gas and gasLimit together in transaction options"
       */
      async approveTransactionHash(hash, options) {
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const addressIsOwner = owners.find((owner) => signerAddress && (0, utils_1.sameString)(owner, signerAddress));
        if (!addressIsOwner) {
          throw new Error("Transaction hashes can only be approved by Safe owners");
        }
        if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        return __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.approveHash(hash, {
          from: signerAddress,
          ...options
        });
      }
      /**
       * Returns a list of owners who have approved a specific Safe transaction.
       *
       * @param txHash - The Safe transaction hash
       * @returns The list of owners
       */
      async getOwnersWhoApprovedTx(txHash) {
        const owners = await this.getOwners();
        let ownersWhoApproved = [];
        for (const owner of owners) {
          const approved = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.approvedHashes(owner, txHash);
          if (approved.gt(0)) {
            ownersWhoApproved.push(owner);
          }
        }
        return ownersWhoApproved;
      }
      /**
       * Returns the Safe transaction to enable the fallback handler.
       *
       * @param address - The new fallback handler address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid fallback handler address provided"
       * @throws "Fallback handler provided is already enabled"
       * @throws "Current version of the Safe does not support the fallback handler functionality"
       */
      async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").encodeEnableFallbackHandlerData(fallbackHandlerAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable the fallback handler.
       *
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "There is no fallback handler enabled yet"
       * @throws "Current version of the Safe does not support the fallback handler functionality"
       */
      async createDisableFallbackHandlerTx(options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, "f").encodeDisableFallbackHandlerData(),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to enable a Safe guard.
       *
       * @param guardAddress - The desired guard address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid guard address provided"
       * @throws "Guard provided is already enabled"
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async createEnableGuardTx(guardAddress, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_guardManager, "f").encodeEnableGuardData(guardAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable a Safe guard.
       *
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "There is no guard enabled yet"
       * @throws "Current version of the Safe does not support Safe transaction guards functionality"
       */
      async createDisableGuardTx(options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_guardManager, "f").encodeDisableGuardData(),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to enable a Safe module.
       *
       * @param moduleAddress - The desired module address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid module address provided"
       * @throws "Module provided is already enabled"
       */
      async createEnableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_moduleManager, "f").encodeEnableModuleData(moduleAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to disable a Safe module.
       *
       * @param moduleAddress - The desired module address
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid module address provided"
       * @throws "Module provided is not enabled already"
       */
      async createDisableModuleTx(moduleAddress, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_moduleManager, "f").encodeDisableModuleData(moduleAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to add an owner and optionally change the threshold.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid owner address provided"
       * @throws "Address provided is already an owner"
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createAddOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeAddOwnerWithThresholdData(ownerAddress, threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to remove an owner and optionally change the threshold.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid owner address provided"
       * @throws "Address provided is not an owner"
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createRemoveOwnerTx({ ownerAddress, threshold }, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeRemoveOwnerData(ownerAddress, threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to replace an owner of the Safe with a new one.
       *
       * @param params - The transaction params
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Invalid new owner address provided"
       * @throws "Invalid old owner address provided"
       * @throws "New address provided is already an owner"
       * @throws "Old address provided is not an owner"
       */
      async createSwapOwnerTx({ oldOwnerAddress, newOwnerAddress }, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Returns the Safe transaction to change the threshold.
       *
       * @param threshold - The new threshold
       * @param options - The transaction optional properties
       * @returns The Safe transaction ready to be signed
       * @throws "Threshold needs to be greater than 0"
       * @throws "Threshold cannot exceed owner count"
       */
      async createChangeThresholdTx(threshold, options) {
        const safeTransactionData = {
          to: this.getAddress(),
          value: "0",
          data: await __classPrivateFieldGet(this, _Safe_ownerManager, "f").encodeChangeThresholdData(threshold),
          ...options
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        return safeTransaction;
      }
      /**
       * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction
       *
       * @param serviceTransactionResponse - The transaction to convert
       * @returns The converted transaction with type SafeTransaction
       */
      async toSafeTransactionType(serviceTransactionResponse) {
        var _a;
        const safeTransactionData = {
          to: serviceTransactionResponse.to,
          value: serviceTransactionResponse.value,
          data: serviceTransactionResponse.data || "0x",
          operation: serviceTransactionResponse.operation,
          safeTxGas: serviceTransactionResponse.safeTxGas,
          baseGas: serviceTransactionResponse.baseGas,
          gasPrice: Number(serviceTransactionResponse.gasPrice),
          gasToken: serviceTransactionResponse.gasToken,
          refundReceiver: serviceTransactionResponse.refundReceiver,
          nonce: serviceTransactionResponse.nonce
        };
        const safeTransaction = await this.createTransaction({ safeTransactionData });
        (_a = serviceTransactionResponse.confirmations) === null || _a === void 0 ? void 0 : _a.map((confirmation) => {
          const signature = new SafeSignature_1.default(confirmation.owner, confirmation.signature);
          safeTransaction.addSignature(signature);
        });
        return safeTransaction;
      }
      /**
       * Checks if a Safe transaction can be executed successfully with no errors.
       *
       * @param safeTransaction - The Safe transaction to check
       * @param options - The Safe transaction execution options. Optional
       * @returns TRUE if the Safe transaction can be executed successfully with no errors
       */
      async isValidTransaction(safeTransaction, options) {
        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
          signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        if (owners.includes(signerAddress)) {
          signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));
        }
        const isTxValid = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.isValidTransaction(signedSafeTransaction, {
          from: signerAddress,
          ...options
        });
        return isTxValid;
      }
      /**
       * Executes a Safe transaction.
       *
       * @param safeTransaction - The Safe transaction to execute
       * @param options - The Safe transaction execution options. Optional
       * @returns The Safe transaction response
       * @throws "No signer provided"
       * @throws "There are X signatures missing"
       * @throws "Cannot specify gas and gasLimit together in transaction options"
       */
      async executeTransaction(safeTransaction, options) {
        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;
        const signedSafeTransaction = await this.copyTransaction(transaction);
        const txHash = await this.getTransactionHash(signedSafeTransaction);
        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);
        for (const owner of ownersWhoApprovedTx) {
          signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));
        }
        const owners = await this.getOwners();
        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, "f").getSignerAddress();
        if (signerAddress && owners.includes(signerAddress)) {
          signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));
        }
        const threshold = await this.getThreshold();
        if (threshold > signedSafeTransaction.signatures.size) {
          const signaturesMissing = threshold - signedSafeTransaction.signatures.size;
          throw new Error(`There ${signaturesMissing > 1 ? "are" : "is"} ${signaturesMissing} signature${signaturesMissing > 1 ? "s" : ""} missing`);
        }
        const value = bignumber_1.BigNumber.from(signedSafeTransaction.data.value);
        if (!value.isZero()) {
          const balance = await this.getBalance();
          if (value.gt(bignumber_1.BigNumber.from(balance))) {
            throw new Error("Not enough Ether funds");
          }
        }
        if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        const txResponse = await __classPrivateFieldGet(this, _Safe_contractManager, "f").safeContract.execTransaction(signedSafeTransaction, {
          from: signerAddress,
          ...options
        });
        return txResponse;
      }
    };
    _Safe_ethAdapter = /* @__PURE__ */ new WeakMap(), _Safe_contractManager = /* @__PURE__ */ new WeakMap(), _Safe_ownerManager = /* @__PURE__ */ new WeakMap(), _Safe_moduleManager = /* @__PURE__ */ new WeakMap(), _Safe_guardManager = /* @__PURE__ */ new WeakMap(), _Safe_fallbackHandlerManager = /* @__PURE__ */ new WeakMap();
    exports.default = Safe;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/lrucache.js
var require_lrucache3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/lrucache.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/parse-options.js
var require_parse_options3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/parse-options.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/constants.js
var require_constants7 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/constants.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/debug.js
var require_debug3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/debug.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/re.js
var require_re3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/re.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants7();
    var debug = require_debug3();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/identifiers.js
var require_identifiers3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/internal/identifiers.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/semver.js
var require_semver3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/semver.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var debug = require_debug3();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants7();
    var { safeRe: re, t } = require_re3();
    var parseOptions = require_parse_options3();
    var { compareIdentifiers } = require_identifiers3();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/compare.js
var require_compare3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/compare.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SemVer = require_semver3();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/eq.js
var require_eq3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/eq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/neq.js
var require_neq3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/neq.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/gt.js
var require_gt3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/gt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/gte.js
var require_gte3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/gte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/lt.js
var require_lt3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/lt.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/lte.js
var require_lte3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/lte.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare3();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/cmp.js
var require_cmp3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/cmp.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var eq = require_eq3();
    var neq = require_neq3();
    var gt = require_gt3();
    var gte = require_gte3();
    var lt = require_lt3();
    var lte = require_lte3();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/comparator.js
var require_comparator3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/comparator.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options3();
    var { safeRe: re, t } = require_re3();
    var cmp = require_cmp3();
    var debug = require_debug3();
    var SemVer = require_semver3();
    var Range = require_range3();
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/range.js
var require_range3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/classes/range.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache3();
    var cache = new LRU();
    var parseOptions = require_parse_options3();
    var Comparator = require_comparator3();
    var debug = require_debug3();
    var SemVer = require_semver3();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re3();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants7();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/satisfies.js
var require_satisfies3 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/node_modules/semver/functions/satisfies.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Range = require_range3();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/zksync-web3/build/src/types.js
var require_types5 = __commonJS({
  "node_modules/zksync-web3/build/src/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNonceOrdering = exports.AccountAbstractionVersion = exports.TransactionStatus = exports.PriorityOpTree = exports.PriorityQueueType = exports.Network = void 0;
    var Network;
    (function(Network2) {
      Network2[Network2["Mainnet"] = 1] = "Mainnet";
      Network2[Network2["Ropsten"] = 3] = "Ropsten";
      Network2[Network2["Rinkeby"] = 4] = "Rinkeby";
      Network2[Network2["Goerli"] = 5] = "Goerli";
      Network2[Network2["Localhost"] = 9] = "Localhost";
    })(Network = exports.Network || (exports.Network = {}));
    var PriorityQueueType;
    (function(PriorityQueueType2) {
      PriorityQueueType2[PriorityQueueType2["Deque"] = 0] = "Deque";
      PriorityQueueType2[PriorityQueueType2["HeapBuffer"] = 1] = "HeapBuffer";
      PriorityQueueType2[PriorityQueueType2["Heap"] = 2] = "Heap";
    })(PriorityQueueType = exports.PriorityQueueType || (exports.PriorityQueueType = {}));
    var PriorityOpTree;
    (function(PriorityOpTree2) {
      PriorityOpTree2[PriorityOpTree2["Full"] = 0] = "Full";
      PriorityOpTree2[PriorityOpTree2["Rollup"] = 1] = "Rollup";
    })(PriorityOpTree = exports.PriorityOpTree || (exports.PriorityOpTree = {}));
    var TransactionStatus;
    (function(TransactionStatus2) {
      TransactionStatus2["NotFound"] = "not-found";
      TransactionStatus2["Processing"] = "processing";
      TransactionStatus2["Committed"] = "committed";
      TransactionStatus2["Finalized"] = "finalized";
    })(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
    var AccountAbstractionVersion;
    (function(AccountAbstractionVersion2) {
      AccountAbstractionVersion2[AccountAbstractionVersion2["None"] = 0] = "None";
      AccountAbstractionVersion2[AccountAbstractionVersion2["Version1"] = 1] = "Version1";
    })(AccountAbstractionVersion = exports.AccountAbstractionVersion || (exports.AccountAbstractionVersion = {}));
    var AccountNonceOrdering;
    (function(AccountNonceOrdering2) {
      AccountNonceOrdering2[AccountNonceOrdering2["Sequential"] = 0] = "Sequential";
      AccountNonceOrdering2[AccountNonceOrdering2["Arbitrary"] = 1] = "Arbitrary";
    })(AccountNonceOrdering = exports.AccountNonceOrdering || (exports.AccountNonceOrdering = {}));
  }
});

// node_modules/zksync-web3/build/typechain/IZkSyncFactory.js
var require_IZkSyncFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IZkSyncFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IZkSyncFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IZkSyncFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IZkSyncFactory = IZkSyncFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "commitment",
            type: "bytes32"
          }
        ],
        name: "BlockCommit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "blockHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "commitment",
            type: "bytes32"
          }
        ],
        name: "BlockExecution",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksCommitted",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksVerified",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalBlocksExecuted",
            type: "uint256"
          }
        ],
        name: "BlocksRevert",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "previousLastVerifiedBlock",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "currentLastVerifiedBlock",
            type: "uint256"
          }
        ],
        name: "BlocksVerification",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "CancelUpgradeProposal",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "EthWithdrawalFinalized",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "proposalSalt",
            type: "bytes32"
          }
        ],
        name: "ExecuteUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "Freeze",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bool",
            name: "isPorterAvailable",
            type: "bool"
          }
        ],
        name: "IsPorterAvailableStatusUpdate",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldGovernor",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newGovernor",
            type: "address"
          }
        ],
        name: "NewGovernor",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousBytecodeHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "NewL2BootloaderBytecodeHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "previousBytecodeHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "newBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "NewL2DefaultAccountBytecodeHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldPendingGovernor",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newPendingGovernor",
            type: "address"
          }
        ],
        name: "NewPendingGovernor",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "txId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint64",
            name: "expirationTimestamp",
            type: "uint64"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "txType",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "from",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "to",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "gasPerPubdataByteLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymaster",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "value",
                type: "uint256"
              },
              {
                internalType: "uint256[4]",
                name: "reserved",
                type: "uint256[4]"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
              },
              {
                internalType: "uint256[]",
                name: "factoryDeps",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "paymasterInput",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "reservedDynamic",
                type: "bytes"
              }
            ],
            indexed: false,
            internalType: "struct IMailbox.L2CanonicalTransaction",
            name: "transaction",
            type: "tuple"
          },
          {
            indexed: false,
            internalType: "bytes[]",
            name: "factoryDeps",
            type: "bytes[]"
          }
        ],
        name: "NewPriorityRequest",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "oldPriorityTxMaxGasLimit",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newPriorityTxMaxGasLimit",
            type: "uint256"
          }
        ],
        name: "NewPriorityTxMaxGasLimit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "oldVerifier",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newVerifier",
            type: "address"
          }
        ],
        name: "NewVerifier",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct VerifierParams",
            name: "oldVerifierParams",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            indexed: false,
            internalType: "struct VerifierParams",
            name: "newVerifierParams",
            type: "tuple"
          }
        ],
        name: "NewVerifierParams",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "ProposeShadowUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            indexed: false,
            internalType: "struct Diamond.DiamondCutData",
            name: "diamondCut",
            type: "tuple"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "bytes32",
            name: "proposalSalt",
            type: "bytes32"
          }
        ],
        name: "ProposeTransparentUpgrade",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "proposalId",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "proposalHash",
            type: "bytes32"
          }
        ],
        name: "SecurityCouncilUpgradeApprove",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [],
        name: "Unfreeze",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "validatorAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "isActive",
            type: "bool"
          }
        ],
        name: "ValidatorStatusUpdate",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_proposedUpgradeHash",
            type: "bytes32"
          }
        ],
        name: "cancelUpgradeProposal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo",
            name: "_lastCommittedBlockData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "timestamp",
                type: "uint64"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "newStateRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes",
                name: "initialStorageChanges",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "repeatedStorageChanges",
                type: "bytes"
              },
              {
                internalType: "bytes",
                name: "l2Logs",
                type: "bytes"
              },
              {
                internalType: "bytes[]",
                name: "l2ArbitraryLengthMessages",
                type: "bytes[]"
              },
              {
                internalType: "bytes[]",
                name: "factoryDeps",
                type: "bytes[]"
              }
            ],
            internalType: "struct IExecutor.CommitBlockInfo[]",
            name: "_newBlocksData",
            type: "tuple[]"
          }
        ],
        name: "commitBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo[]",
            name: "_blocksData",
            type: "tuple[]"
          }
        ],
        name: "executeBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "bytes32",
            name: "_proposalSalt",
            type: "bytes32"
          }
        ],
        name: "executeUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "facetAddress",
        outputs: [
          {
            internalType: "address",
            name: "facet",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facetAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "facets",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "facetFunctionSelectors",
        outputs: [
          {
            internalType: "bytes4[]",
            name: "",
            type: "bytes4[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "facets",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "addr",
                type: "address"
              },
              {
                internalType: "bytes4[]",
                name: "selectors",
                type: "bytes4[]"
              }
            ],
            internalType: "struct IGetters.Facet[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "_message",
            type: "bytes"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "finalizeEthWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "freezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getCurrentProposalId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getFirstUnprocessedPriorityTx",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getGovernor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getL2BootloaderBytecodeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getL2DefaultAccountBytecodeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPendingGovernor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPriorityQueueSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getProposedUpgradeHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getProposedUpgradeTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSecurityCouncil",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksCommitted",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksExecuted",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalBlocksVerified",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTotalPriorityTxs",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUpgradeProposalState",
        outputs: [
          {
            internalType: "enum UpgradeState",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVerifier",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVerifierParams",
        outputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            internalType: "struct VerifierParams",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getpriorityTxMaxGasLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isApprovedBySecurityCouncil",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isDiamondStorageFrozen",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          }
        ],
        name: "isEthWithdrawalFinalized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_facet",
            type: "address"
          }
        ],
        name: "isFacetFreezable",
        outputs: [
          {
            internalType: "bool",
            name: "isFreezable",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "_selector",
            type: "bytes4"
          }
        ],
        name: "isFunctionFreezable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_address",
            type: "address"
          }
        ],
        name: "isValidator",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          }
        ],
        name: "l2LogsRootHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_gasPrice",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasPerPubdataByteLimit",
            type: "uint256"
          }
        ],
        name: "l2TransactionBaseCost",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "priorityQueueFrontOperation",
        outputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "canonicalTxHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "expirationTimestamp",
                type: "uint64"
              },
              {
                internalType: "uint192",
                name: "layer2Tip",
                type: "uint192"
              }
            ],
            internalType: "struct PriorityOperation",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_proposalHash",
            type: "bytes32"
          },
          {
            internalType: "uint40",
            name: "_proposalId",
            type: "uint40"
          }
        ],
        name: "proposeShadowUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "uint40",
            name: "_proposalId",
            type: "uint40"
          }
        ],
        name: "proposeTransparentUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo",
            name: "_prevBlock",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "uint64",
                name: "blockNumber",
                type: "uint64"
              },
              {
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
              },
              {
                internalType: "uint64",
                name: "indexRepeatedStorageChanges",
                type: "uint64"
              },
              {
                internalType: "uint256",
                name: "numberOfLayer1Txs",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "priorityOperationsHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "l2LogsTreeRoot",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "timestamp",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
              }
            ],
            internalType: "struct IExecutor.StoredBlockInfo[]",
            name: "_committedBlocks",
            type: "tuple[]"
          },
          {
            components: [
              {
                internalType: "uint256[]",
                name: "recursiveAggregationInput",
                type: "uint256[]"
              },
              {
                internalType: "uint256[]",
                name: "serializedProof",
                type: "uint256[]"
              }
            ],
            internalType: "struct IExecutor.ProofInput",
            name: "_proof",
            type: "tuple"
          }
        ],
        name: "proveBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2TxHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          },
          {
            internalType: "enum TxStatus",
            name: "_status",
            type: "uint8"
          }
        ],
        name: "proveL1ToL2TransactionStatus",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint8",
                name: "l2ShardId",
                type: "uint8"
              },
              {
                internalType: "bool",
                name: "isService",
                type: "bool"
              },
              {
                internalType: "uint16",
                name: "txNumberInBlock",
                type: "uint16"
              },
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bytes32",
                name: "key",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "value",
                type: "bytes32"
              }
            ],
            internalType: "struct L2Log",
            name: "_log",
            type: "tuple"
          },
          {
            internalType: "bytes32[]",
            name: "_proof",
            type: "bytes32[]"
          }
        ],
        name: "proveL2LogInclusion",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_index",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "uint16",
                name: "txNumberInBlock",
                type: "uint16"
              },
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "data",
                type: "bytes"
              }
            ],
            internalType: "struct L2Message",
            name: "_message",
            type: "tuple"
          },
          {
            internalType: "bytes32[]",
            name: "_proof",
            type: "bytes32[]"
          }
        ],
        name: "proveL2MessageInclusion",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_contractL2",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_l2Value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_calldata",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "_l2GasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2GasPerPubdataByteLimit",
            type: "uint256"
          },
          {
            internalType: "bytes[]",
            name: "_factoryDeps",
            type: "bytes[]"
          },
          {
            internalType: "address",
            name: "_refundRecipient",
            type: "address"
          }
        ],
        name: "requestL2Transaction",
        outputs: [
          {
            internalType: "bytes32",
            name: "canonicalTxHash",
            type: "bytes32"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_newLastBlock",
            type: "uint256"
          }
        ],
        name: "revertBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_upgradeProposalHash",
            type: "bytes32"
          }
        ],
        name: "securityCouncilUpgradeApprove",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2BootloaderBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "setL2BootloaderBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_l2DefaultAccountBytecodeHash",
            type: "bytes32"
          }
        ],
        name: "setL2DefaultAccountBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newPendingGovernor",
            type: "address"
          }
        ],
        name: "setPendingGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "_zkPorterIsAvailable",
            type: "bool"
          }
        ],
        name: "setPorterAvailability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_newPriorityTxMaxGasLimit",
            type: "uint256"
          }
        ],
        name: "setPriorityTxMaxGasLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_validator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "_active",
            type: "bool"
          }
        ],
        name: "setValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract Verifier",
            name: "_newVerifier",
            type: "address"
          }
        ],
        name: "setVerifier",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "recursionNodeLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionLeafLevelVkHash",
                type: "bytes32"
              },
              {
                internalType: "bytes32",
                name: "recursionCircuitsSetVksHash",
                type: "bytes32"
              }
            ],
            internalType: "struct VerifierParams",
            name: "_newVerifierParams",
            type: "tuple"
          }
        ],
        name: "setVerifierParams",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_blockNumber",
            type: "uint256"
          }
        ],
        name: "storedBlockHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "unfreezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  {
                    internalType: "address",
                    name: "facet",
                    type: "address"
                  },
                  {
                    internalType: "enum Diamond.Action",
                    name: "action",
                    type: "uint8"
                  },
                  {
                    internalType: "bool",
                    name: "isFreezable",
                    type: "bool"
                  },
                  {
                    internalType: "bytes4[]",
                    name: "selectors",
                    type: "bytes4[]"
                  }
                ],
                internalType: "struct Diamond.FacetCut[]",
                name: "facetCuts",
                type: "tuple[]"
              },
              {
                internalType: "address",
                name: "initAddress",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "initCalldata",
                type: "bytes"
              }
            ],
            internalType: "struct Diamond.DiamondCutData",
            name: "_diamondCut",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "_proposalId",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "_salt",
            type: "bytes32"
          }
        ],
        name: "upgradeProposalHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "pure",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js
var require_IERC20MetadataFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IERC20MetadataFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IERC20MetadataFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IERC20MetadataFactory = IERC20MetadataFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js
var require_IL1BridgeFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IL1BridgeFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IL1BridgeFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IL1BridgeFactory = IL1BridgeFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "ClaimedFailedDeposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "DepositInitiated",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "l1Token",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "WithdrawalFinalized",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_depositSender",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_l2TxHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "claimFailedDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l2Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2TxGasLimit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2TxGasPerPubdataByte",
            type: "uint256"
          }
        ],
        name: "deposit",
        outputs: [
          {
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "_l2TxNumberInBlock",
            type: "uint16"
          },
          {
            internalType: "bytes",
            name: "_message",
            type: "bytes"
          },
          {
            internalType: "bytes32[]",
            name: "_merkleProof",
            type: "bytes32[]"
          }
        ],
        name: "finalizeWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_l2BlockNumber",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_l2MessageIndex",
            type: "uint256"
          }
        ],
        name: "isWithdrawalFinalized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "l2TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js
var require_IL2BridgeFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IL2BridgeFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IL2BridgeFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IL2BridgeFactory = IL2BridgeFactory;
    var _abi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l2Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "finalizeDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Bridge",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_l2TokenProxyBytecodeHash",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "_governor",
            type: "address"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "l1Bridge",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l2Token",
            type: "address"
          }
        ],
        name: "l1TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "l2TokenAddress",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          },
          {
            internalType: "address",
            name: "_l2Token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IAllowListFactory.js
var require_IAllowListFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IAllowListFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IAllowListFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IAllowListFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IAllowListFactory = IAllowListFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            indexed: false,
            internalType: "enum IAllowList.AccessMode",
            name: "previousMode",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "enum IAllowList.AccessMode",
            name: "newMode",
            type: "uint8"
          }
        ],
        name: "UpdateAccessMode",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "caller",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            indexed: true,
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            indexed: false,
            internalType: "bool",
            name: "status",
            type: "bool"
          }
        ],
        name: "UpdateCallPermission",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          }
        ],
        name: "canCall",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_target",
            type: "address"
          }
        ],
        name: "getAccessMode",
        outputs: [
          {
            internalType: "enum IAllowList.AccessMode",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          }
        ],
        name: "getTokenDepositLimitData",
        outputs: [
          {
            components: [
              {
                internalType: "bool",
                name: "depositLimitation",
                type: "bool"
              },
              {
                internalType: "uint256",
                name: "depositCap",
                type: "uint256"
              }
            ],
            internalType: "struct IAllowList.Deposit",
            name: "",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          }
        ],
        name: "hasSpecialAccessToCall",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "enum IAllowList.AccessMode",
            name: "_accessMode",
            type: "uint8"
          }
        ],
        name: "setAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_targets",
            type: "address[]"
          },
          {
            internalType: "enum IAllowList.AccessMode[]",
            name: "_accessMode",
            type: "uint8[]"
          }
        ],
        name: "setBatchAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_callers",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "_targets",
            type: "address[]"
          },
          {
            internalType: "bytes4[]",
            name: "_functionSigs",
            type: "bytes4[]"
          },
          {
            internalType: "bool[]",
            name: "_enables",
            type: "bool[]"
          }
        ],
        name: "setBatchPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Token",
            type: "address"
          },
          {
            internalType: "bool",
            name: "_depositLimitation",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "_depositCap",
            type: "uint256"
          }
        ],
        name: "setDepositLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_caller",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "_functionSig",
            type: "bytes4"
          },
          {
            internalType: "bool",
            name: "_enable",
            type: "bool"
          }
        ],
        name: "setPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/IEthTokenFactory.js
var require_IEthTokenFactory = __commonJS({
  "node_modules/zksync-web3/build/typechain/IEthTokenFactory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEthTokenFactory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var IEthTokenFactory = class {
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.IEthTokenFactory = IEthTokenFactory;
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Mint",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "Withdrawal",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          }
        ],
        name: "transferFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_l1Receiver",
            type: "address"
          }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
  }
});

// node_modules/zksync-web3/build/typechain/index.js
var require_typechain = __commonJS({
  "node_modules/zksync-web3/build/typechain/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEthTokenFactory = exports.IAllowListFactory = exports.IL2BridgeFactory = exports.IL1BridgeFactory = exports.IERC20MetadataFactory = exports.IZkSyncFactory = void 0;
    var IZkSyncFactory_1 = require_IZkSyncFactory();
    Object.defineProperty(exports, "IZkSyncFactory", { enumerable: true, get: function() {
      return IZkSyncFactory_1.IZkSyncFactory;
    } });
    var IERC20MetadataFactory_1 = require_IERC20MetadataFactory();
    Object.defineProperty(exports, "IERC20MetadataFactory", { enumerable: true, get: function() {
      return IERC20MetadataFactory_1.IERC20MetadataFactory;
    } });
    var IL1BridgeFactory_1 = require_IL1BridgeFactory();
    Object.defineProperty(exports, "IL1BridgeFactory", { enumerable: true, get: function() {
      return IL1BridgeFactory_1.IL1BridgeFactory;
    } });
    var IL2BridgeFactory_1 = require_IL2BridgeFactory();
    Object.defineProperty(exports, "IL2BridgeFactory", { enumerable: true, get: function() {
      return IL2BridgeFactory_1.IL2BridgeFactory;
    } });
    var IAllowListFactory_1 = require_IAllowListFactory();
    Object.defineProperty(exports, "IAllowListFactory", { enumerable: true, get: function() {
      return IAllowListFactory_1.IAllowListFactory;
    } });
    var IEthTokenFactory_1 = require_IEthTokenFactory();
    Object.defineProperty(exports, "IEthTokenFactory", { enumerable: true, get: function() {
      return IEthTokenFactory_1.IEthTokenFactory;
    } });
  }
});

// node_modules/zksync-web3/build/src/adapters.js
var require_adapters = __commonJS({
  "node_modules/zksync-web3/build/src/adapters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AdapterL2 = exports.AdapterL1 = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var typechain_1 = require_typechain();
    var utils_1 = require_utils16();
    function AdapterL1(Base) {
      return class Adapter extends Base {
        _providerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        _providerL1() {
          throw new Error("Must be implemented by the derived class!");
        }
        _signerL1() {
          throw new Error("Must be implemented by the derived class!");
        }
        async getMainContract() {
          const address = await this._providerL2().getMainContractAddress();
          return typechain_1.IZkSyncFactory.connect(address, this._signerL1());
        }
        async getL1BridgeContracts() {
          const addresses = await this._providerL2().getDefaultBridgeAddresses();
          return {
            erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())
          };
        }
        async getBalanceL1(token, blockTag) {
          token !== null && token !== void 0 ? token : token = utils_1.ETH_ADDRESS;
          if ((0, utils_1.isETH)(token)) {
            return await this._providerL1().getBalance(await this.getAddress(), blockTag);
          } else {
            const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());
            return await erc20contract.balanceOf(await this.getAddress());
          }
        }
        async l2TokenAddress(token) {
          if (token == utils_1.ETH_ADDRESS) {
            return utils_1.ETH_ADDRESS;
          } else {
            const erc20Bridge = (await this.getL1BridgeContracts()).erc20;
            return await erc20Bridge.l2TokenAddress(token);
          }
        }
        async approveERC20(token, amount, overrides) {
          if ((0, utils_1.isETH)(token)) {
            throw new Error("ETH token can't be approved. The address of the token does not exist on L1.");
          }
          let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;
          const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());
          if (bridgeAddress == null) {
            bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;
          } else {
            delete overrides.bridgeAddress;
          }
          return await erc20contract.approve(bridgeAddress, amount, overrides);
        }
        async getBaseCost(params) {
          var _a, _b;
          const zksyncContract = await this.getMainContract();
          const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
          (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : parameters.gasPrice = await this._providerL1().getGasPrice();
          (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));
        }
        async deposit(transaction) {
          var _a;
          const depositTx = await this.getDepositTx(transaction);
          if (transaction.token == utils_1.ETH_ADDRESS) {
            return this.requestExecute(depositTx);
          } else {
            const bridgeContracts = await this.getL1BridgeContracts();
            if (transaction.approveERC20) {
              const approveTx = await this.approveERC20(transaction.token, transaction.amount, {
                bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,
                ...transaction.approveOverrides
              });
              await approveTx.wait();
            }
            return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));
          }
        }
        async estimateGasDeposit(transaction) {
          const depositTx = await this.getDepositTx(transaction);
          if (transaction.token == utils_1.ETH_ADDRESS) {
            return await this.estimateGasRequestExecute(depositTx);
          } else {
            return await this._providerL1().estimateGas(depositTx);
          }
        }
        async getDepositTx(transaction) {
          var _a, _b, _c, _d, _e, _f, _g;
          const bridgeContracts = await this.getL1BridgeContracts();
          if (transaction.bridgeAddress) {
            bridgeContracts.erc20.attach(transaction.bridgeAddress);
          }
          const { ...tx } = transaction;
          (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = await this.getAddress();
          (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
          (_c = tx.overrides) !== null && _c !== void 0 ? _c : tx.overrides = {};
          (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte);
          const { to, token, amount, operatorTip, overrides } = tx;
          await insertGasPrice(this._providerL1(), overrides);
          const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
          const zksyncContract = await this.getMainContract();
          const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);
          if (token == utils_1.ETH_ADDRESS) {
            (_f = overrides.value) !== null && _f !== void 0 ? _f : overrides.value = baseCost.add(operatorTip).add(amount);
            return {
              contractAddress: to,
              calldata: "0x",
              l2Value: amount,
              // For some reason typescript can not deduce that we've already set the
              // tx.l2GasLimit
              l2GasLimit: tx.l2GasLimit,
              ...tx
            };
          } else {
            const args = [
              to,
              token,
              amount,
              tx.l2GasLimit,
              tx.gasPerPubdataByte
            ];
            (_g = overrides.value) !== null && _g !== void 0 ? _g : overrides.value = baseCost.add(operatorTip);
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);
          }
        }
        async _getWithdrawalLog(withdrawalHash, index = 0) {
          const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
          const receipt = await this._providerL2().getTransactionReceipt(hash);
          const log = receipt.logs.filter((log2) => log2.address == utils_1.L1_MESSENGER_ADDRESS && log2.topics[0] == ethers_1.ethers.utils.id("L1MessageSent(address,bytes32,bytes)"))[index];
          return {
            log,
            l1BatchTxId: receipt.l1BatchTxIndex
          };
        }
        async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {
          const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
          const receipt = await this._providerL2().getTransactionReceipt(hash);
          const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([_, log]) => log.sender == utils_1.L1_MESSENGER_ADDRESS);
          const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
          return {
            l2ToL1LogIndex,
            l2ToL1Log
          };
        }
        async finalizeWithdrawalParams(withdrawalHash, index = 0) {
          const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);
          const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
          const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
          const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
          const message = ethers_1.ethers.utils.defaultAbiCoder.decode(["bytes"], log.data)[0];
          return {
            l1BatchNumber: log.l1BatchNumber,
            l2MessageIndex: proof.id,
            l2TxNumberInBlock: l1BatchTxId,
            message,
            sender,
            proof: proof.proof
          };
        }
        async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {
          const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, sender, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);
          if ((0, utils_1.isETH)(sender)) {
            const contractAddress = await this._providerL2().getMainContractAddress();
            const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
            return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
          }
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());
          return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async isWithdrawalFinalized(withdrawalHash, index = 0) {
          const { log } = await this._getWithdrawalLog(withdrawalHash, index);
          const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
          const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
          const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
          if ((0, utils_1.isETH)(sender)) {
            const contractAddress = await this._providerL2().getMainContractAddress();
            const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
            return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);
          }
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());
          return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);
        }
        async claimFailedDeposit(depositHash, overrides) {
          const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));
          const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((l2ToL1log) => l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);
          const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];
          if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {
            throw new Error("Cannot claim successful deposit");
          }
          const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));
          const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);
          const l2BridgeAddress = receipt.to;
          const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());
          const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());
          const calldata = l2Bridge.interface.decodeFunctionData("finalizeDeposit", tx.data);
          const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);
          return await l1Bridge.claimFailedDeposit(calldata["_l1Sender"], calldata["_l1Token"], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async requestExecute(transaction) {
          const requestExecuteTx = await this.getRequestExecuteTx(transaction);
          return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));
        }
        async estimateGasRequestExecute(transaction) {
          const requestExecuteTx = await this.getRequestExecuteTx(transaction);
          return this._providerL1().estimateGas(requestExecuteTx);
        }
        async getRequestExecuteTx(transaction) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const zksyncContract = await this.getMainContract();
          const { ...tx } = transaction;
          (_a = tx.l2Value) !== null && _a !== void 0 ? _a : tx.l2Value = ethers_1.BigNumber.from(0);
          (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
          (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : tx.factoryDeps = [];
          (_d = tx.overrides) !== null && _d !== void 0 ? _d : tx.overrides = {};
          (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
          (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : tx.refundRecipient = await this.getAddress();
          (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction);
          const { contractAddress, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient } = tx;
          await insertGasPrice(this._providerL1(), overrides);
          const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
          const baseCost = await this.getBaseCost({
            gasPrice: await gasPriceForEstimation,
            gasPerPubdataByte,
            gasLimit: l2GasLimit
          });
          (_h = overrides.value) !== null && _h !== void 0 ? _h : overrides.value = baseCost.add(operatorTip).add(l2Value);
          await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
          return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);
        }
      };
    }
    exports.AdapterL1 = AdapterL1;
    function AdapterL2(Base) {
      return class Adapter extends Base {
        _providerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        _signerL2() {
          throw new Error("Must be implemented by the derived class!");
        }
        async getBalance(token, blockTag = "committed") {
          return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);
        }
        async getAllBalances() {
          return await this._providerL2().getAllAccountBalances(await this.getAddress());
        }
        async getL2BridgeContracts() {
          const addresses = await this._providerL2().getDefaultBridgeAddresses();
          return {
            erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())
          };
        }
        _fillCustomData(data) {
          var _a, _b;
          const customData = { ...data };
          (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
          (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : customData.factoryDeps = [];
          return customData;
        }
        async withdraw(transaction) {
          const withdrawTx = await this._providerL2().getWithdrawTx({
            from: await this.getAddress(),
            ...transaction
          });
          const txResponse = await this.sendTransaction(withdrawTx);
          return this._providerL2()._wrapTransaction(txResponse);
        }
        async transfer(transaction) {
          const transferTx = await this._providerL2().getTransferTx({
            from: await this.getAddress(),
            ...transaction
          });
          const txResponse = await this.sendTransaction(transferTx);
          return this._providerL2()._wrapTransaction(txResponse);
        }
      };
    }
    exports.AdapterL2 = AdapterL2;
    async function insertGasPrice(l1Provider, overrides) {
      if (!overrides.gasPrice && !overrides.maxFeePerGas) {
        const l1FeeData = await l1Provider.getFeeData();
        const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;
        const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);
        overrides.maxFeePerGas = maxFeePerGas;
        overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;
      }
    }
  }
});

// node_modules/zksync-web3/build/src/signer.js
var require_signer2 = __commonJS({
  "node_modules/zksync-web3/build/src/signer.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.eip712Types = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var utils_1 = require_utils16();
    var hash_1 = (init_lib4(), __toCommonJS(lib_exports4));
    var adapters_1 = require_adapters();
    exports.eip712Types = {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    };
    var EIP712Signer = class _EIP712Signer {
      constructor(ethSigner, chainId) {
        this.ethSigner = ethSigner;
        this.eip712Domain = Promise.resolve(chainId).then((chainId2) => ({
          name: "zkSync",
          version: "2",
          chainId: chainId2
        }));
      }
      static getSignInput(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
        const gasPerPubdataByteLimit = ((_a = transaction.customData) === null || _a === void 0 ? void 0 : _a.gasPerPubdata) || utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        const signInput = {
          txType: transaction.type,
          from: transaction.from,
          to: transaction.to,
          gasLimit: transaction.gasLimit,
          gasPerPubdataByteLimit,
          maxFeePerGas,
          maxPriorityFeePerGas,
          paymaster: ((_c = (_b = transaction.customData) === null || _b === void 0 ? void 0 : _b.paymasterParams) === null || _c === void 0 ? void 0 : _c.paymaster) || ethers_1.ethers.constants.AddressZero,
          nonce: transaction.nonce,
          value: transaction.value,
          data: transaction.data,
          factoryDeps: ((_e = (_d = transaction.customData) === null || _d === void 0 ? void 0 : _d.factoryDeps) === null || _e === void 0 ? void 0 : _e.map((dep) => (0, utils_1.hashBytecode)(dep))) || [],
          paymasterInput: ((_g = (_f = transaction.customData) === null || _f === void 0 ? void 0 : _f.paymasterParams) === null || _g === void 0 ? void 0 : _g.paymasterInput) || "0x"
        };
        return signInput;
      }
      async sign(transaction) {
        return await this.ethSigner._signTypedData(await this.eip712Domain, exports.eip712Types, _EIP712Signer.getSignInput(transaction));
      }
      static getSignedDigest(transaction) {
        if (!transaction.chainId) {
          throw Error("Transaction chainId isn't set");
        }
        const domain = {
          name: "zkSync",
          version: "2",
          chainId: transaction.chainId
        };
        return hash_1._TypedDataEncoder.hash(domain, exports.eip712Types, _EIP712Signer.getSignInput(transaction));
      }
    };
    exports.EIP712Signer = EIP712Signer;
    var Signer = class _Signer extends (0, adapters_1.AdapterL2)(ethers_1.ethers.providers.JsonRpcSigner) {
      _signerL2() {
        return this;
      }
      _providerL2() {
        return this.provider;
      }
      static from(signer) {
        const newSigner = Object.setPrototypeOf(signer, _Signer.prototype);
        newSigner.eip712 = new EIP712Signer(newSigner, newSigner.getChainId());
        return newSigner;
      }
      // an alias with a better name
      async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
      }
      async sendTransaction(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (transaction.customData == null && transaction.type == null) {
          transaction.type = 0;
        }
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          return await super.sendTransaction(transaction);
        } else {
          const address = await this.getAddress();
          (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = address;
          if (transaction.from.toLowerCase() != address.toLowerCase()) {
            throw new Error("Transaction `from` address mismatch");
          }
          transaction.type = utils_1.EIP712_TX_TYPE;
          (_b = transaction.value) !== null && _b !== void 0 ? _b : transaction.value = 0;
          (_c = transaction.data) !== null && _c !== void 0 ? _c : transaction.data = "0x";
          (_d = transaction.nonce) !== null && _d !== void 0 ? _d : transaction.nonce = await this.getNonce();
          transaction.customData = this._fillCustomData(transaction.customData);
          (_e = transaction.gasPrice) !== null && _e !== void 0 ? _e : transaction.gasPrice = await this.provider.getGasPrice();
          (_f = transaction.gasLimit) !== null && _f !== void 0 ? _f : transaction.gasLimit = await this.provider.estimateGas(transaction);
          (_g = transaction.chainId) !== null && _g !== void 0 ? _g : transaction.chainId = (await this.provider.getNetwork()).chainId;
          transaction.customData.customSignature = await this.eip712.sign(transaction);
          const txBytes = (0, utils_1.serialize)(transaction);
          return await this.provider.sendTransaction(txBytes);
        }
      }
    };
    exports.Signer = Signer;
    var L1Signer = class _L1Signer extends (0, adapters_1.AdapterL1)(ethers_1.ethers.providers.JsonRpcSigner) {
      _providerL2() {
        return this.providerL2;
      }
      _providerL1() {
        return this.provider;
      }
      _signerL1() {
        return this;
      }
      static from(signer, zksyncProvider) {
        const newSigner = Object.setPrototypeOf(signer, _L1Signer.prototype);
        newSigner.providerL2 = zksyncProvider;
        return newSigner;
      }
      connectToL2(provider) {
        this.providerL2 = provider;
        return this;
      }
    };
    exports.L1Signer = L1Signer;
  }
});

// node_modules/zksync-web3/abi/IPaymasterFlow.json
var require_IPaymasterFlow = __commonJS({
  "node_modules/zksync-web3/abi/IPaymasterFlow.json"(exports, module) {
    module.exports = {
      abi: [
        {
          inputs: [
            {
              internalType: "address",
              name: "_token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_minAllowance",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_innerInput",
              type: "bytes"
            }
          ],
          name: "approvalBased",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "input",
              type: "bytes"
            }
          ],
          name: "general",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/build/src/paymaster-utils.js
var require_paymaster_utils = __commonJS({
  "node_modules/zksync-web3/build/src/paymaster-utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPaymasterParams = exports.getGeneralPaymasterInput = exports.getApprovalBasedPaymasterInput = exports.IPaymasterFlow = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    exports.IPaymasterFlow = new ethers_1.ethers.utils.Interface(require_IPaymasterFlow().abi);
    function getApprovalBasedPaymasterInput(paymasterInput) {
      return exports.IPaymasterFlow.encodeFunctionData("approvalBased", [
        paymasterInput.token,
        paymasterInput.minimalAllowance,
        paymasterInput.innerInput
      ]);
    }
    exports.getApprovalBasedPaymasterInput = getApprovalBasedPaymasterInput;
    function getGeneralPaymasterInput(paymasterInput) {
      return exports.IPaymasterFlow.encodeFunctionData("general", [paymasterInput.innerInput]);
    }
    exports.getGeneralPaymasterInput = getGeneralPaymasterInput;
    function getPaymasterParams(paymasterAddress, paymasterInput) {
      if (paymasterInput.type == "General") {
        return {
          paymaster: paymasterAddress,
          paymasterInput: getGeneralPaymasterInput(paymasterInput)
        };
      } else {
        return {
          paymaster: paymasterAddress,
          paymasterInput: getApprovalBasedPaymasterInput(paymasterInput)
        };
      }
    }
    exports.getPaymasterParams = getPaymasterParams;
  }
});

// node_modules/zksync-web3/abi/IZkSync.json
var require_IZkSync = __commonJS({
  "node_modules/zksync-web3/abi/IZkSync.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "blockNumber",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "blockHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "commitment",
              type: "bytes32"
            }
          ],
          name: "BlockCommit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "blockNumber",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "blockHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "commitment",
              type: "bytes32"
            }
          ],
          name: "BlockExecution",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksCommitted",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksVerified",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "totalBlocksExecuted",
              type: "uint256"
            }
          ],
          name: "BlocksRevert",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "previousLastVerifiedBlock",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "uint256",
              name: "currentLastVerifiedBlock",
              type: "uint256"
            }
          ],
          name: "BlocksVerification",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "CancelUpgradeProposal",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "EthWithdrawalFinalized",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "proposalSalt",
              type: "bytes32"
            }
          ],
          name: "ExecuteUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [],
          name: "Freeze",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "bool",
              name: "isPorterAvailable",
              type: "bool"
            }
          ],
          name: "IsPorterAvailableStatusUpdate",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldGovernor",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newGovernor",
              type: "address"
            }
          ],
          name: "NewGovernor",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "previousBytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "newBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "NewL2BootloaderBytecodeHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "bytes32",
              name: "previousBytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "newBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "NewL2DefaultAccountBytecodeHash",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldPendingGovernor",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newPendingGovernor",
              type: "address"
            }
          ],
          name: "NewPendingGovernor",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "txId",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "uint64",
              name: "expirationTimestamp",
              type: "uint64"
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "txType",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "from",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "to",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "gasPerPubdataByteLimit",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "maxPriorityFeePerGas",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "paymaster",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "nonce",
                  type: "uint256"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "uint256[4]",
                  name: "reserved",
                  type: "uint256[4]"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "signature",
                  type: "bytes"
                },
                {
                  internalType: "uint256[]",
                  name: "factoryDeps",
                  type: "uint256[]"
                },
                {
                  internalType: "bytes",
                  name: "paymasterInput",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "reservedDynamic",
                  type: "bytes"
                }
              ],
              indexed: false,
              internalType: "struct IMailbox.L2CanonicalTransaction",
              name: "transaction",
              type: "tuple"
            },
            {
              indexed: false,
              internalType: "bytes[]",
              name: "factoryDeps",
              type: "bytes[]"
            }
          ],
          name: "NewPriorityRequest",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "uint256",
              name: "oldPriorityTxMaxGasLimit",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "newPriorityTxMaxGasLimit",
              type: "uint256"
            }
          ],
          name: "NewPriorityTxMaxGasLimit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "oldVerifier",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "newVerifier",
              type: "address"
            }
          ],
          name: "NewVerifier",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              indexed: false,
              internalType: "struct VerifierParams",
              name: "oldVerifierParams",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              indexed: false,
              internalType: "struct VerifierParams",
              name: "newVerifierParams",
              type: "tuple"
            }
          ],
          name: "NewVerifierParams",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "ProposeShadowUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              indexed: false,
              internalType: "struct Diamond.DiamondCutData",
              name: "diamondCut",
              type: "tuple"
            },
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: false,
              internalType: "bytes32",
              name: "proposalSalt",
              type: "bytes32"
            }
          ],
          name: "ProposeTransparentUpgrade",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "uint256",
              name: "proposalId",
              type: "uint256"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "proposalHash",
              type: "bytes32"
            }
          ],
          name: "SecurityCouncilUpgradeApprove",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [],
          name: "Unfreeze",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "validatorAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "bool",
              name: "isActive",
              type: "bool"
            }
          ],
          name: "ValidatorStatusUpdate",
          type: "event"
        },
        {
          inputs: [],
          name: "acceptGovernor",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_proposedUpgradeHash",
              type: "bytes32"
            }
          ],
          name: "cancelUpgradeProposal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo",
              name: "_lastCommittedBlockData",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "uint64",
                  name: "timestamp",
                  type: "uint64"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "newStateRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes",
                  name: "initialStorageChanges",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "repeatedStorageChanges",
                  type: "bytes"
                },
                {
                  internalType: "bytes",
                  name: "l2Logs",
                  type: "bytes"
                },
                {
                  internalType: "bytes[]",
                  name: "l2ArbitraryLengthMessages",
                  type: "bytes[]"
                },
                {
                  internalType: "bytes[]",
                  name: "factoryDeps",
                  type: "bytes[]"
                }
              ],
              internalType: "struct IExecutor.CommitBlockInfo[]",
              name: "_newBlocksData",
              type: "tuple[]"
            }
          ],
          name: "commitBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo[]",
              name: "_blocksData",
              type: "tuple[]"
            }
          ],
          name: "executeBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "bytes32",
              name: "_proposalSalt",
              type: "bytes32"
            }
          ],
          name: "executeUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "_selector",
              type: "bytes4"
            }
          ],
          name: "facetAddress",
          outputs: [
            {
              internalType: "address",
              name: "facet",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "facetAddresses",
          outputs: [
            {
              internalType: "address[]",
              name: "facets",
              type: "address[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_facet",
              type: "address"
            }
          ],
          name: "facetFunctionSelectors",
          outputs: [
            {
              internalType: "bytes4[]",
              name: "",
              type: "bytes4[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "facets",
          outputs: [
            {
              components: [
                {
                  internalType: "address",
                  name: "addr",
                  type: "address"
                },
                {
                  internalType: "bytes4[]",
                  name: "selectors",
                  type: "bytes4[]"
                }
              ],
              internalType: "struct IGetters.Facet[]",
              name: "",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "finalizeEthWithdrawal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "freezeDiamond",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "getCurrentProposalId",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getFirstUnprocessedPriorityTx",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getGovernor",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getL2BootloaderBytecodeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getL2DefaultAccountBytecodeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getPendingGovernor",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getPriorityQueueSize",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getProposedUpgradeHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getProposedUpgradeTimestamp",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getSecurityCouncil",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksCommitted",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksExecuted",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalBlocksVerified",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getTotalPriorityTxs",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getUpgradeProposalState",
          outputs: [
            {
              internalType: "enum UpgradeState",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getVerifier",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getVerifierParams",
          outputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              internalType: "struct VerifierParams",
              name: "",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "getpriorityTxMaxGasLimit",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "isApprovedBySecurityCouncil",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "isDiamondStorageFrozen",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            }
          ],
          name: "isEthWithdrawalFinalized",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_facet",
              type: "address"
            }
          ],
          name: "isFacetFreezable",
          outputs: [
            {
              internalType: "bool",
              name: "isFreezable",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes4",
              name: "_selector",
              type: "bytes4"
            }
          ],
          name: "isFunctionFreezable",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "isValidator",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            }
          ],
          name: "l2LogsRootHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "hash",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_gasPrice",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasPerPubdataByteLimit",
              type: "uint256"
            }
          ],
          name: "l2TransactionBaseCost",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "priorityQueueFrontOperation",
          outputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "canonicalTxHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "expirationTimestamp",
                  type: "uint64"
                },
                {
                  internalType: "uint192",
                  name: "layer2Tip",
                  type: "uint192"
                }
              ],
              internalType: "struct PriorityOperation",
              name: "",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_proposalHash",
              type: "bytes32"
            },
            {
              internalType: "uint40",
              name: "_proposalId",
              type: "uint40"
            }
          ],
          name: "proposeShadowUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "uint40",
              name: "_proposalId",
              type: "uint40"
            }
          ],
          name: "proposeTransparentUpgrade",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo",
              name: "_prevBlock",
              type: "tuple"
            },
            {
              components: [
                {
                  internalType: "uint64",
                  name: "blockNumber",
                  type: "uint64"
                },
                {
                  internalType: "bytes32",
                  name: "blockHash",
                  type: "bytes32"
                },
                {
                  internalType: "uint64",
                  name: "indexRepeatedStorageChanges",
                  type: "uint64"
                },
                {
                  internalType: "uint256",
                  name: "numberOfLayer1Txs",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "priorityOperationsHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "l2LogsTreeRoot",
                  type: "bytes32"
                },
                {
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256"
                },
                {
                  internalType: "bytes32",
                  name: "commitment",
                  type: "bytes32"
                }
              ],
              internalType: "struct IExecutor.StoredBlockInfo[]",
              name: "_committedBlocks",
              type: "tuple[]"
            },
            {
              components: [
                {
                  internalType: "uint256[]",
                  name: "recursiveAggregationInput",
                  type: "uint256[]"
                },
                {
                  internalType: "uint256[]",
                  name: "serializedProof",
                  type: "uint256[]"
                }
              ],
              internalType: "struct IExecutor.ProofInput",
              name: "_proof",
              type: "tuple"
            }
          ],
          name: "proveBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2TxHash",
              type: "bytes32"
            },
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            },
            {
              internalType: "enum TxStatus",
              name: "_status",
              type: "uint8"
            }
          ],
          name: "proveL1ToL2TransactionStatus",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            },
            {
              components: [
                {
                  internalType: "uint8",
                  name: "l2ShardId",
                  type: "uint8"
                },
                {
                  internalType: "bool",
                  name: "isService",
                  type: "bool"
                },
                {
                  internalType: "uint16",
                  name: "txNumberInBlock",
                  type: "uint16"
                },
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "bytes32",
                  name: "key",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "value",
                  type: "bytes32"
                }
              ],
              internalType: "struct L2Log",
              name: "_log",
              type: "tuple"
            },
            {
              internalType: "bytes32[]",
              name: "_proof",
              type: "bytes32[]"
            }
          ],
          name: "proveL2LogInclusion",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_index",
              type: "uint256"
            },
            {
              components: [
                {
                  internalType: "uint16",
                  name: "txNumberInBlock",
                  type: "uint16"
                },
                {
                  internalType: "address",
                  name: "sender",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "data",
                  type: "bytes"
                }
              ],
              internalType: "struct L2Message",
              name: "_message",
              type: "tuple"
            },
            {
              internalType: "bytes32[]",
              name: "_proof",
              type: "bytes32[]"
            }
          ],
          name: "proveL2MessageInclusion",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_contractL2",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_l2Value",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_calldata",
              type: "bytes"
            },
            {
              internalType: "uint256",
              name: "_l2GasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2GasPerPubdataByteLimit",
              type: "uint256"
            },
            {
              internalType: "bytes[]",
              name: "_factoryDeps",
              type: "bytes[]"
            },
            {
              internalType: "address",
              name: "_refundRecipient",
              type: "address"
            }
          ],
          name: "requestL2Transaction",
          outputs: [
            {
              internalType: "bytes32",
              name: "canonicalTxHash",
              type: "bytes32"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_newLastBlock",
              type: "uint256"
            }
          ],
          name: "revertBlocks",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_upgradeProposalHash",
              type: "bytes32"
            }
          ],
          name: "securityCouncilUpgradeApprove",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2BootloaderBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "setL2BootloaderBytecodeHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_l2DefaultAccountBytecodeHash",
              type: "bytes32"
            }
          ],
          name: "setL2DefaultAccountBytecodeHash",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_newPendingGovernor",
              type: "address"
            }
          ],
          name: "setPendingGovernor",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bool",
              name: "_zkPorterIsAvailable",
              type: "bool"
            }
          ],
          name: "setPorterAvailability",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_newPriorityTxMaxGasLimit",
              type: "uint256"
            }
          ],
          name: "setPriorityTxMaxGasLimit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_validator",
              type: "address"
            },
            {
              internalType: "bool",
              name: "_active",
              type: "bool"
            }
          ],
          name: "setValidator",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "contract Verifier",
              name: "_newVerifier",
              type: "address"
            }
          ],
          name: "setVerifier",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "recursionNodeLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionLeafLevelVkHash",
                  type: "bytes32"
                },
                {
                  internalType: "bytes32",
                  name: "recursionCircuitsSetVksHash",
                  type: "bytes32"
                }
              ],
              internalType: "struct VerifierParams",
              name: "_newVerifierParams",
              type: "tuple"
            }
          ],
          name: "setVerifierParams",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_blockNumber",
              type: "uint256"
            }
          ],
          name: "storedBlockHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "unfreezeDiamond",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  components: [
                    {
                      internalType: "address",
                      name: "facet",
                      type: "address"
                    },
                    {
                      internalType: "enum Diamond.Action",
                      name: "action",
                      type: "uint8"
                    },
                    {
                      internalType: "bool",
                      name: "isFreezable",
                      type: "bool"
                    },
                    {
                      internalType: "bytes4[]",
                      name: "selectors",
                      type: "bytes4[]"
                    }
                  ],
                  internalType: "struct Diamond.FacetCut[]",
                  name: "facetCuts",
                  type: "tuple[]"
                },
                {
                  internalType: "address",
                  name: "initAddress",
                  type: "address"
                },
                {
                  internalType: "bytes",
                  name: "initCalldata",
                  type: "bytes"
                }
              ],
              internalType: "struct Diamond.DiamondCutData",
              name: "_diamondCut",
              type: "tuple"
            },
            {
              internalType: "uint256",
              name: "_proposalId",
              type: "uint256"
            },
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            }
          ],
          name: "upgradeProposalHash",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "pure",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/ContractDeployer.json
var require_ContractDeployer = __commonJS({
  "node_modules/zksync-web3/abi/ContractDeployer.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "accountAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "enum IContractDeployer.AccountNonceOrdering",
              name: "nonceOrdering",
              type: "uint8"
            }
          ],
          name: "AccountNonceOrderingUpdated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "accountAddress",
              type: "address"
            },
            {
              indexed: false,
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "aaVersion",
              type: "uint8"
            }
          ],
          name: "AccountVersionUpdated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "deployerAddress",
              type: "address"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32"
            },
            {
              indexed: true,
              internalType: "address",
              name: "contractAddress",
              type: "address"
            }
          ],
          name: "ContractDeployed",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "create",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "create2",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            },
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_aaVersion",
              type: "uint8"
            }
          ],
          name: "create2Account",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            },
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_aaVersion",
              type: "uint8"
            }
          ],
          name: "createAccount",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "extendedAccountVersion",
          outputs: [
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "bytecodeHash",
                  type: "bytes32"
                },
                {
                  internalType: "address",
                  name: "newAddress",
                  type: "address"
                },
                {
                  internalType: "bool",
                  name: "callConstructor",
                  type: "bool"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "input",
                  type: "bytes"
                }
              ],
              internalType: "struct ContractDeployer.ForceDeployment",
              name: "_deployment",
              type: "tuple"
            },
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            }
          ],
          name: "forceDeployOnAddress",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "bytecodeHash",
                  type: "bytes32"
                },
                {
                  internalType: "address",
                  name: "newAddress",
                  type: "address"
                },
                {
                  internalType: "bool",
                  name: "callConstructor",
                  type: "bool"
                },
                {
                  internalType: "uint256",
                  name: "value",
                  type: "uint256"
                },
                {
                  internalType: "bytes",
                  name: "input",
                  type: "bytes"
                }
              ],
              internalType: "struct ContractDeployer.ForceDeployment[]",
              name: "_deployments",
              type: "tuple[]"
            }
          ],
          name: "forceDeployOnAddresses",
          outputs: [],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_address",
              type: "address"
            }
          ],
          name: "getAccountInfo",
          outputs: [
            {
              components: [
                {
                  internalType: "enum IContractDeployer.AccountAbstractionVersion",
                  name: "supportedAAVersion",
                  type: "uint8"
                },
                {
                  internalType: "enum IContractDeployer.AccountNonceOrdering",
                  name: "nonceOrdering",
                  type: "uint8"
                }
              ],
              internalType: "struct IContractDeployer.AccountInfo",
              name: "info",
              type: "tuple"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_senderNonce",
              type: "uint256"
            }
          ],
          name: "getNewAddressCreate",
          outputs: [
            {
              internalType: "address",
              name: "newAddress",
              type: "address"
            }
          ],
          stateMutability: "pure",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_bytecodeHash",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "_salt",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_input",
              type: "bytes"
            }
          ],
          name: "getNewAddressCreate2",
          outputs: [
            {
              internalType: "address",
              name: "newAddress",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "enum IContractDeployer.AccountAbstractionVersion",
              name: "_version",
              type: "uint8"
            }
          ],
          name: "updateAccountVersion",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "enum IContractDeployer.AccountNonceOrdering",
              name: "_nonceOrdering",
              type: "uint8"
            }
          ],
          name: "updateNonceOrdering",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL1Messenger.json
var require_IL1Messenger = __commonJS({
  "node_modules/zksync-web3/abi/IL1Messenger.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "_sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "bytes32",
              name: "_hash",
              type: "bytes32"
            },
            {
              indexed: false,
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            }
          ],
          name: "L1MessageSent",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            }
          ],
          name: "sendToL1",
          outputs: [
            {
              internalType: "bytes32",
              name: "",
              type: "bytes32"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IERC20.json
var require_IERC20 = __commonJS({
  "node_modules/zksync-web3/abi/IERC20.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "spender",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "Approval",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "value",
              type: "uint256"
            }
          ],
          name: "Transfer",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "owner",
              type: "address"
            },
            {
              internalType: "address",
              name: "spender",
              type: "address"
            }
          ],
          name: "allowance",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "spender",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "approve",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "account",
              type: "address"
            }
          ],
          name: "balanceOf",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "decimals",
          outputs: [
            {
              internalType: "uint8",
              name: "",
              type: "uint8"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "name",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "symbol",
          outputs: [
            {
              internalType: "string",
              name: "",
              type: "string"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "totalSupply",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transfer",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "transferFrom",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IERC1271.json
var require_IERC1271 = __commonJS({
  "node_modules/zksync-web3/abi/IERC1271.json"(exports, module) {
    module.exports = {
      abi: [
        {
          inputs: [
            {
              internalType: "bytes32",
              name: "hash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "signature",
              type: "bytes"
            }
          ],
          name: "isValidSignature",
          outputs: [
            {
              internalType: "bytes4",
              name: "magicValue",
              type: "bytes4"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL1Bridge.json
var require_IL1Bridge = __commonJS({
  "node_modules/zksync-web3/abi/IL1Bridge.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "ClaimedFailedDeposit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "from",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "DepositInitiated",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "to",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "WithdrawalFinalized",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_depositSender",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_l2TxHash",
              type: "bytes32"
            },
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "claimFailedDeposit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l2Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2TxGasLimit",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2TxGasPerPubdataByte",
              type: "uint256"
            }
          ],
          name: "deposit",
          outputs: [
            {
              internalType: "bytes32",
              name: "txHash",
              type: "bytes32"
            }
          ],
          stateMutability: "payable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            },
            {
              internalType: "uint16",
              name: "_l2TxNumberInBlock",
              type: "uint16"
            },
            {
              internalType: "bytes",
              name: "_message",
              type: "bytes"
            },
            {
              internalType: "bytes32[]",
              name: "_merkleProof",
              type: "bytes32[]"
            }
          ],
          name: "finalizeWithdrawal",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "_l2BlockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "_l2MessageIndex",
              type: "uint256"
            }
          ],
          name: "isWithdrawalFinalized",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            }
          ],
          name: "l2TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/abi/IL2Bridge.json
var require_IL2Bridge = __commonJS({
  "node_modules/zksync-web3/abi/IL2Bridge.json"(exports, module) {
    module.exports = {
      abi: [
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "l1Sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Receiver",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "FinalizeDeposit",
          type: "event"
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "l2Sender",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l1Receiver",
              type: "address"
            },
            {
              indexed: true,
              internalType: "address",
              name: "l2Token",
              type: "address"
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256"
            }
          ],
          name: "WithdrawalInitiated",
          type: "event"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Sender",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l2Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            },
            {
              internalType: "bytes",
              name: "_data",
              type: "bytes"
            }
          ],
          name: "finalizeDeposit",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        },
        {
          inputs: [],
          name: "l1Bridge",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l2Token",
              type: "address"
            }
          ],
          name: "l1TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Token",
              type: "address"
            }
          ],
          name: "l2TokenAddress",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address"
            }
          ],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_l1Receiver",
              type: "address"
            },
            {
              internalType: "address",
              name: "_l2Token",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "_amount",
              type: "uint256"
            }
          ],
          name: "withdraw",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function"
        }
      ]
    };
  }
});

// node_modules/zksync-web3/build/src/utils.js
var require_utils16 = __commonJS({
  "node_modules/zksync-web3/build/src/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var types_1 = require_types5();
    var signer_1 = require_signer2();
    var typechain_1 = require_typechain();
    var utils_1 = require_utils();
    __exportStar(require_paymaster_utils(), exports);
    exports.ETH_ADDRESS = "0x0000000000000000000000000000000000000000";
    exports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(require_IZkSync().abi);
    exports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(require_ContractDeployer().abi);
    exports.L1_MESSENGER = new ethers_1.utils.Interface(require_IL1Messenger().abi);
    exports.IERC20 = new ethers_1.utils.Interface(require_IERC20().abi);
    exports.IERC1271 = new ethers_1.utils.Interface(require_IERC1271().abi);
    exports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(require_IL1Bridge().abi);
    exports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(require_IL2Bridge().abi);
    exports.BOOTLOADER_FORMAL_ADDRESS = "0x0000000000000000000000000000000000008001";
    exports.CONTRACT_DEPLOYER_ADDRESS = "0x0000000000000000000000000000000000008006";
    exports.L1_MESSENGER_ADDRESS = "0x0000000000000000000000000000000000008008";
    exports.L2_ETH_TOKEN_ADDRESS = "0x000000000000000000000000000000000000800a";
    exports.L1_TO_L2_ALIAS_OFFSET = "0x1111000000000000000000000000000000001111";
    exports.EIP1271_MAGIC_VALUE = "0x1626ba7e";
    exports.EIP712_TX_TYPE = 113;
    exports.PRIORITY_OPERATION_L2_TX_TYPE = 255;
    exports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;
    exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 5e4;
    exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;
    function isETH(token) {
      return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;
    }
    exports.isETH = isETH;
    function sleep(millis) {
      return new Promise((resolve2) => setTimeout(resolve2, millis));
    }
    exports.sleep = sleep;
    function layer1TxDefaults() {
      return {
        queueType: types_1.PriorityQueueType.Deque,
        opTree: types_1.PriorityOpTree.Full
      };
    }
    exports.layer1TxDefaults = layer1TxDefaults;
    function getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {
      const encodedMsg = new Uint8Array([
        0,
        1,
        ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2),
        ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS),
        ...ethers_1.ethers.utils.zeroPad(sender, 32),
        ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))
      ]);
      return ethers_1.ethers.utils.keccak256(encodedMsg);
    }
    exports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;
    function getDeployedContracts(receipt) {
      const addressBytesLen = 40;
      const deployedContracts = receipt.logs.filter((log) => log.topics[0] == ethers_1.utils.id("ContractDeployed(address,bytes32,address)") && log.address == exports.CONTRACT_DEPLOYER_ADDRESS).map((log) => {
        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;
        const bytesCodehash = log.topics[2];
        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;
        return {
          sender: ethers_1.utils.getAddress(sender),
          bytecodeHash: bytesCodehash,
          deployedAddress: ethers_1.utils.getAddress(address)
        };
      });
      return deployedContracts;
    }
    exports.getDeployedContracts = getDeployedContracts;
    function create2Address(sender, bytecodeHash, salt, input) {
      const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes("zksyncCreate2"));
      const inputHash = ethers_1.ethers.utils.keccak256(input);
      const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([prefix, ethers_1.ethers.utils.zeroPad(sender, 32), salt, bytecodeHash, inputHash])).slice(26);
      return ethers_1.ethers.utils.getAddress(addressBytes);
    }
    exports.create2Address = create2Address;
    function createAddress(sender, senderNonce) {
      const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes("zksyncCreate"));
      const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([
        prefix,
        ethers_1.ethers.utils.zeroPad(sender, 32),
        ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)
      ])).slice(26);
      return ethers_1.ethers.utils.getAddress(addressBytes);
    }
    exports.createAddress = createAddress;
    async function checkBaseCost(baseCost, value) {
      if (baseCost.gt(await value)) {
        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter for the transaction: baseCost: ${baseCost}, provided value: ${value}`);
      }
    }
    exports.checkBaseCost = checkBaseCost;
    function serialize(transaction, signature) {
      var _a;
      if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.serializeTransaction(transaction, signature);
      }
      if (!transaction.chainId) {
        throw Error("Transaction chainId isn't set");
      }
      function formatNumber(value, name) {
        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());
        if (result.length > 32) {
          throw new Error("invalid length for " + name);
        }
        return result;
      }
      if (!transaction.from) {
        throw new Error("Explicitly providing `from` field is reqiured for EIP712 transactions");
      }
      const from = transaction.from;
      const meta = transaction.customData;
      let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;
      let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
      const fields = [
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(maxPriorityFeePerGas, "maxPriorityFeePerGas"),
        formatNumber(maxFeePerGas, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x"
      ];
      if (signature) {
        const sig = ethers_1.utils.splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(ethers_1.utils.stripZeros(sig.r));
        fields.push(ethers_1.utils.stripZeros(sig.s));
      } else {
        fields.push(formatNumber(transaction.chainId, "chainId"));
        fields.push("0x");
        fields.push("0x");
      }
      fields.push(formatNumber(transaction.chainId, "chainId"));
      fields.push(ethers_1.utils.getAddress(from));
      fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, "gasPerPubdata"));
      fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep) => ethers_1.utils.hexlify(dep)));
      if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {
        throw new Error("Empty signatures are not supported");
      }
      fields.push(meta.customSignature || "0x");
      if (meta.paymasterParams) {
        fields.push([meta.paymasterParams.paymaster, ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)]);
      } else {
        fields.push([]);
      }
      return ethers_1.utils.hexConcat([[exports.EIP712_TX_TYPE], ethers_1.utils.RLP.encode(fields)]);
    }
    exports.serialize = serialize;
    function hashBytecode(bytecode) {
      const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);
      if (bytecodeAsArray.length % 32 != 0) {
        throw new Error("The bytecode length in bytes must be divisible by 32");
      }
      if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {
        throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);
      }
      const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);
      const hash = ethers_1.ethers.utils.arrayify(hashStr);
      const bytecodeLengthInWords = bytecodeAsArray.length / 32;
      if (bytecodeLengthInWords % 2 == 0) {
        throw new Error("Bytecode length in 32-byte words must be odd");
      }
      const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);
      const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);
      const codeHashVersion = new Uint8Array([1, 0]);
      hash.set(codeHashVersion, 0);
      hash.set(bytecodeLengthPadded, 2);
      return hash;
    }
    exports.hashBytecode = hashBytecode;
    function parseTransaction(payload) {
      function handleAddress(value) {
        if (value === "0x") {
          return null;
        }
        return ethers_1.utils.getAddress(value);
      }
      function handleNumber(value) {
        if (value === "0x") {
          return ethers_1.BigNumber.from(0);
        }
        return ethers_1.BigNumber.from(value);
      }
      function arrayToPaymasterParams(arr) {
        if (arr.length == 0) {
          return void 0;
        }
        if (arr.length != 2) {
          throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);
        }
        return {
          paymaster: ethers_1.utils.getAddress(arr[0]),
          paymasterInput: ethers_1.utils.arrayify(arr[1])
        };
      }
      const bytes = ethers_1.utils.arrayify(payload);
      if (bytes[0] != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.parseTransaction(bytes);
      }
      const raw = ethers_1.utils.RLP.decode(bytes.slice(1));
      const transaction = {
        type: exports.EIP712_TX_TYPE,
        nonce: handleNumber(raw[0]).toNumber(),
        maxPriorityFeePerGas: handleNumber(raw[1]),
        maxFeePerGas: handleNumber(raw[2]),
        gasLimit: handleNumber(raw[3]),
        to: handleAddress(raw[4]),
        value: handleNumber(raw[5]),
        data: raw[6],
        chainId: handleNumber(raw[10]),
        from: handleAddress(raw[11]),
        customData: {
          gasPerPubdata: handleNumber(raw[12]),
          factoryDeps: raw[13],
          customSignature: raw[14],
          paymasterParams: arrayToPaymasterParams(raw[15])
        }
      };
      const ethSignature = {
        v: handleNumber(raw[7]).toNumber(),
        r: raw[8],
        s: raw[9]
      };
      if ((ethers_1.utils.hexlify(ethSignature.r) == "0x" || ethers_1.utils.hexlify(ethSignature.s) == "0x") && !transaction.customData.customSignature) {
        return transaction;
      }
      if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {
        throw new Error("Failed to parse signature");
      }
      if (!transaction.customData.customSignature) {
        transaction.v = ethSignature.v;
        transaction.s = ethSignature.s;
        transaction.r = ethSignature.r;
      }
      transaction.hash = eip712TxHash(transaction, ethSignature);
      return transaction;
    }
    exports.parseTransaction = parseTransaction;
    function getSignature(transaction, ethSignature) {
      var _a;
      if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {
        return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);
      }
      if (!ethSignature) {
        throw new Error("No signature provided");
      }
      const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);
      const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);
      const v = ethSignature.v;
      return new Uint8Array([...r, ...s, v]);
    }
    function eip712TxHash(transaction, ethSignature) {
      const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);
      const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));
      return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([signedDigest, hashedSignature]));
    }
    function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
      let txHash = null;
      for (const log of txReceipt.logs) {
        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {
          continue;
        }
        try {
          const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);
          if (priorityQueueLog && priorityQueueLog.args.txHash != null) {
            txHash = priorityQueueLog.args.txHash;
          }
        } catch {
        }
      }
      if (!txHash) {
        throw new Error("Failed to parse tx logs");
      }
      return txHash;
    }
    exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
    var ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);
    function applyL1ToL2Alias(address) {
      return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));
    }
    exports.applyL1ToL2Alias = applyL1ToL2Alias;
    function undoL1ToL2Alias(address) {
      let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);
      if (result.lt(ethers_1.BigNumber.from(0))) {
        result = result.add(ADDRESS_MODULO);
      }
      return ethers_1.ethers.utils.hexlify(result);
    }
    exports.undoL1ToL2Alias = undoL1ToL2Alias;
    async function getERC20GettersData(l1TokenAddress, provider) {
      const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);
      const name = await token.name();
      const symbol = await token.symbol();
      const decimals = await token.decimals();
      const coder = new utils_1.AbiCoder();
      const nameBytes = coder.encode(["string"], [name]);
      const symbolBytes = coder.encode(["string"], [symbol]);
      const decimalsBytes = coder.encode(["uint256"], [decimals]);
      return coder.encode(["bytes", "bytes", "bytes"], [nameBytes, symbolBytes, decimalsBytes]);
    }
    async function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {
      const gettersData = await getERC20GettersData(l1TokenAddress, provider);
      return exports.L2_BRIDGE_ABI.encodeFunctionData("finalizeDeposit", [
        l1Sender,
        l2Receiver,
        l1TokenAddress,
        amount,
        gettersData
      ]);
    }
    exports.getERC20BridgeCalldata = getERC20BridgeCalldata;
    function isECDSASignatureCorrect(address, msgHash, signature) {
      try {
        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);
      } catch {
        return false;
      }
    }
    async function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {
      const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);
      const result = await accountContract.isValidSignature(msgHash, signature);
      return result == exports.EIP1271_MAGIC_VALUE;
    }
    async function isSignatureCorrect(provider, address, msgHash, signature) {
      let isContractAccount = false;
      const code = await provider.getCode(address);
      isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;
      if (!isContractAccount) {
        return isECDSASignatureCorrect(address, msgHash, signature);
      } else {
        return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);
      }
    }
    async function isMessageSignatureCorrect(provider, address, message, signature) {
      const msgHash = ethers_1.ethers.utils.hashMessage(message);
      return await isSignatureCorrect(provider, address, msgHash, signature);
    }
    exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
    async function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {
      const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);
      return await isSignatureCorrect(provider, address, msgHash, signature);
    }
    exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
    async function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {
      from !== null && from !== void 0 ? from : from = ethers_1.ethers.Wallet.createRandom().address;
      if (token == exports.ETH_ADDRESS) {
        return await providerL2.estimateL1ToL2Execute({
          contractAddress: to,
          gasPerPubdataByte,
          caller: from,
          calldata: "0x",
          l2Value: amount
        });
      } else {
        const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;
        const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;
        const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);
        return await providerL2.estimateL1ToL2Execute({
          caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),
          contractAddress: erc20BridgeAddress,
          gasPerPubdataByte,
          calldata
        });
      }
    }
    exports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;
  }
});

// node_modules/zksync-web3/build/src/wallet.js
var require_wallet = __commonJS({
  "node_modules/zksync-web3/build/src/wallet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = void 0;
    var signer_1 = require_signer2();
    var utils_1 = require_utils16();
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var adapters_1 = require_adapters();
    var Wallet = class _Wallet extends (0, adapters_1.AdapterL2)((0, adapters_1.AdapterL1)(ethers_1.ethers.Wallet)) {
      _providerL1() {
        if (this.providerL1 == null) {
          throw new Error("L1 provider missing: use `connectToL1` to specify");
        }
        return this.providerL1;
      }
      _providerL2() {
        return this.provider;
      }
      _signerL1() {
        return this.ethWallet();
      }
      _signerL2() {
        return this;
      }
      ethWallet() {
        return new ethers_1.ethers.Wallet(this._signingKey(), this._providerL1());
      }
      // an alias with a better name
      async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
      }
      connect(provider) {
        return new _Wallet(this._signingKey(), provider, this.providerL1);
      }
      connectToL1(provider) {
        return new _Wallet(this._signingKey(), this.provider, provider);
      }
      static fromMnemonic(mnemonic, path, wordlist) {
        const wallet = super.fromMnemonic(mnemonic, path, wordlist);
        return new _Wallet(wallet._signingKey());
      }
      static async fromEncryptedJson(json, password, callback) {
        const wallet = await super.fromEncryptedJson(json, password, callback);
        return new _Wallet(wallet._signingKey());
      }
      static fromEncryptedJsonSync(json, password) {
        const wallet = super.fromEncryptedJsonSync(json, password);
        return new _Wallet(wallet._signingKey());
      }
      static createRandom(options) {
        const wallet = super.createRandom(options);
        return new _Wallet(wallet._signingKey());
      }
      constructor(privateKey, providerL2, providerL1) {
        super(privateKey, providerL2);
        if (this.provider != null) {
          const chainId = this.getChainId();
          this.eip712 = new signer_1.EIP712Signer(this, chainId);
        }
        this.providerL1 = providerL1;
      }
      async populateTransaction(transaction) {
        var _a, _b;
        if (transaction.type == null && transaction.customData == null) {
          transaction.type = 0;
        }
        transaction = await super.populateTransaction(transaction);
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          return transaction;
        }
        transaction.type = utils_1.EIP712_TX_TYPE;
        (_a = transaction.value) !== null && _a !== void 0 ? _a : transaction.value = 0;
        (_b = transaction.data) !== null && _b !== void 0 ? _b : transaction.data = "0x";
        transaction.customData = this._fillCustomData(transaction.customData);
        transaction.gasPrice = await this.provider.getGasPrice();
        return transaction;
      }
      async signTransaction(transaction) {
        var _a;
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
          if (transaction.type == 2 && transaction.maxFeePerGas == null) {
            transaction.maxFeePerGas = await this.provider.getGasPrice();
          }
          return await super.signTransaction(transaction);
        } else {
          (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = this.address;
          if (transaction.from.toLowerCase() != this.address.toLowerCase()) {
            throw new Error("Transaction `from` address mismatch");
          }
          transaction.customData.customSignature = await this.eip712.sign(transaction);
          return (0, utils_1.serialize)(transaction);
        }
      }
      async sendTransaction(transaction) {
        return await super.sendTransaction(transaction);
      }
    };
    exports.Wallet = Wallet;
  }
});

// node_modules/zksync-web3/build/src/provider.js
var require_provider2 = __commonJS({
  "node_modules/zksync-web3/build/src/provider.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Provider = exports.Provider = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var Formatter = ethers_1.providers.Formatter;
    var web_1 = (init_lib7(), __toCommonJS(lib_exports7));
    var typechain_1 = require_typechain();
    var types_1 = require_types5();
    var utils_1 = require_utils16();
    var signer_1 = require_signer2();
    var defaultFormatter = null;
    var Provider = class _Provider extends ethers_1.ethers.providers.JsonRpcProvider {
      async getTransactionReceipt(transactionHash) {
        await this.getNetwork();
        transactionHash = await transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return (0, web_1.poll)(async () => {
          const result = await this.perform("getTransactionReceipt", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {
            return {
              ...this.formatter.receipt({
                ...result,
                confirmations: 1,
                blockNumber: 0,
                blockHash: ethers_1.ethers.constants.HashZero
              }),
              blockNumber: null,
              blockHash: null,
              l1BatchNumber: null,
              l1BatchTxIndex: null
            };
          }
          if (result.blockHash == null) {
            return void 0;
          } else {
            const receipt = this.formatter.receipt(result);
            if (receipt.blockNumber == null) {
              receipt.confirmations = 0;
            } else if (receipt.confirmations == null) {
              const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - receipt.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              receipt.confirmations = confirmations;
            }
            return receipt;
          }
        }, { oncePoll: this });
      }
      async getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      }
      async getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      }
      static getFormatter() {
        if (defaultFormatter == null) {
          defaultFormatter = new Formatter();
          const number = defaultFormatter.number.bind(defaultFormatter);
          const boolean = defaultFormatter.boolean.bind(defaultFormatter);
          const hash = defaultFormatter.hash.bind(defaultFormatter);
          const address = defaultFormatter.address.bind(defaultFormatter);
          defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.l2Tol1Log = {
            blockNumber: number,
            blockHash: hash,
            l1BatchNumber: Formatter.allowNull(number),
            transactionIndex: number,
            shardId: number,
            isService: boolean,
            sender: address,
            key: hash,
            value: hash,
            transactionHash: hash,
            logIndex: number
          };
          defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);
          defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value) => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));
          defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);
          defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);
          defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);
          defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);
          defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);
        }
        return defaultFormatter;
      }
      async getBalance(address, blockTag, tokenAddress) {
        const tag = this.formatter.blockTag(blockTag);
        if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {
          return await super.getBalance(address, tag);
        } else {
          try {
            let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);
            return await token.balanceOf(address, { blockTag: tag });
          } catch {
            return ethers_1.BigNumber.from(0);
          }
        }
      }
      async l2TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
          return utils_1.ETH_ADDRESS;
        } else {
          const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
          const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
          return await erc20Bridge.l2TokenAddress(token);
        }
      }
      async l1TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
          return utils_1.ETH_ADDRESS;
        } else {
          const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
          const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
          return await erc20Bridge.l1TokenAddress(token);
        }
      }
      // This function is used when formatting requests for
      // eth_call and eth_estimateGas. We override it here
      // because we have extra stuff to serialize (customData).
      // This function is for internal use only.
      static hexlifyTransaction(transaction, allowExtra) {
        var _a;
        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {
          ...allowExtra,
          customData: true,
          from: true
        });
        if (transaction.customData == null) {
          return result;
        }
        result.eip712Meta = {
          gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)
        };
        transaction.type = utils_1.EIP712_TX_TYPE;
        if (transaction.customData.factoryDeps) {
          result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => (
            // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.
            //  We should change deserialization there.
            Array.from(ethers_1.utils.arrayify(dep))
          ));
        }
        if (transaction.customData.paymasterParams) {
          result.eip712Meta.paymasterParams = {
            paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),
            paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))
          };
        }
        return result;
      }
      async estimateGas(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
          params.transaction.customData = transaction.customData;
        }
        const result = await this.perform("estimateGas", params);
        try {
          return ethers_1.BigNumber.from(result);
        } catch (error) {
          throw new Error(`bad result from backend (estimateGas): ${result}`);
        }
      }
      async estimateGasL1(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
          params.transaction.customData = transaction.customData;
        }
        const result = await this.send("zks_estimateGasL1ToL2", [
          _Provider.hexlifyTransaction(params.transaction, { from: true })
        ]);
        try {
          return ethers_1.BigNumber.from(result);
        } catch (error) {
          throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);
        }
      }
      async getGasPrice(token) {
        const params = token ? [token] : [];
        const price = await this.send("eth_gasPrice", params);
        return ethers_1.BigNumber.from(price);
      }
      constructor(url, network) {
        super(url, network);
        this.pollingInterval = 500;
        const blockTag = this.formatter.blockTag.bind(this.formatter);
        this.formatter.blockTag = (tag) => {
          if (tag == "committed" || tag == "finalized") {
            return tag;
          }
          return blockTag(tag);
        };
        this.contractAddresses = {};
        this.formatter.transaction = utils_1.parseTransaction;
      }
      async getMessageProof(blockNumber, sender, messageHash, logIndex) {
        return await this.send("zks_getL2ToL1MsgProof", [
          ethers_1.BigNumber.from(blockNumber).toNumber(),
          sender,
          ethers_1.ethers.utils.hexlify(messageHash),
          logIndex
        ]);
      }
      async getLogProof(txHash, index) {
        return await this.send("zks_getL2ToL1LogProof", [ethers_1.ethers.utils.hexlify(txHash), index]);
      }
      async getL1BatchBlockRange(l1BatchNumber) {
        const range = await this.send("zks_getL1BatchBlockRange", [l1BatchNumber]);
        if (range == null) {
          return null;
        }
        return [parseInt(range[0], 16), parseInt(range[1], 16)];
      }
      async getMainContractAddress() {
        if (!this.contractAddresses.mainContract) {
          this.contractAddresses.mainContract = await this.send("zks_getMainContract", []);
        }
        return this.contractAddresses.mainContract;
      }
      async getTestnetPaymasterAddress() {
        return await this.send("zks_getTestnetPaymaster", []);
      }
      async getDefaultBridgeAddresses() {
        if (!this.contractAddresses.erc20BridgeL1) {
          let addresses = await this.send("zks_getBridgeContracts", []);
          this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
          this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
        }
        return {
          erc20L1: this.contractAddresses.erc20BridgeL1,
          erc20L2: this.contractAddresses.erc20BridgeL2
        };
      }
      async getConfirmedTokens(start = 0, limit = 255) {
        const tokens = await this.send("zks_getConfirmedTokens", [start, limit]);
        return tokens.map((token) => ({ address: token.l2Address, ...token }));
      }
      async getTokenPrice(token) {
        return await this.send("zks_getTokenPrice", [token]);
      }
      async getAllAccountBalances(address) {
        let balances = await this.send("zks_getAllAccountBalances", [address]);
        for (let token in balances) {
          balances[token] = ethers_1.BigNumber.from(balances[token]);
        }
        return balances;
      }
      async l1ChainId() {
        const res = await this.send("zks_L1ChainId", []);
        return ethers_1.BigNumber.from(res).toNumber();
      }
      async getL1BatchNumber() {
        const number = await this.send("zks_L1BatchNumber", []);
        return ethers_1.BigNumber.from(number).toNumber();
      }
      async getL1BatchDetails(number) {
        return await this.send("zks_getL1BatchDetails", [number]);
      }
      async getBlockDetails(number) {
        return await this.send("zks_getBlockDetails", [number]);
      }
      async getTransactionDetails(txHash) {
        return await this.send("zks_getTransactionDetails", [txHash]);
      }
      async getWithdrawTx(transaction) {
        var _a, _b, _c;
        var _d;
        const { ...tx } = transaction;
        if (tx.to == null && tx.from == null) {
          throw new Error("withdrawal target address is undefined");
        }
        (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = tx.from;
        (_b = tx.overrides) !== null && _b !== void 0 ? _b : tx.overrides = {};
        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : _d.from = tx.from;
        if ((0, utils_1.isETH)(tx.token)) {
          if (!tx.overrides.value) {
            tx.overrides.value = tx.amount;
          }
          const passedValue = ethers_1.BigNumber.from(tx.overrides.value);
          if (!passedValue.eq(tx.amount)) {
            throw new Error("The tx.value is not equal to the value withdrawn");
          }
          const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);
          return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);
        }
        if (tx.bridgeAddress == null) {
          const bridges = await this.getDefaultBridgeAddresses();
          tx.bridgeAddress = bridges.erc20L2;
        }
        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);
        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);
      }
      async estimateGasWithdraw(transaction) {
        const withdrawTx = await this.getWithdrawTx(transaction);
        return await this.estimateGas(withdrawTx);
      }
      async getTransferTx(transaction) {
        var _a, _b;
        var _c;
        const { ...tx } = transaction;
        (_a = tx.overrides) !== null && _a !== void 0 ? _a : tx.overrides = {};
        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : _c.from = tx.from;
        if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {
          return {
            ...await ethers_1.ethers.utils.resolveProperties(tx.overrides),
            to: tx.to,
            value: tx.amount
          };
        } else {
          const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);
          return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);
        }
      }
      async estimateGasTransfer(transaction) {
        const transferTx = await this.getTransferTx(transaction);
        return await this.estimateGas(transferTx);
      }
      static getDefaultProvider() {
        return new _Provider(process.env.ZKSYNC_WEB3_API_URL || "http://localhost:3050");
      }
      async newFilter(filter2) {
        filter2 = await filter2;
        const id = await this.send("eth_newFilter", [this._prepareFilter(filter2)]);
        return ethers_1.BigNumber.from(id);
      }
      async newBlockFilter() {
        const id = await this.send("eth_newBlockFilter", []);
        return ethers_1.BigNumber.from(id);
      }
      async newPendingTransactionsFilter() {
        const id = await this.send("eth_newPendingTransactionFilter", []);
        return ethers_1.BigNumber.from(id);
      }
      async getFilterChanges(idx) {
        const logs = await this.send("eth_getFilterChanges", [idx.toHexString()]);
        return typeof logs[0] === "string" ? logs : this._parseLogs(logs);
      }
      async getLogs(filter2 = {}) {
        filter2 = await filter2;
        const logs = await this.send("eth_getLogs", [this._prepareFilter(filter2)]);
        return this._parseLogs(logs);
      }
      _parseLogs(logs) {
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
      }
      _prepareFilter(filter2) {
        return {
          ...filter2,
          fromBlock: filter2.fromBlock == null ? null : this.formatter.blockTag(filter2.fromBlock),
          toBlock: filter2.fromBlock == null ? null : this.formatter.blockTag(filter2.toBlock)
        };
      }
      _wrapTransaction(tx, hash) {
        const response = super._wrapTransaction(tx, hash);
        response.waitFinalize = async () => {
          const receipt = await response.wait();
          while (true) {
            const block = await this.getBlock("finalized");
            if (receipt.blockNumber <= block.number) {
              return await this.getTransactionReceipt(receipt.transactionHash);
            } else {
              await (0, utils_1.sleep)(this.pollingInterval);
            }
          }
        };
        return response;
      }
      // This is inefficient. Status should probably be indicated in the transaction receipt.
      async getTransactionStatus(txHash) {
        const tx = await this.getTransaction(txHash);
        if (tx == null) {
          return types_1.TransactionStatus.NotFound;
        }
        if (tx.blockNumber == null) {
          return types_1.TransactionStatus.Processing;
        }
        const verifiedBlock = await this.getBlock("finalized");
        if (tx.blockNumber <= verifiedBlock.number) {
          return types_1.TransactionStatus.Finalized;
        }
        return types_1.TransactionStatus.Committed;
      }
      async getTransaction(hash) {
        hash = await hash;
        const tx = await super.getTransaction(hash);
        return tx ? this._wrapTransaction(tx, hash) : null;
      }
      async sendTransaction(transaction) {
        return await super.sendTransaction(transaction);
      }
      async getL2TransactionFromPriorityOp(l1TxResponse) {
        const receipt = await l1TxResponse.wait();
        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
          status = await this.getTransactionStatus(l2Hash);
          await (0, utils_1.sleep)(this.pollingInterval);
        } while (status == types_1.TransactionStatus.NotFound);
        return await this.getTransaction(l2Hash);
      }
      async getPriorityOpResponse(l1TxResponse) {
        const l2Response = { ...l1TxResponse };
        l2Response.waitL1Commit = l2Response.wait;
        l2Response.wait = async () => {
          const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
          return await l2Tx.wait();
        };
        l2Response.waitFinalize = async () => {
          const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
          return await l2Tx.waitFinalize();
        };
        return l2Response;
      }
      async getContractAccountInfo(address) {
        const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);
        const data = await deployerContract.getAccountInfo(address);
        return {
          supportedAAVersion: data.supportedAAVersion,
          nonceOrdering: data.nonceOrdering
        };
      }
      // TODO (EVM-3): support refundRecipient for fee estimation
      async estimateL1ToL2Execute(transaction) {
        var _a, _b;
        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
        (_b = transaction.caller) !== null && _b !== void 0 ? _b : transaction.caller = ethers_1.ethers.Wallet.createRandom().address;
        const customData = {
          gasPerPubdataByte: transaction.gasPerPubdataByte
        };
        if (transaction.factoryDeps) {
          Object.assign(customData, { factoryDeps: transaction.factoryDeps });
        }
        const fee = await this.estimateGasL1({
          from: transaction.caller,
          data: transaction.calldata,
          to: transaction.contractAddress,
          value: transaction.l2Value,
          customData
        });
        return fee;
      }
    };
    exports.Provider = Provider;
    var Web3Provider = class extends Provider {
      constructor(provider, network) {
        if (provider == null) {
          throw new Error("missing provider");
        }
        if (!provider.request) {
          throw new Error("provider must implement eip-1193");
        }
        let path = provider.host || provider.path || (provider.isMetaMask ? "metamask" : "eip-1193:");
        super(path, network);
        this.provider = provider;
      }
      async send(method, params) {
        params !== null && params !== void 0 ? params : params = [];
        if (method == "eth_sign" && (this.provider.isMetaMask || this.provider.isStatus)) {
          method = "personal_sign";
          params = [params[1], params[0]];
        }
        return await this.provider.request({ method, params });
      }
      getSigner(addressOrIndex) {
        return signer_1.Signer.from(super.getSigner(addressOrIndex));
      }
      async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = ethers_1.BigNumber.from(21e3);
        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;
        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;
      }
    };
    exports.Web3Provider = Web3Provider;
  }
});

// node_modules/zksync-web3/build/src/contract.js
var require_contract = __commonJS({
  "node_modules/zksync-web3/build/src/contract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractFactory = exports.Contract = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var utils_1 = require_utils16();
    var types_1 = require_types5();
    var ethers_2 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return ethers_2.Contract;
    } });
    var ContractFactory = class extends ethers_1.ethers.ContractFactory {
      constructor(abi, bytecode, signer, deploymentType) {
        super(abi, bytecode, signer);
        this.deploymentType = deploymentType || "create";
      }
      encodeCalldata(salt, bytecodeHash, constructorCalldata) {
        if (this.deploymentType == "create") {
          return utils_1.CONTRACT_DEPLOYER.encodeFunctionData("create", [salt, bytecodeHash, constructorCalldata]);
        } else if (this.deploymentType == "createAccount") {
          return utils_1.CONTRACT_DEPLOYER.encodeFunctionData("createAccount", [
            salt,
            bytecodeHash,
            constructorCalldata,
            types_1.AccountAbstractionVersion.Version1
          ]);
        } else {
          throw new Error(`Unsupported deployment type ${this.deploymentType}`);
        }
      }
      getDeployTransaction(...args) {
        var _a, _b, _c;
        var _d, _e;
        let salt = "0x0000000000000000000000000000000000000000000000000000000000000000";
        const txRequest = super.getDeployTransaction(...args);
        if (this.interface.deploy.inputs.length + 1 == args.length) {
          args.pop();
        }
        const bytecodeHash = (0, utils_1.hashBytecode)(this.bytecode);
        const constructorCalldata = ethers_1.utils.arrayify(this.interface.encodeDeploy(args));
        const deployCalldata = this.encodeCalldata(salt, bytecodeHash, constructorCalldata);
        txRequest.type = utils_1.EIP712_TX_TYPE;
        txRequest.to = utils_1.CONTRACT_DEPLOYER_ADDRESS;
        txRequest.data = deployCalldata;
        (_a = txRequest.customData) !== null && _a !== void 0 ? _a : txRequest.customData = {};
        (_b = (_d = txRequest.customData).factoryDeps) !== null && _b !== void 0 ? _b : _d.factoryDeps = [];
        (_c = (_e = txRequest.customData).gasPerPubdata) !== null && _c !== void 0 ? _c : _e.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        if (!txRequest.customData.factoryDeps.includes(this.bytecode)) {
          txRequest.customData.factoryDeps.push(this.bytecode);
        }
        return txRequest;
      }
      async deploy(...args) {
        const contract = await super.deploy(...args);
        const deployTxReceipt = await contract.deployTransaction.wait();
        const deployedAddresses = (0, utils_1.getDeployedContracts)(deployTxReceipt).map((info) => info.deployedAddress);
        const contractWithCorrectAddress = new ethers_1.ethers.Contract(deployedAddresses[deployedAddresses.length - 1], contract.interface, contract.signer);
        ethers_1.utils.defineReadOnly(contractWithCorrectAddress, "deployTransaction", contract.deployTransaction);
        return contractWithCorrectAddress;
      }
    };
    exports.ContractFactory = ContractFactory;
  }
});

// node_modules/zksync-web3/build/src/index.js
var require_src7 = __commonJS({
  "node_modules/zksync-web3/build/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = exports.ContractFactory = exports.Provider = exports.Web3Provider = exports.Wallet = exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.types = exports.utils = void 0;
    exports.utils = __importStar(require_utils16());
    exports.types = __importStar(require_types5());
    var signer_1 = require_signer2();
    Object.defineProperty(exports, "EIP712Signer", { enumerable: true, get: function() {
      return signer_1.EIP712Signer;
    } });
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return signer_1.Signer;
    } });
    Object.defineProperty(exports, "L1Signer", { enumerable: true, get: function() {
      return signer_1.L1Signer;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return wallet_1.Wallet;
    } });
    var provider_1 = require_provider2();
    Object.defineProperty(exports, "Web3Provider", { enumerable: true, get: function() {
      return provider_1.Web3Provider;
    } });
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return provider_1.Provider;
    } });
    var contract_1 = require_contract();
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return contract_1.ContractFactory;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contract_1.Contract;
    } });
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/safeFactory/utils.js
var require_utils17 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/safeFactory/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSafeDeploymentConfig = exports.validateSafeAccountConfig = void 0;
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var validateSafeAccountConfig = ({ owners, threshold }) => {
      if (owners.length <= 0)
        throw new Error("Owner list must have at least one owner");
      if (threshold <= 0)
        throw new Error("Threshold must be greater than or equal to 1");
      if (threshold > owners.length)
        throw new Error("Threshold must be lower than or equal to owners length");
    };
    exports.validateSafeAccountConfig = validateSafeAccountConfig;
    var validateSafeDeploymentConfig = ({ saltNonce }) => {
      if (bignumber_1.BigNumber.from(saltNonce).lt(0))
        throw new Error("saltNonce must be greater than or equal to 0");
    };
    exports.validateSafeDeploymentConfig = validateSafeDeploymentConfig;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/safeFactory/index.js
var require_safeFactory = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/safeFactory/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _SafeFactory_contractNetworks;
    var _SafeFactory_isL1SafeMasterCopy;
    var _SafeFactory_safeVersion;
    var _SafeFactory_ethAdapter;
    var _SafeFactory_safeProxyFactoryContract;
    var _SafeFactory_gnosisSafeContract;
    Object.defineProperty(exports, "__esModule", { value: true });
    var ethereumjs_util_1 = require_dist9();
    var satisfies_1 = __importDefault(require_satisfies3());
    var zksync_web3_1 = require_src7();
    var config_1 = require_config();
    var safeDeploymentContracts_1 = require_safeDeploymentContracts();
    var Safe_1 = __importDefault(require_Safe());
    var constants_1 = require_constants5();
    var utils_1 = require_utils17();
    var ZKSYNC_MAINNET = 324;
    var ZKSYNC_TESTNET = 280;
    var ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE = {
      "1.3.0": {
        deployedBytecodeHash: "0x0100004124426fb9ebb25e27d670c068e52f9ba631bd383279a188be47e3f86d"
      }
    };
    var SafeFactory = class _SafeFactory {
      constructor() {
        _SafeFactory_contractNetworks.set(this, void 0);
        _SafeFactory_isL1SafeMasterCopy.set(this, void 0);
        _SafeFactory_safeVersion.set(this, void 0);
        _SafeFactory_ethAdapter.set(this, void 0);
        _SafeFactory_safeProxyFactoryContract.set(this, void 0);
        _SafeFactory_gnosisSafeContract.set(this, void 0);
      }
      static async create({ ethAdapter, safeVersion = config_1.SAFE_LAST_VERSION, isL1SafeMasterCopy = false, contractNetworks }) {
        const safeFactorySdk = new _SafeFactory();
        await safeFactorySdk.init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks });
        return safeFactorySdk;
      }
      async init({ ethAdapter, safeVersion, isL1SafeMasterCopy, contractNetworks }) {
        __classPrivateFieldSet(this, _SafeFactory_ethAdapter, ethAdapter, "f");
        __classPrivateFieldSet(this, _SafeFactory_safeVersion, safeVersion, "f");
        __classPrivateFieldSet(this, _SafeFactory_isL1SafeMasterCopy, isL1SafeMasterCopy, "f");
        __classPrivateFieldSet(this, _SafeFactory_contractNetworks, contractNetworks, "f");
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        const customContracts = contractNetworks === null || contractNetworks === void 0 ? void 0 : contractNetworks[chainId];
        __classPrivateFieldSet(this, _SafeFactory_safeProxyFactoryContract, await (0, safeDeploymentContracts_1.getProxyFactoryContract)({
          ethAdapter,
          safeVersion,
          chainId,
          customContracts
        }), "f");
        __classPrivateFieldSet(this, _SafeFactory_gnosisSafeContract, await (0, safeDeploymentContracts_1.getSafeContract)({
          ethAdapter,
          safeVersion,
          chainId,
          isL1SafeMasterCopy,
          customContracts
        }), "f");
      }
      getEthAdapter() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f");
      }
      getSafeVersion() {
        return __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f");
      }
      getAddress() {
        return __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").getAddress();
      }
      async getChainId() {
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
      }
      async encodeSetupCallData({ owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS }) {
        var _a;
        if ((0, satisfies_1.default)(__classPrivateFieldGet(this, _SafeFactory_safeVersion, "f"), "<=1.0.0")) {
          return __classPrivateFieldGet(this, _SafeFactory_gnosisSafeContract, "f").encode("setup", [
            owners,
            threshold,
            to,
            data,
            paymentToken,
            payment,
            paymentReceiver
          ]);
        }
        let fallbackHandlerAddress;
        if (fallbackHandler) {
          fallbackHandlerAddress = fallbackHandler;
        } else {
          const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
          const customContracts = (_a = __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")) === null || _a === void 0 ? void 0 : _a[chainId];
          const fallbackHandlerContract = await (0, safeDeploymentContracts_1.getCompatibilityFallbackHandlerContract)({
            ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
            safeVersion: __classPrivateFieldGet(this, _SafeFactory_safeVersion, "f"),
            chainId,
            customContracts
          });
          fallbackHandlerAddress = fallbackHandlerContract.getAddress();
        }
        return __classPrivateFieldGet(this, _SafeFactory_gnosisSafeContract, "f").encode("setup", [
          owners,
          threshold,
          to,
          data,
          fallbackHandlerAddress,
          paymentToken,
          payment,
          paymentReceiver
        ]);
      }
      async predictSafeAddress({ safeAccountConfig, safeDeploymentConfig }) {
        (0, utils_1.validateSafeAccountConfig)(safeAccountConfig);
        (0, utils_1.validateSafeDeploymentConfig)(safeDeploymentConfig);
        const from = __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").getAddress();
        const initializer = await this.encodeSetupCallData(safeAccountConfig);
        const saltNonce = safeDeploymentConfig.saltNonce;
        const encodedNonce = (0, ethereumjs_util_1.toBuffer)(__classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").encodeParameters(["uint256"], [saltNonce])).toString("hex");
        const salt = (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)("0x" + (0, ethereumjs_util_1.keccak256)((0, ethereumjs_util_1.toBuffer)(initializer)).toString("hex") + encodedNonce));
        const proxyCreationCode = await __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").proxyCreationCode();
        const input = __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").encodeParameters(["address"], [__classPrivateFieldGet(this, _SafeFactory_gnosisSafeContract, "f").getAddress()]);
        const chainId = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChainId();
        if ([ZKSYNC_MAINNET, ZKSYNC_TESTNET].includes(chainId)) {
          const safeVersion = await __classPrivateFieldGet(this, _SafeFactory_gnosisSafeContract, "f").getVersion();
          const bytecodeHash = ZKSYNC_SAFE_PROXY_DEPLOYED_BYTECODE[safeVersion].deployedBytecodeHash;
          return zksync_web3_1.utils.create2Address(from, bytecodeHash, salt, input);
        }
        const constructorData = (0, ethereumjs_util_1.toBuffer)(input).toString("hex");
        const initCode = proxyCreationCode + constructorData;
        const proxyAddress = "0x" + (0, ethereumjs_util_1.generateAddress2)((0, ethereumjs_util_1.toBuffer)(from), (0, ethereumjs_util_1.toBuffer)(salt), (0, ethereumjs_util_1.toBuffer)(initCode)).toString("hex");
        return __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getChecksummedAddress(proxyAddress);
      }
      async deploySafe({ safeAccountConfig, safeDeploymentConfig, options, callback }) {
        var _a;
        (0, utils_1.validateSafeAccountConfig)(safeAccountConfig);
        if (safeDeploymentConfig) {
          (0, utils_1.validateSafeDeploymentConfig)(safeDeploymentConfig);
        }
        const signerAddress = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").getSignerAddress();
        if (!signerAddress) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const initializer = await this.encodeSetupCallData(safeAccountConfig);
        const saltNonce = (_a = safeDeploymentConfig === null || safeDeploymentConfig === void 0 ? void 0 : safeDeploymentConfig.saltNonce) !== null && _a !== void 0 ? _a : (Date.now() * 1e3 + Math.floor(Math.random() * 1e3)).toString();
        if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {
          throw new Error("Cannot specify gas and gasLimit together in transaction options");
        }
        const safeAddress = await __classPrivateFieldGet(this, _SafeFactory_safeProxyFactoryContract, "f").createProxy({
          safeMasterCopyAddress: __classPrivateFieldGet(this, _SafeFactory_gnosisSafeContract, "f").getAddress(),
          initializer,
          saltNonce,
          options: {
            from: signerAddress,
            ...options
          },
          callback
        });
        const isContractDeployed = await __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f").isContractDeployed(safeAddress);
        if (!isContractDeployed) {
          throw new Error("SafeProxy contract is not deployed on the current network");
        }
        const safe = await Safe_1.default.create({
          ethAdapter: __classPrivateFieldGet(this, _SafeFactory_ethAdapter, "f"),
          safeAddress,
          isL1SafeMasterCopy: __classPrivateFieldGet(this, _SafeFactory_isL1SafeMasterCopy, "f"),
          contractNetworks: __classPrivateFieldGet(this, _SafeFactory_contractNetworks, "f")
        });
        return safe;
      }
    };
    _SafeFactory_contractNetworks = /* @__PURE__ */ new WeakMap(), _SafeFactory_isL1SafeMasterCopy = /* @__PURE__ */ new WeakMap(), _SafeFactory_safeVersion = /* @__PURE__ */ new WeakMap(), _SafeFactory_ethAdapter = /* @__PURE__ */ new WeakMap(), _SafeFactory_safeProxyFactoryContract = /* @__PURE__ */ new WeakMap(), _SafeFactory_gnosisSafeContract = /* @__PURE__ */ new WeakMap();
    exports.default = SafeFactory;
  }
});

// node_modules/@safe-global/safe-core-sdk/dist/src/index.js
var require_src8 = __commonJS({
  "node_modules/@safe-global/safe-core-sdk/dist/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.standardizeSafeTransactionData = exports.SafeFactory = exports.ContractManager = void 0;
    var contractManager_1 = __importDefault(require_contractManager());
    exports.ContractManager = contractManager_1.default;
    var Safe_1 = __importDefault(require_Safe());
    var safeFactory_1 = __importDefault(require_safeFactory());
    exports.SafeFactory = safeFactory_1.default;
    var utils_1 = require_utils15();
    Object.defineProperty(exports, "standardizeSafeTransactionData", { enumerable: true, get: function() {
      return utils_1.standardizeSafeTransactionData;
    } });
    exports.default = Safe_1.default;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        constant: false,
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "DOMAIN_SEPARATOR_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "",
            type: "address"
          },
          {
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SENTINEL_MODULES",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SENTINEL_OWNERS",
        outputs: [
          {
            name: "",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SAFE_MSG_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "SAFE_TX_TYPEHASH",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevModule",
            type: "address"
          },
          {
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevOwner",
            type: "address"
          },
          {
            name: "oldOwner",
            type: "address"
          },
          {
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "prevOwner",
            type: "address"
          },
          {
            name: "owner",
            type: "address"
          },
          {
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "txHash",
            type: "bytes32"
          }
        ],
        name: "ExecutionFailed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "newContract",
            type: "address"
          }
        ],
        name: "ContractCreation",
        type: "event"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_owners",
            type: "address[]"
          },
          {
            name: "_threshold",
            type: "uint256"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "paymentToken",
            type: "address"
          },
          {
            name: "payment",
            type: "uint256"
          },
          {
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "_data",
            type: "bytes"
          },
          {
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          },
          {
            name: "operation",
            type: "uint8"
          },
          {
            name: "safeTxGas",
            type: "uint256"
          },
          {
            name: "baseGas",
            type: "uint256"
          },
          {
            name: "gasPrice",
            type: "uint256"
          },
          {
            name: "gasToken",
            type: "address"
          },
          {
            name: "refundReceiver",
            type: "address"
          },
          {
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.0.0/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        constant: false,
        inputs: [
          {
            name: "_mastercopy",
            type: "address"
          },
          {
            name: "initializer",
            type: "bytes"
          },
          {
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            name: "masterCopy",
            type: "address"
          },
          {
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            name: "proxy",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory2 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "masterCopy",
            type: "address"
          }
        ],
        name: "ChangedMasterCopy",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Multi_send__factory.js
var require_Multi_send_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Multi_send__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Multi_send__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send__factory = Multi_send__factory;
    Multi_send__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory2 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.1.1/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "masterCopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          },
          {
            internalType: "contract IProxyCreationCallback",
            name: "callback",
            type: "address"
          }
        ],
        name: "createProxyWithCallback",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_mastercopy",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.2.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory3 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.2.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "masterCopy",
            type: "address"
          }
        ],
        name: "ChangedMasterCopy",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        payable: true,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: true,
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "_masterCopy",
            type: "address"
          }
        ],
        name: "changeMasterCopy",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "contract Module",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        payable: true,
        stateMutability: "payable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: false,
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: true,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: false,
        stateMutability: "view",
        type: "function"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Compatibility_fallback_handler__factory.js
var require_Compatibility_fallback_handler_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Compatibility_fallback_handler__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compatibility_fallback_handler__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract GnosisSafe",
            name: "safe",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHashForSafe",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getModules",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "_dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        name: "isValidSignature",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155BatchReceived",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC1155Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulate",
        outputs: [
          {
            internalType: "bytes",
            name: "response",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "tokensReceived",
        outputs: [],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Compatibility_fallback_handler__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Compatibility_fallback_handler__factory = Compatibility_fallback_handler__factory;
    Compatibility_fallback_handler__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Gnosis_safe__factory.js
var require_Gnosis_safe_factory4 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Gnosis_safe__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gnosis_safe__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "AddedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "approvedHash",
            type: "bytes32"
          },
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "ApproveHash",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "ChangedFallbackHandler",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "ChangedGuard",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          }
        ],
        name: "ChangedThreshold",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "DisabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "EnabledModule",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "bytes32",
            name: "txHash",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          }
        ],
        name: "ExecutionSuccess",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "RemovedOwner",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "SafeReceived",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "initiator",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "threshold",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "address",
            name: "initializer",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          }
        ],
        name: "SafeSetup",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        stateMutability: "nonpayable",
        type: "fallback"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "addOwnerWithThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "hashToApprove",
            type: "bytes32"
          }
        ],
        name: "approveHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "approvedHashes",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "changeThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "requiredSignatures",
            type: "uint256"
          }
        ],
        name: "checkNSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "dataHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "checkSignatures",
        outputs: [],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevModule",
            type: "address"
          },
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "domainSeparator",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "encodeTransactionData",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "signatures",
            type: "bytes"
          }
        ],
        name: "execTransaction",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "returnData",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getChainId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "start",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "pageSize",
            type: "uint256"
          }
        ],
        name: "getModulesPaginated",
        outputs: [
          {
            internalType: "address[]",
            name: "array",
            type: "address[]"
          },
          {
            internalType: "address",
            name: "next",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwners",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "offset",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "length",
            type: "uint256"
          }
        ],
        name: "getStorageAt",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "safeTxGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseGas",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gasPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "gasToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "refundReceiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          }
        ],
        name: "getTransactionHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          }
        ],
        name: "isModuleEnabled",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "nonce",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          }
        ],
        name: "removeOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          }
        ],
        name: "requiredTxGas",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "handler",
            type: "address"
          }
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "_threshold",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "fallbackHandler",
            type: "address"
          },
          {
            internalType: "address",
            name: "paymentToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "payment",
            type: "uint256"
          },
          {
            internalType: "address payable",
            name: "paymentReceiver",
            type: "address"
          }
        ],
        name: "setup",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "signedMessages",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "targetContract",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "calldataPayload",
            type: "bytes"
          }
        ],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "prevOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "oldOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "swapOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
    var Gnosis_safe__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Gnosis_safe__factory = Gnosis_safe__factory;
    Gnosis_safe__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send_call_only__factory.js
var require_Multi_send_call_only_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send_call_only__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send_call_only__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send_call_only__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send_call_only__factory = Multi_send_call_only__factory;
    Multi_send_call_only__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send__factory.js
var require_Multi_send_factory2 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Multi_send__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Multi_send__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "transactions",
            type: "bytes"
          }
        ],
        name: "multiSend",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      }
    ];
    var Multi_send__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Multi_send__factory = Multi_send__factory;
    Multi_send__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Proxy_factory__factory.js
var require_Proxy_factory_factory3 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Proxy_factory__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Proxy_factory__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "singleton",
            type: "address"
          }
        ],
        name: "ProxyCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "calculateCreateProxyWithNonceAddress",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "createProxy",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          },
          {
            internalType: "contract IProxyCreationCallback",
            name: "callback",
            type: "address"
          }
        ],
        name: "createProxyWithCallback",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_singleton",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initializer",
            type: "bytes"
          },
          {
            internalType: "uint256",
            name: "saltNonce",
            type: "uint256"
          }
        ],
        name: "createProxyWithNonce",
        outputs: [
          {
            internalType: "contract GnosisSafeProxy",
            name: "proxy",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "proxyCreationCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "proxyRuntimeCode",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "pure",
        type: "function"
      }
    ];
    var Proxy_factory__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Proxy_factory__factory = Proxy_factory__factory;
    Proxy_factory__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Sign_message_lib__factory.js
var require_Sign_message_lib_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Sign_message_lib__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sign_message_lib__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "bytes32",
            name: "msgHash",
            type: "bytes32"
          }
        ],
        name: "SignMsg",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "message",
            type: "bytes"
          }
        ],
        name: "getMessageHash",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
          }
        ],
        name: "signMessage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Sign_message_lib__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Sign_message_lib__factory = Sign_message_lib__factory;
    Sign_message_lib__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Create_call__factory.js
var require_Create_call_factory = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/typechain/src/ethers-v5/v1.3.0/factories/Create_call__factory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Create_call__factory = void 0;
    var ethers_1 = (init_lib9(), __toCommonJS(lib_exports9));
    var _abi = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        name: "ContractCreation",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          }
        ],
        name: "performCreate",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "deploymentData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "salt",
            type: "bytes32"
          }
        ],
        name: "performCreate2",
        outputs: [
          {
            internalType: "address",
            name: "newContract",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    var Create_call__factory = class {
      static createInterface() {
        return new ethers_1.utils.Interface(_abi);
      }
      static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
      }
    };
    exports.Create_call__factory = Create_call__factory;
    Create_call__factory.abi = _abi;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerEthersContract.js
var require_CompatibilityFallbackHandlerEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CompatibilityFallbackHandler/CompatibilityFallbackHandlerEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = CompatibilityFallbackHandlerEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Ethers.js
var require_CompatibilityFallbackHandler_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CompatibilityFallbackHandler/v1.3.0/CompatibilityFallbackHandler_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CompatibilityFallbackHandlerEthersContract_1 = __importDefault(require_CompatibilityFallbackHandlerEthersContract());
    var CompatibilityFallbackHandler_V1_3_0_Ethers = class extends CompatibilityFallbackHandlerEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CompatibilityFallbackHandler_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/utils/index.js
var require_utils18 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/utils/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTypedDataSigner = exports.toTxResult = exports.sameString = void 0;
    function sameString(str1, str2) {
      return str1.toLowerCase() === str2.toLowerCase();
    }
    exports.sameString = sameString;
    function toTxResult(transactionResponse, options) {
      return {
        hash: transactionResponse.hash,
        options,
        transactionResponse
      };
    }
    exports.toTxResult = toTxResult;
    function isTypedDataSigner(signer) {
      return signer._signTypedData !== void 0;
    }
    exports.isTypedDataSigner = isTypedDataSigner;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CreateCall/CreateCallEthersContract.js
var require_CreateCallEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CreateCall/CreateCallEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var CreateCallEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      async performCreate2(value, deploymentData, salt, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("performCreate2", [value, deploymentData, salt], {
            ...options
          });
        }
        const txResponse = await this.contract.performCreate2(value, deploymentData, salt, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async performCreate(value, deploymentData, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("performCreate", [value, deploymentData], {
            ...options
          });
        }
        const txResponse = await this.contract.performCreate(value, deploymentData, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();
      }
    };
    exports.default = CreateCallEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Ethers.js
var require_CreateCallEthersContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/CreateCall/v1.3.0/CreateCallEthersContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CreateCallEthersContract_1 = __importDefault(require_CreateCallEthersContract());
    var CreateCallContract_V1_3_0_Ethers = class extends CreateCallEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = CreateCallContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/utils/constants.js
var require_constants8 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/utils/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENTINEL_ADDRESS = exports.EMPTY_DATA = exports.ZERO_ADDRESS = void 0;
    exports.ZERO_ADDRESS = `0x${"0".repeat(40)}`;
    exports.EMPTY_DATA = "0x";
    exports.SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/GnosisSafeContractEthers.js
var require_GnosisSafeContractEthers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/GnosisSafeContractEthers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var GnosisSafeContractEthers = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      async getVersion() {
        return await this.contract.VERSION();
      }
      getAddress() {
        return this.contract.address;
      }
      async getNonce() {
        return (await this.contract.nonce()).toNumber();
      }
      async getThreshold() {
        return (await this.contract.getThreshold()).toNumber();
      }
      async getOwners() {
        return this.contract.getOwners();
      }
      async isOwner(address) {
        return this.contract.isOwner(address);
      }
      async getTransactionHash(safeTransactionData) {
        return this.contract.getTransactionHash(safeTransactionData.to, safeTransactionData.value, safeTransactionData.data, safeTransactionData.operation, safeTransactionData.safeTxGas, safeTransactionData.baseGas, safeTransactionData.gasPrice, safeTransactionData.gasToken, safeTransactionData.refundReceiver, safeTransactionData.nonce);
      }
      async approvedHashes(ownerAddress, hash) {
        return this.contract.approvedHashes(ownerAddress, hash);
      }
      async approveHash(hash, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("approveHash", [hash], { ...options });
        }
        const txResponse = await this.contract.approveHash(hash, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async isValidTransaction(safeTransaction, options) {
        let isTxValid = false;
        try {
          if (options && !options.gasLimit) {
            options.gasLimit = await this.estimateGas("execTransaction", [
              safeTransaction.data.to,
              safeTransaction.data.value,
              safeTransaction.data.data,
              safeTransaction.data.operation,
              safeTransaction.data.safeTxGas,
              safeTransaction.data.baseGas,
              safeTransaction.data.gasPrice,
              safeTransaction.data.gasToken,
              safeTransaction.data.refundReceiver,
              safeTransaction.encodedSignatures()
            ], {
              ...options
            });
          }
          isTxValid = await this.contract.callStatic.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        } catch {
        }
        return isTxValid;
      }
      async execTransaction(safeTransaction, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("execTransaction", [
            safeTransaction.data.to,
            safeTransaction.data.value,
            safeTransaction.data.data,
            safeTransaction.data.operation,
            safeTransaction.data.safeTxGas,
            safeTransaction.data.baseGas,
            safeTransaction.data.gasPrice,
            safeTransaction.data.gasToken,
            safeTransaction.data.refundReceiver,
            safeTransaction.encodedSignatures()
          ], {
            ...options
          });
        }
        const txResponse = await this.contract.execTransaction(safeTransaction.data.to, safeTransaction.data.value, safeTransaction.data.data, safeTransaction.data.operation, safeTransaction.data.safeTxGas, safeTransaction.data.baseGas, safeTransaction.data.gasPrice, safeTransaction.data.gasToken, safeTransaction.data.refundReceiver, safeTransaction.encodedSignatures(), options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();
      }
    };
    exports.default = GnosisSafeContractEthers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.0.0/GnosisSafeContract_V1_0_0_Ethers.js
var require_GnosisSafeContract_V1_0_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.0.0/GnosisSafeContract_V1_0_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants8();
    var utils_1 = require_utils18();
    var GnosisSafeContractEthers_1 = __importDefault(require_GnosisSafeContractEthers());
    var GnosisSafeContract_V1_0_0_Ethers = class extends GnosisSafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = GnosisSafeContract_V1_0_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.1.1/GnosisSafeContract_V1_1_1_Ethers.js
var require_GnosisSafeContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.1.1/GnosisSafeContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants8();
    var utils_1 = require_utils18();
    var GnosisSafeContractEthers_1 = __importDefault(require_GnosisSafeContractEthers());
    var GnosisSafeContract_V1_1_1_Ethers = class extends GnosisSafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        const modules = await this.getModules();
        const isModuleEnabled = modules.some((enabledModuleAddress) => (0, utils_1.sameString)(enabledModuleAddress, moduleAddress));
        return isModuleEnabled;
      }
    };
    exports.default = GnosisSafeContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.2.0/GnosisSafeContract_V1_2_0_Ethers.js
var require_GnosisSafeContract_V1_2_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.2.0/GnosisSafeContract_V1_2_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants8();
    var GnosisSafeContractEthers_1 = __importDefault(require_GnosisSafeContractEthers());
    var GnosisSafeContract_V1_2_0_Ethers = class extends GnosisSafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        return this.contract.getModules();
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
      }
    };
    exports.default = GnosisSafeContract_V1_2_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.3.0/GnosisSafeContract_V1_3_0_Ethers.js
var require_GnosisSafeContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafe/v1.3.0/GnosisSafeContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var constants_1 = require_constants8();
    var GnosisSafeContractEthers_1 = __importDefault(require_GnosisSafeContractEthers());
    var GnosisSafeContract_V1_3_0_Ethers = class extends GnosisSafeContractEthers_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
      async setup(setupConfig, options) {
        const { owners, threshold, to = constants_1.ZERO_ADDRESS, data = constants_1.EMPTY_DATA, fallbackHandler = constants_1.ZERO_ADDRESS, paymentToken = constants_1.ZERO_ADDRESS, payment = 0, paymentReceiver = constants_1.ZERO_ADDRESS } = setupConfig;
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("setup", [owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver], {
            ...options
          });
        }
        const txResponse = await this.contract.setup(owners, threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getModules() {
        const { array } = await this.contract.getModulesPaginated(constants_1.SENTINEL_ADDRESS, 10);
        return array;
      }
      async isModuleEnabled(moduleAddress) {
        return this.contract.isModuleEnabled(moduleAddress);
      }
    };
    exports.default = GnosisSafeContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/GnosisSafeProxyFactoryEthersContract.js
var require_GnosisSafeProxyFactoryEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/GnosisSafeProxyFactoryEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var GnosisSafeProxyFactoryEthersContract = class {
      constructor(contract) {
        this.contract = contract;
      }
      getAddress() {
        return this.contract.address;
      }
      async proxyCreationCode() {
        return this.contract.proxyCreationCode();
      }
      async createProxy({ safeMasterCopyAddress, initializer, saltNonce, options, callback }) {
        if (bignumber_1.BigNumber.from(saltNonce).lt(0))
          throw new Error("saltNonce must be greater than or equal to 0");
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("createProxyWithNonce", [safeMasterCopyAddress, initializer, saltNonce], {
            ...options
          });
        }
        const proxyAddress = this.contract.createProxyWithNonce(safeMasterCopyAddress, initializer, saltNonce, options).then(async (txResponse) => {
          var _a;
          if (callback) {
            callback(txResponse.hash);
          }
          const txReceipt = await txResponse.wait();
          const proxyCreationEvent = (_a = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.events) === null || _a === void 0 ? void 0 : _a.find(({ event }) => event === "ProxyCreation");
          if (!proxyCreationEvent || !proxyCreationEvent.args) {
            throw new Error("SafeProxy was not deployed correctly");
          }
          const proxyAddress2 = proxyCreationEvent.args[0];
          return proxyAddress2;
        });
        return proxyAddress;
      }
      encode(methodName, params) {
        return this.contract.interface.encodeFunctionData(methodName, params);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();
      }
    };
    exports.default = GnosisSafeProxyFactoryEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.0.0/GnosisSafeProxyFactoryContract_V1_0_0_Ethers.js
var require_GnosisSafeProxyFactoryContract_V1_0_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.0.0/GnosisSafeProxyFactoryContract_V1_0_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GnosisSafeProxyFactoryEthersContract_1 = __importDefault(require_GnosisSafeProxyFactoryEthersContract());
    var GnosisSafeProxyFactoryContract_V1_0_0_Ethers = class extends GnosisSafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = GnosisSafeProxyFactoryContract_V1_0_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.1.1/GnosisSafeProxyFactoryContract_V1_1_1_Ethers.js
var require_GnosisSafeProxyFactoryContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.1.1/GnosisSafeProxyFactoryContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GnosisSafeProxyFactoryEthersContract_1 = __importDefault(require_GnosisSafeProxyFactoryEthersContract());
    var GnosisSafeProxyFactoryContract_V1_1_1_Ethers = class extends GnosisSafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = GnosisSafeProxyFactoryContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.3.0/GnosisSafeProxyFactoryContract_V1_3_0_Ethers.js
var require_GnosisSafeProxyFactoryContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/GnosisSafeProxyFactory/v1.3.0/GnosisSafeProxyFactoryContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var GnosisSafeProxyFactoryEthersContract_1 = __importDefault(require_GnosisSafeProxyFactoryEthersContract());
    var GnosisSafeProxyFactoryContract_V1_3_0_Ethers = class extends GnosisSafeProxyFactoryEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = GnosisSafeProxyFactoryContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/MultiSendEthersContract.js
var require_MultiSendEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/MultiSendEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = MultiSendEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Ethers.js
var require_MultiSendContract_V1_1_1_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/v1.1.1/MultiSendContract_V1_1_1_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendContract_V1_1_1_Ethers = class extends MultiSendEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_1_1_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Ethers.js
var require_MultiSendContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSend/v1.3.0/MultiSendContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendEthersContract_1 = __importDefault(require_MultiSendEthersContract());
    var MultiSendContract_V1_3_0_Ethers = class extends MultiSendEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSendCallOnly/MultiSendCallOnlyEthersContract.js
var require_MultiSendCallOnlyEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSendCallOnly/MultiSendCallOnlyEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
    };
    exports.default = MultiSendCallOnlyEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Ethers.js
var require_MultiSendCallOnlyContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/MultiSendCallOnly/v1.3.0/MultiSendCallOnlyContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var MultiSendCallOnlyEthersContract_1 = __importDefault(require_MultiSendCallOnlyEthersContract());
    var MultiSendCallOnlyContract_V1_3_0_Ethers = class extends MultiSendCallOnlyEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = MultiSendCallOnlyContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/SignMessageLib/SignMessageLibEthersContract.js
var require_SignMessageLibEthersContract = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/SignMessageLib/SignMessageLibEthersContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils18();
    var SignMessageLibEthersContract = class {
      constructor(contract) {
        this.contract = contract;
        this.encode = (methodName, params) => {
          return this.contract.interface.encodeFunctionData(methodName, params);
        };
      }
      getAddress() {
        return this.contract.address;
      }
      async signMessage(data, options) {
        if (options && !options.gasLimit) {
          options.gasLimit = await this.estimateGas("signMessage", [data], { ...options });
        }
        const txResponse = await this.contract.signMessage(data, options);
        return (0, utils_1.toTxResult)(txResponse, options);
      }
      async getMessageHash(message) {
        return this.contract.getMessageHash(message);
      }
      async estimateGas(methodName, params, options) {
        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();
      }
    };
    exports.default = SignMessageLibEthersContract;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Ethers.js
var require_SignMessageLibContract_V1_3_0_Ethers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/SignMessageLib/v1.3.0/SignMessageLibContract_V1_3_0_Ethers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SignMessageLibEthersContract_1 = __importDefault(require_SignMessageLibEthersContract());
    var SignMessageLibContract_V1_3_0_Ethers = class extends SignMessageLibEthersContract_1.default {
      constructor(contract) {
        super(contract);
        this.contract = contract;
      }
    };
    exports.default = SignMessageLibContract_V1_3_0_Ethers;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/contractInstancesEthers.js
var require_contractInstancesEthers = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/contracts/contractInstancesEthers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreateCallContractInstance = exports.getSignMessageLibContractInstance = exports.getSafeProxyFactoryContractInstance = exports.getMultiSendCallOnlyContractInstance = exports.getMultiSendContractInstance = exports.getCompatibilityFallbackHandlerContractInstance = exports.getSafeContractInstance = void 0;
    var Gnosis_safe__factory_1 = require_Gnosis_safe_factory();
    var Proxy_factory__factory_1 = require_Proxy_factory_factory();
    var Gnosis_safe__factory_2 = require_Gnosis_safe_factory2();
    var Multi_send__factory_1 = require_Multi_send_factory();
    var Proxy_factory__factory_2 = require_Proxy_factory_factory2();
    var Gnosis_safe__factory_3 = require_Gnosis_safe_factory3();
    var Compatibility_fallback_handler__factory_1 = require_Compatibility_fallback_handler_factory();
    var Gnosis_safe__factory_4 = require_Gnosis_safe_factory4();
    var Multi_send_call_only__factory_1 = require_Multi_send_call_only_factory();
    var Multi_send__factory_2 = require_Multi_send_factory2();
    var Proxy_factory__factory_3 = require_Proxy_factory_factory3();
    var Sign_message_lib__factory_1 = require_Sign_message_lib_factory();
    var Create_call__factory_1 = require_Create_call_factory();
    var CompatibilityFallbackHandler_V1_3_0_Ethers_1 = __importDefault(require_CompatibilityFallbackHandler_V1_3_0_Ethers());
    var CreateCallEthersContract_V1_3_0_Ethers_1 = __importDefault(require_CreateCallEthersContract_V1_3_0_Ethers());
    var GnosisSafeContract_V1_0_0_Ethers_1 = __importDefault(require_GnosisSafeContract_V1_0_0_Ethers());
    var GnosisSafeContract_V1_1_1_Ethers_1 = __importDefault(require_GnosisSafeContract_V1_1_1_Ethers());
    var GnosisSafeContract_V1_2_0_Ethers_1 = __importDefault(require_GnosisSafeContract_V1_2_0_Ethers());
    var GnosisSafeContract_V1_3_0_Ethers_1 = __importDefault(require_GnosisSafeContract_V1_3_0_Ethers());
    var GnosisSafeProxyFactoryContract_V1_0_0_Ethers_1 = __importDefault(require_GnosisSafeProxyFactoryContract_V1_0_0_Ethers());
    var GnosisSafeProxyFactoryContract_V1_1_1_Ethers_1 = __importDefault(require_GnosisSafeProxyFactoryContract_V1_1_1_Ethers());
    var GnosisSafeProxyFactoryContract_V1_3_0_Ethers_1 = __importDefault(require_GnosisSafeProxyFactoryContract_V1_3_0_Ethers());
    var MultiSendContract_V1_1_1_Ethers_1 = __importDefault(require_MultiSendContract_V1_1_1_Ethers());
    var MultiSendContract_V1_3_0_Ethers_1 = __importDefault(require_MultiSendContract_V1_3_0_Ethers());
    var MultiSendCallOnlyContract_V1_3_0_Ethers_1 = __importDefault(require_MultiSendCallOnlyContract_V1_3_0_Ethers());
    var SignMessageLibContract_V1_3_0_Ethers_1 = __importDefault(require_SignMessageLibContract_V1_3_0_Ethers());
    function getSafeContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let safeContract;
      switch (safeVersion) {
        case "1.3.0":
          safeContract = Gnosis_safe__factory_4.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeContract_V1_3_0_Ethers_1.default(safeContract);
        case "1.2.0":
          safeContract = Gnosis_safe__factory_3.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeContract_V1_2_0_Ethers_1.default(safeContract);
        case "1.1.1":
          safeContract = Gnosis_safe__factory_2.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeContract_V1_1_1_Ethers_1.default(safeContract);
        case "1.0.0":
          safeContract = Gnosis_safe__factory_1.Gnosis_safe__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeContract_V1_0_0_Ethers_1.default(safeContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeContractInstance = getSafeContractInstance;
    function getCompatibilityFallbackHandlerContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let compatibilityFallbackHandlerContract;
      switch (safeVersion) {
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
          compatibilityFallbackHandlerContract = Compatibility_fallback_handler__factory_1.Compatibility_fallback_handler__factory.connect(contractAddress, signerOrProvider);
          return new CompatibilityFallbackHandler_V1_3_0_Ethers_1.default(compatibilityFallbackHandlerContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCompatibilityFallbackHandlerContractInstance = getCompatibilityFallbackHandlerContractInstance;
    function getMultiSendContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let multiSendContract;
      switch (safeVersion) {
        case "1.3.0":
          multiSendContract = Multi_send__factory_2.Multi_send__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendContract_V1_3_0_Ethers_1.default(multiSendContract);
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          multiSendContract = Multi_send__factory_1.Multi_send__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendContract_V1_1_1_Ethers_1.default(multiSendContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendContractInstance = getMultiSendContractInstance;
    function getMultiSendCallOnlyContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let multiSendCallOnlyContract;
      switch (safeVersion) {
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          multiSendCallOnlyContract = Multi_send_call_only__factory_1.Multi_send_call_only__factory.connect(contractAddress, signerOrProvider);
          return new MultiSendCallOnlyContract_V1_3_0_Ethers_1.default(multiSendCallOnlyContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getMultiSendCallOnlyContractInstance = getMultiSendCallOnlyContractInstance;
    function getSafeProxyFactoryContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let gnosisSafeProxyFactoryContract;
      switch (safeVersion) {
        case "1.3.0":
          gnosisSafeProxyFactoryContract = Proxy_factory__factory_3.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeProxyFactoryContract_V1_3_0_Ethers_1.default(gnosisSafeProxyFactoryContract);
        case "1.2.0":
        case "1.1.1":
          gnosisSafeProxyFactoryContract = Proxy_factory__factory_2.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeProxyFactoryContract_V1_1_1_Ethers_1.default(gnosisSafeProxyFactoryContract);
        case "1.0.0":
          gnosisSafeProxyFactoryContract = Proxy_factory__factory_1.Proxy_factory__factory.connect(contractAddress, signerOrProvider);
          return new GnosisSafeProxyFactoryContract_V1_0_0_Ethers_1.default(gnosisSafeProxyFactoryContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSafeProxyFactoryContractInstance = getSafeProxyFactoryContractInstance;
    function getSignMessageLibContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let signMessageLibContract;
      switch (safeVersion) {
        case "1.3.0":
          signMessageLibContract = Sign_message_lib__factory_1.Sign_message_lib__factory.connect(contractAddress, signerOrProvider);
          return new SignMessageLibContract_V1_3_0_Ethers_1.default(signMessageLibContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getSignMessageLibContractInstance = getSignMessageLibContractInstance;
    function getCreateCallContractInstance(safeVersion, contractAddress, signerOrProvider) {
      let createCallContract;
      switch (safeVersion) {
        case "1.3.0":
        case "1.2.0":
        case "1.1.1":
        case "1.0.0":
          createCallContract = Create_call__factory_1.Create_call__factory.connect(contractAddress, signerOrProvider);
          return new CreateCallEthersContract_V1_3_0_Ethers_1.default(createCallContract);
        default:
          throw new Error("Invalid Safe version");
      }
    }
    exports.getCreateCallContractInstance = getCreateCallContractInstance;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/EthersAdapter.js
var require_EthersAdapter = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/EthersAdapter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _EthersAdapter_ethers;
    var _EthersAdapter_signer;
    var _EthersAdapter_provider;
    Object.defineProperty(exports, "__esModule", { value: true });
    var abstract_signer_1 = (init_lib6(), __toCommonJS(lib_exports6));
    var bignumber_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var safe_core_sdk_utils_1 = require_src6();
    var contractInstancesEthers_1 = require_contractInstancesEthers();
    var utils_1 = require_utils18();
    var EthersAdapter = class {
      constructor({ ethers, signerOrProvider }) {
        _EthersAdapter_ethers.set(this, void 0);
        _EthersAdapter_signer.set(this, void 0);
        _EthersAdapter_provider.set(this, void 0);
        if (!ethers) {
          throw new Error("ethers property missing from options");
        }
        __classPrivateFieldSet(this, _EthersAdapter_ethers, ethers, "f");
        const isSigner = signerOrProvider instanceof abstract_signer_1.Signer;
        if (isSigner) {
          const signer = signerOrProvider;
          if (!signer.provider) {
            throw new Error("Signer must be connected to a provider");
          }
          __classPrivateFieldSet(this, _EthersAdapter_provider, signer.provider, "f");
          __classPrivateFieldSet(this, _EthersAdapter_signer, signer, "f");
        } else {
          __classPrivateFieldSet(this, _EthersAdapter_provider, signerOrProvider, "f");
        }
      }
      getProvider() {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
      }
      getSigner() {
        return __classPrivateFieldGet(this, _EthersAdapter_signer, "f");
      }
      isAddress(address) {
        return __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.isAddress(address);
      }
      async getEip3770Address(fullAddress) {
        const chainId = await this.getChainId();
        return (0, safe_core_sdk_utils_1.validateEip3770Address)(fullAddress, chainId);
      }
      async getBalance(address, blockTag) {
        return bignumber_1.BigNumber.from(await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getBalance(address, blockTag));
      }
      async getNonce(address, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getTransactionCount(address, blockTag);
      }
      async getChainId() {
        return (await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getNetwork()).chainId;
      }
      getChecksummedAddress(address) {
        return __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.getAddress(address);
      }
      getSafeContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid SafeProxy contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getSafeProxyFactoryContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid SafeProxyFactory contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSafeProxyFactoryContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getMultiSendContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid MultiSend contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getMultiSendCallOnlyContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid MultiSendCallOnly contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getMultiSendCallOnlyContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getCompatibilityFallbackHandlerContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid CompatibilityFallbackHandler contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCompatibilityFallbackHandlerContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getSignMessageLibContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid SignMessageLib contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getSignMessageLibContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      getCreateCallContract({ safeVersion, chainId, singletonDeployment, customContractAddress }) {
        const contractAddress = customContractAddress ? customContractAddress : singletonDeployment === null || singletonDeployment === void 0 ? void 0 : singletonDeployment.networkAddresses[chainId];
        if (!contractAddress) {
          throw new Error("Invalid CreateCall contract address");
        }
        const signerOrProvider = __classPrivateFieldGet(this, _EthersAdapter_signer, "f") || __classPrivateFieldGet(this, _EthersAdapter_provider, "f");
        return (0, contractInstancesEthers_1.getCreateCallContractInstance)(safeVersion, contractAddress, signerOrProvider);
      }
      async getContractCode(address, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
      }
      async isContractDeployed(address, blockTag) {
        const contractCode = await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getCode(address, blockTag);
        return contractCode !== "0x";
      }
      async getStorageAt(address, position) {
        const content = await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getStorageAt(address, position);
        const decodedContent = this.decodeParameters(["address"], content);
        return decodedContent[0];
      }
      async getTransaction(transactionHash) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").getTransaction(transactionHash);
      }
      async getSignerAddress() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _EthersAdapter_signer, "f")) === null || _a === void 0 ? void 0 : _a.getAddress();
      }
      signMessage(message) {
        if (!__classPrivateFieldGet(this, _EthersAdapter_signer, "f")) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        const messageArray = __classPrivateFieldGet(this, _EthersAdapter_ethers, "f").utils.arrayify(message);
        return __classPrivateFieldGet(this, _EthersAdapter_signer, "f").signMessage(messageArray);
      }
      async signTypedData(safeTransactionEIP712Args) {
        if (!__classPrivateFieldGet(this, _EthersAdapter_signer, "f")) {
          throw new Error("EthAdapter must be initialized with a signer to use this method");
        }
        if ((0, utils_1.isTypedDataSigner)(__classPrivateFieldGet(this, _EthersAdapter_signer, "f"))) {
          const typedData = (0, safe_core_sdk_utils_1.generateTypedData)(safeTransactionEIP712Args);
          const signature = await __classPrivateFieldGet(this, _EthersAdapter_signer, "f")._signTypedData(typedData.domain, { SafeTx: typedData.types.SafeTx }, typedData.message);
          return signature;
        }
        throw new Error("The current signer does not implement EIP-712 to sign typed data");
      }
      async estimateGas(transaction) {
        return (await __classPrivateFieldGet(this, _EthersAdapter_provider, "f").estimateGas(transaction)).toNumber();
      }
      call(transaction, blockTag) {
        return __classPrivateFieldGet(this, _EthersAdapter_provider, "f").call(transaction, blockTag);
      }
      encodeParameters(types, values) {
        return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, "f")).utils.AbiCoder().encode(types, values);
      }
      decodeParameters(types, values) {
        return new (__classPrivateFieldGet(this, _EthersAdapter_ethers, "f")).utils.AbiCoder().decode(types, values);
      }
    };
    _EthersAdapter_ethers = /* @__PURE__ */ new WeakMap(), _EthersAdapter_signer = /* @__PURE__ */ new WeakMap(), _EthersAdapter_provider = /* @__PURE__ */ new WeakMap();
    exports.default = EthersAdapter;
  }
});

// node_modules/@safe-global/safe-ethers-lib/dist/src/index.js
var require_src9 = __commonJS({
  "node_modules/@safe-global/safe-ethers-lib/dist/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var EthersAdapter_1 = __importDefault(require_EthersAdapter());
    exports.default = EthersAdapter_1.default;
  }
});

// node_modules/@thirdweb-dev/wallets/evm/connectors/safe/dist/thirdweb-dev-wallets-evm-connectors-safe.browser.esm.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());
init_lib9();
var import_safe_ethers_adapters = __toESM(require_src2());
var import_safe_core_sdk = __toESM(require_src8());
var import_safe_ethers_lib = __toESM(require_src9());
var CHAIN_ID_TO_GNOSIS_SERVER_URL = {
  // mainnet
  1: "https://safe-transaction-mainnet.safe.global",
  // Sepolia
  11155111: "https://safe-transaction-sepolia.safe.global",
  // optimism
  10: "https://safe-transaction-optimism.safe.global",
  // bsc
  56: "https://safe-transaction-bsc.safe.global",
  // gnosis
  100: "https://safe-transaction-gnosis-chain.safe.global",
  // polygon
  137: "https://safe-transaction-polygon.safe.global",
  // avalanche
  43114: "https://safe-transaction-avalanche.safe.global",
  // arbitrum
  42161: "https://safe-transaction-arbitrum.safe.global",
  // celo
  42220: "https://safe-transaction-celo.safe.global",
  // Base mainnet
  8453: "https://safe-transaction-base.safe.global",
  // aurora
  1313161554: "https://safe-transaction-aurora.safe.global",
  //  Polygon zkEVM
  1101: "https://safe-transaction-zkevm.safe.global",
  //  ZkSync Mainnet
  324: "https://safe-transaction-zksync.safe.global"
};
var CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS = {
  // mainnet
  1: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // polygon
  137: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // bsc
  56: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // arbitrum
  42161: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // aurora
  1313161554: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // avalanche
  43114: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // optimism
  10: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // celo
  42220: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // gnosis chain - https://docs.safe.global/smart-account-supported-networks/v1.3.0#gnosis
  100: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // Sepolia - https://docs.safe.global/smart-account-supported-networks/v1.3.0#sepolia
  11155111: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // base mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#base
  8453: "0x98FFBBF51bb33A056B08ddf711f289936AafF717",
  // Polygon zkEVM - https://docs.safe.global/smart-account-supported-networks/v1.3.0#polygon-zkevm
  1101: "0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2",
  // ZkSync Mainnet - https://docs.safe.global/smart-account-supported-networks/v1.3.0#zksync-mainnet
  324: "0x357147caf9C0cCa67DfA0CF5369318d8193c8407"
};
var SIGN_MESSAGE_LIB_ABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "bytes32",
    name: "msgHash",
    type: "bytes32"
  }],
  name: "SignMsg",
  type: "event"
}, {
  inputs: [{
    internalType: "bytes",
    name: "message",
    type: "bytes"
  }],
  name: "getMessageHash",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes",
    name: "_data",
    type: "bytes"
  }],
  name: "signMessage",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var __IS_SERVER__ = false;
var SafeConnector = class _SafeConnector extends Connector {
  // config
  // private options: SafeOptions;
  constructor() {
    super();
    _defineProperty(this, "supportedChains", _SafeConnector.supportedChains);
    _defineProperty(this, "id", "safe-wallet");
    _defineProperty(this, "ready", !__IS_SERVER__);
    _defineProperty(this, "name", "Safe Wallet");
    {
      this.ready = true;
    }
  }
  async connect(args) {
    if (!(args.chain.chainId in CHAIN_ID_TO_GNOSIS_SERVER_URL)) {
      throw new Error("Chain not supported by Safe");
    }
    this.safeSigner = await this.createSafeSigner(args);
    return await this.getAddress();
  }
  async createSafeSigner(params) {
    this.personalWallet = params.personalWallet;
    const signer = await params.personalWallet.getSigner();
    const safeAddress = params.safeAddress;
    const safeChainId = params.chain.chainId;
    if (!signer) {
      throw new Error("cannot create Gnosis Safe signer without a personal signer");
    }
    const signerChainId = await signer.getChainId();
    if (signerChainId !== safeChainId) {
      throw new Error("chainId of personal signer has to match safe chainId");
    }
    if (!safeAddress) {
      throw new Error("safeAddress is required");
    }
    if (!safeChainId) {
      throw new Error("safeChainId is required");
    }
    const serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
    const signMessageLibAddress = CHAIN_ID_TO_SIGN_MESSAGE_LIB_ADDRESS[safeChainId];
    if (!serverUrl || !signMessageLibAddress) {
      throw new Error("Chain not supported");
    }
    const ethAdapter = new import_safe_ethers_lib.default({
      ethers: ethers_exports,
      signerOrProvider: signer
    });
    const safe = await import_safe_core_sdk.default.create({
      ethAdapter,
      safeAddress
    });
    const service = new import_safe_ethers_adapters.SafeService(serverUrl);
    const safeSigner = new import_safe_ethers_adapters.SafeEthersSigner(safe, service, signer.provider);
    safeSigner.signMessage = async (message) => {
      var _a;
      const contract = new ethers_exports.BaseContract(signMessageLibAddress, SIGN_MESSAGE_LIB_ABI);
      const data = contract.interface.encodeFunctionData("signMessage", [ethers_exports.utils.hashMessage(message)]);
      const to = signMessageLibAddress;
      const value = "0";
      const operation = 1;
      const safeTxGas = 5e4;
      const baseGas = 5e4;
      const gasPrice = 0;
      const gasToken = ethers_exports.constants.AddressZero;
      const refundReceiver = ethers_exports.constants.AddressZero;
      const safeTx = await safe.createTransaction({
        safeTransactionData: {
          to,
          value,
          operation,
          data,
          baseGas,
          safeTxGas,
          gasPrice,
          gasToken,
          refundReceiver
        }
      });
      const safeTxHash = await safe.getTransactionHash(safeTx);
      const safeSignature = await safe.signTransactionHash(safeTxHash);
      await service.proposeTx(safe.getAddress(), safeTxHash, safeTx, safeSignature);
      while (true) {
        try {
          const txDetails = await service.getSafeTxDetails(safeTxHash);
          if (txDetails.transactionHash) {
            await ((_a = signer.provider) == null ? void 0 : _a.waitForTransaction(txDetails.transactionHash));
            break;
          }
        } catch (e) {
        }
        await new Promise((resolve2) => setTimeout(resolve2, 5e3));
      }
      return "0x";
    };
    this.previousConnector = params.personalWallet;
    return safeSigner;
  }
  async disconnect() {
    this.safeSigner = void 0;
    this.previousConnector = void 0;
    return void 0;
  }
  async getAddress() {
    const signer = await this.getSigner();
    return await signer.getAddress();
  }
  async getChainId() {
    return (await this.getSigner()).getChainId();
  }
  async getProvider() {
    const provider = (await this.getSigner()).provider;
    if (!provider) {
      throw new Error("No provider available");
    }
    return provider;
  }
  async getSigner() {
    if (!this.safeSigner) {
      throw new Error("not connected - please call connect() first");
    }
    return this.safeSigner;
  }
  async isConnected() {
    try {
      const account = await this.getAddress();
      return !!account;
    } catch (e) {
      return false;
    }
  }
  onAccountsChanged(accounts) {
    if (accounts.length === 0) {
      this.emit("disconnect");
    } else {
      if (accounts[0]) {
        this.emit("change", {
          account: ethers_exports.utils.getAddress(accounts[0])
        });
      }
    }
  }
  onDisconnect() {
    this.emit("disconnect");
  }
  switchChain() {
    throw new Error("Safe connector does not support switching chains");
  }
  updateChains() {
  }
  async setupListeners() {
  }
};
_defineProperty(SafeConnector, "supportedChains", (() => Object.keys(CHAIN_ID_TO_GNOSIS_SERVER_URL))());
export {
  SafeConnector
};
/*! Bundled license information:

utf8/utf8.js:
  (*! https://mths.be/utf8js v3.0.0 by @mathias *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=thirdweb-dev-wallets-evm-connectors-safe.browser.esm-AX3Z3FR2.js.map
