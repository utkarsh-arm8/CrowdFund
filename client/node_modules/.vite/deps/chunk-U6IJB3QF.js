import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  DEFAULT_RPC_URL,
  getClientFetch,
  getThirdwebDomains,
  isThirdwebUrl
} from "./chunk-LMJC2RD2.js";
import {
  stringify
} from "./chunk-4K65M2LO.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/rpc.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/utils.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/withCache.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey) {
  const buildCache = (cacheKey_, cache) => ({
    clear: () => cache.delete(cacheKey_),
    get: () => cache.get(cacheKey_),
    set: (data) => cache.set(cacheKey_, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime) {
      return response.data;
    }
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/utils.js
var CUSTOM_CHAIN_MAP = /* @__PURE__ */ new Map();
function defineChain(options) {
  if (typeof options === "number") {
    return {
      id: options,
      rpc: `https://${options}.rpc.thirdweb.com`
    };
  }
  if (isViemChain(options)) {
    return convertViemChain(options);
  }
  if (isLegacyChain(options)) {
    return convertLegacyChain(options);
  }
  let rpc = options.rpc;
  if (!rpc) {
    rpc = `https://${options.id}.rpc.thirdweb.com`;
  }
  const chain = { ...options, rpc };
  CUSTOM_CHAIN_MAP.set(options.id, chain);
  return chain;
}
function getCachedChain(id) {
  if (CUSTOM_CHAIN_MAP.has(id)) {
    return CUSTOM_CHAIN_MAP.get(id);
  }
  const chain = {
    id,
    rpc: `https://${id}.rpc.thirdweb.com`
  };
  return chain;
}
function isLegacyChain(chain) {
  return "rpc" in chain && Array.isArray(chain.rpc) && "slug" in chain;
}
function convertLegacyChain(legacyChain) {
  var _a;
  const c = {
    id: legacyChain.chainId,
    name: legacyChain.name,
    rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.rpc.thirdweb.com`,
    blockExplorers: (_a = legacyChain == null ? void 0 : legacyChain.explorers) == null ? void 0 : _a.map((explorer) => ({
      name: explorer.name,
      url: explorer.url,
      apiUrl: explorer.url
    })),
    nativeCurrency: {
      name: legacyChain.nativeCurrency.name,
      symbol: legacyChain.nativeCurrency.symbol,
      decimals: legacyChain.nativeCurrency.decimals
    }
  };
  if (legacyChain.testnet) {
    return { ...c, testnet: true };
  }
  return c;
}
function isViemChain(chain) {
  return "rpcUrls" in chain && !("rpc" in chain);
}
function convertViemChain(viemChain) {
  return defineChain({
    id: viemChain.id,
    name: viemChain.name,
    nativeCurrency: {
      name: viemChain.nativeCurrency.name,
      symbol: viemChain.nativeCurrency.symbol,
      decimals: viemChain.nativeCurrency.decimals
    },
    rpc: viemChain.rpcUrls.default.http[0] ?? `https://${viemChain.id}.rpc.thirdweb.com`,
    blockExplorers: (viemChain == null ? void 0 : viemChain.blockExplorers) ? Object.values(viemChain == null ? void 0 : viemChain.blockExplorers).map((explorer) => {
      return {
        name: explorer.name,
        url: explorer.url,
        apiUrl: explorer.apiUrl
      };
    }) : []
  });
}
function getRpcUrlForChain(options) {
  const baseRpcUrl = getThirdwebDomains().rpc;
  if (typeof options.chain === "number") {
    return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;
  }
  const { rpc } = options.chain;
  if (isThirdwebUrl(rpc)) {
    const rpcUrl = new URL(options.chain.rpc.replace(DEFAULT_RPC_URL, baseRpcUrl));
    rpcUrl.pathname = `/${options.client.clientId}`;
    return rpcUrl.toString();
  }
  return rpc;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/fetch-rpc.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
async function fetchRpc(rpcUrl, client, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const response = await getClientFetch(client)(rpcUrl, {
    headers: {
      ...(_c = (_b = (_a = client.config) == null ? void 0 : _a.rpc) == null ? void 0 : _b.fetch) == null ? void 0 : _c.headers,
      "Content-Type": "application/json"
    },
    body: stringify(options.requests),
    method: "POST",
    requestTimeoutMs: options.requestTimeoutMs ?? ((_f = (_e = (_d = client.config) == null ? void 0 : _d.rpc) == null ? void 0 : _e.fetch) == null ? void 0 : _f.requestTimeoutMs),
    keepalive: (_i = (_h = (_g = client.config) == null ? void 0 : _g.rpc) == null ? void 0 : _h.fetch) == null ? void 0 : _i.keepalive
  });
  if (!response.ok) {
    (_j = response.body) == null ? void 0 : _j.cancel();
    throw new Error(`RPC request failed with status ${response.status} - ${response.statusText}`);
  }
  if ((_k = response.headers.get("Content-Type")) == null ? void 0 : _k.startsWith("application/json")) {
    return await response.json();
  }
  const text = await response.text();
  try {
    return JSON.parse(text);
  } catch (err) {
    console.error("Error parsing response", err, text);
    throw err;
  }
}
async function fetchSingleRpc(rpcUrl, client, options) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const response = await getClientFetch(client)(rpcUrl, {
    headers: {
      ...((_c = (_b = (_a = client.config) == null ? void 0 : _a.rpc) == null ? void 0 : _b.fetch) == null ? void 0 : _c.headers) || {},
      "Content-Type": "application/json"
    },
    body: stringify(options.request),
    method: "POST",
    requestTimeoutMs: options.requestTimeoutMs ?? ((_f = (_e = (_d = client.config) == null ? void 0 : _d.rpc) == null ? void 0 : _e.fetch) == null ? void 0 : _f.requestTimeoutMs),
    keepalive: (_i = (_h = (_g = client.config) == null ? void 0 : _g.rpc) == null ? void 0 : _h.fetch) == null ? void 0 : _i.keepalive
  });
  if (!response.ok) {
    (_j = response.body) == null ? void 0 : _j.cancel();
    throw new Error(`RPC request failed with status ${response.status}`);
  }
  if ((_k = response.headers.get("Content-Type")) == null ? void 0 : _k.startsWith("application/json")) {
    return await response.json();
  }
  const text = await response.text();
  try {
    return JSON.parse(text);
  } catch (err) {
    console.error("Error parsing response", err, text);
    throw err;
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/rpc.js
var RPC_CLIENT_MAP = /* @__PURE__ */ new WeakMap();
function getRpcClientMap(client) {
  if (RPC_CLIENT_MAP.has(client)) {
    return RPC_CLIENT_MAP.get(client);
  }
  const rpcClientMap = /* @__PURE__ */ new Map();
  RPC_CLIENT_MAP.set(client, rpcClientMap);
  return rpcClientMap;
}
function rpcRequestKey(request) {
  return `${request.method}:${JSON.stringify(request.params)}`;
}
var DEFAULT_MAX_BATCH_SIZE = 100;
var DEFAULT_BATCH_TIMEOUT_MS = 0;
function getRpcClient(options) {
  const rpcClientMap = getRpcClientMap(options.client);
  const chainId = options.chain.id;
  if (rpcClientMap.has(options.chain.rpc)) {
    return rpcClientMap.get(options.chain.rpc);
  }
  const rpcClient = (() => {
    var _a, _b, _c, _d, _e, _f;
    const rpcUrl = getRpcUrlForChain({
      client: options.client,
      chain: options.chain
    });
    const batchSize = (
      // look at the direct options passed
      ((_a = options.config) == null ? void 0 : _a.maxBatchSize) ?? // look at the client options
      ((_c = (_b = options.client.config) == null ? void 0 : _b.rpc) == null ? void 0 : _c.maxBatchSize) ?? // use defaults
      DEFAULT_MAX_BATCH_SIZE
    );
    const batchTimeoutMs = (
      // look at the direct options passed
      ((_d = options.config) == null ? void 0 : _d.batchTimeoutMs) ?? // look at the client options
      ((_f = (_e = options.client.config) == null ? void 0 : _e.rpc) == null ? void 0 : _f.batchTimeoutMs) ?? DEFAULT_BATCH_TIMEOUT_MS
    );
    const inflightRequests = /* @__PURE__ */ new Map();
    let pendingBatch = [];
    let pendingBatchTimeout = null;
    function sendPendingBatch() {
      var _a2;
      if (pendingBatchTimeout) {
        clearTimeout(pendingBatchTimeout);
        pendingBatchTimeout = null;
      }
      const requests = new Array(pendingBatch.length);
      const activeBatch = pendingBatch.slice().map((inflight, index) => {
        inflight.request.id = index;
        inflight.request.jsonrpc = "2.0";
        requests[index] = inflight.request;
        return inflight;
      });
      pendingBatch = [];
      fetchRpc(rpcUrl, options.client, {
        requests,
        requestTimeoutMs: (_a2 = options.config) == null ? void 0 : _a2.requestTimeoutMs
      }).then((responses) => {
        activeBatch.forEach((inflight, index) => {
          const response = responses[index];
          if (!response) {
            inflight.reject(new Error("No response"));
            return;
          }
          if (response instanceof Error) {
            inflight.reject(response);
            return;
          }
          if (typeof response === "string") {
            inflight.reject(new Error(response));
            return;
          }
          if ("error" in response) {
            inflight.reject(response.error);
          } else if (response.method === "eth_subscription") {
            throw new Error("Subscriptions not supported yet");
          } else {
            inflight.resolve(response.result);
          }
          inflightRequests.delete(inflight.requestKey);
        });
      }).catch((err) => {
        for (const inflight of activeBatch) {
          inflight.reject(err);
          inflightRequests.delete(inflight.requestKey);
        }
      });
    }
    if (batchSize === 1) {
      return async (request) => {
        var _a2;
        request.id = 1;
        request.jsonrpc = "2.0";
        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {
          request,
          requestTimeoutMs: (_a2 = options.config) == null ? void 0 : _a2.requestTimeoutMs
        });
        if (!rpcResponse) {
          throw new Error("No response");
        }
        if ("error" in rpcResponse) {
          throw rpcResponse.error;
        }
        return rpcResponse.result;
      };
    }
    return async (request) => {
      const requestKey = rpcRequestKey(request);
      if (inflightRequests.has(requestKey)) {
        return inflightRequests.get(requestKey);
      }
      let resolve;
      let reject;
      const promise = new Promise((resolve_, reject_) => {
        resolve = resolve_;
        reject = reject_;
      });
      inflightRequests.set(requestKey, promise);
      pendingBatch.push({ request, resolve, reject, requestKey });
      if (batchSize > 1) {
        if (!pendingBatchTimeout) {
          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);
        }
        if (pendingBatch.length >= batchSize) {
          sendPendingBatch();
        }
      } else {
        sendPendingBatch();
      }
      return promise;
    };
  })();
  rpcClientMap.set(chainId, rpcClient);
  return rpcClient;
}

export {
  withCache,
  defineChain,
  getCachedChain,
  getRpcClient
};
//# sourceMappingURL=chunk-U6IJB3QF.js.map
