{
  "version": 3,
  "sources": ["../../@thirdweb-dev/sdk/dist/fetchSourceFilesFromMetadata-906c835e.browser.esm.js"],
  "sourcesContent": ["/**\n * @internal\n * @param publishedMetadata - The published metadata to fetch the sources for\n * @param storage - The storage to use\n */\n\nasync function fetchSourceFilesFromMetadata(publishedMetadata, storage) {\n  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref => {\n    let [path, info] = _ref;\n    const urls = info.urls;\n    const ipfsLink = urls ? urls.find(url => url.includes(\"ipfs\")) : undefined;\n    if (ipfsLink) {\n      const ipfsHash = ipfsLink.split(\"ipfs/\")[1];\n      // 3 sec timeout for sources that haven't been uploaded to ipfs\n      const timeout = new Promise((_r, rej) => setTimeout(() => rej(\"timeout\"), 3000));\n      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);\n      return {\n        filename: path,\n        source\n      };\n    } else {\n      return {\n        filename: path,\n        source: info.content || \"Could not find source for this contract\"\n      };\n    }\n  }));\n}\n\nexport { fetchSourceFilesFromMetadata as f };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAMA,eAAe,6BAA6B,mBAAmB,SAAS;AACtE,SAAO,MAAM,QAAQ,IAAI,OAAO,QAAQ,kBAAkB,SAAS,OAAO,EAAE,IAAI,OAAM,SAAQ;AAC5F,QAAI,CAAC,MAAM,IAAI,IAAI;AACnB,UAAM,OAAO,KAAK;AAClB,UAAM,WAAW,OAAO,KAAK,KAAK,SAAO,IAAI,SAAS,MAAM,CAAC,IAAI;AACjE,QAAI,UAAU;AACZ,YAAM,WAAW,SAAS,MAAM,OAAO,EAAE,CAAC;AAE1C,YAAM,UAAU,IAAI,QAAQ,CAAC,IAAI,QAAQ,WAAW,MAAM,IAAI,SAAS,GAAG,GAAI,CAAC;AAC/E,YAAM,SAAS,MAAM,QAAQ,KAAK,EAAE,MAAM,QAAQ,SAAS,UAAU,QAAQ,EAAE,GAAG,KAAK,GAAG,OAAO,CAAC;AAClG,aAAO;AAAA,QACL,UAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF,OAAO;AACL,aAAO;AAAA,QACL,UAAU;AAAA,QACV,QAAQ,KAAK,WAAW;AAAA,MAC1B;AAAA,IACF;AAAA,EACF,CAAC,CAAC;AACJ;",
  "names": ["import_dist"]
}
