import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  getInjectedMagicEdenProvider
} from "./chunk-J7BOTS6D.js";
import {
  getInjectedXDEFIProvider
} from "./chunk-4MIZRKFV.js";
import {
  getInjectedPhantomProvider
} from "./chunk-HEO2QKMQ.js";
import {
  getInjectedRainbowProvider
} from "./chunk-PZEDXLXV.js";
import {
  AbstractWallet,
  ERC6551_REGISTRY,
  checkContractWalletSignature,
  getAnalyticsHeaders,
  isZkSyncChain,
  require_dist as require_dist4
} from "./chunk-J7AYA5NI.js";
import {
  getInjectedOKXProvider
} from "./chunk-EQL64XJV.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-MYLL4Y3A.js";
import {
  getInjectedOneKeyProvider
} from "./chunk-B35DMV6N.js";
import {
  getInjectedCryptoDefiWalletProvider
} from "./chunk-XCC7H2DR.js";
import {
  getInjectedRabbyProvider
} from "./chunk-PMRROYBF.js";
import {
  getInjectedCoin98Provider
} from "./chunk-RHQ3H47U.js";
import {
  WagmiAdapter
} from "./chunk-BJ3Q2M2N.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-3WOBY6SR.js";
import {
  assertWindowEthereum
} from "./chunk-S7DKKX3R.js";
import {
  A,
  C,
  E,
  IEvents,
  decodeJWT,
  detect,
  encodeIss,
  esm_exports2 as esm_exports,
  f,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  h,
  import_pino,
  init_esm,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  k,
  payloadId,
  r,
  require_browser,
  require_chacha20poly1305,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_hkdf,
  require_lodash,
  require_query_string,
  require_random,
  require_sha256,
  require_x25519,
  safeJsonParse,
  safeJsonStringify,
  signJWT,
  y
} from "./chunk-CGXI2HBF.js";
import {
  walletIds
} from "./chunk-76VURHCN.js";
import {
  _defineProperty
} from "./chunk-7YQW7K4V.js";
import {
  require_brorand,
  require_hmac_drbg,
  require_utils as require_utils2
} from "./chunk-NPKO3TR3.js";
import {
  require_events
} from "./chunk-KFI3GVST.js";
import {
  aesDecryptCompat,
  aesEncrypt,
  getChainProvider
} from "./chunk-YPNI3TBW.js";
import {
  require_utils
} from "./chunk-43DMFY6L.js";
import {
  concat,
  fromString,
  toString
} from "./chunk-2GDUVVK5.js";
import {
  eventemitter3_default
} from "./chunk-C347233M.js";
import {
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-4357AYQK.js";
import {
  BigNumber,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress
} from "./chunk-5UPRJSZY.js";
import {
  require_hash,
  require_minimalistic_assert
} from "./chunk-ZKAAZOGS.js";
import {
  require_inherits_browser
} from "./chunk-OKK22FPZ.js";
import {
  Buffer$1,
  dist_exports,
  init_dist
} from "./chunk-4K5QQUIR.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-OWJUH5G2.js";
import {
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-IIQ5PWPH.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-ZDA3XXE2.js";

// node_modules/@walletconnect/utils/node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.6.0",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/bn.js/lib/bn.js"(exports, module) {
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j3, w4;
        var off = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j3 = 0; i4 >= 0; i4 -= 3) {
            w4 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j3 = 0; i4 < number.length; i4 += 3) {
            w4 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j3 = 0;
        var w4;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w4 = parseHexByte(number, start, i4) << off;
            this.words[j3] |= w4 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w4 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w4 = parseHexByte(number, start, i4) << off;
            this.words[j3] |= w4 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w4 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c5 = str.charCodeAt(i4) - 48;
          r3 *= mul;
          if (c5 >= 49) {
            r3 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r3 += c5 - 17 + 10;
          } else {
            r3 += c5;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w4 = this.words[i4];
            var word = ((w4 << off | carry) & 16777215).toString(16);
            carry = w4 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r3 = c5.modn(groupBase).toString(base);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b5, i4;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q6.isZero(); i4++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i4 - 1] = b5;
          }
        } else {
          for (i4 = 0; !q6.isZero(); i4++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[i4] = b5;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w4) {
          return 32 - Math.clz32(w4);
        };
      } else {
        BN.prototype._countBits = function _countBits(w4) {
          var t = w4;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w4) {
        if (w4 === 0) return 26;
        var t = w4;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w4 = this.words[this.length - 1];
        var hi3 = this._countBits(w4);
        return (this.length - 1) * 26 + hi3;
      };
      function toBitArray(num) {
        var w4 = new Array(num.bitLength());
        for (var bit = 0; bit < w4.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w4;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b5 = this._zeroBits(this.words[i4]);
          r3 += b5;
          if (b5 !== 26) break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or4(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b5;
        if (this.length > num.length) {
          b5 = num;
        } else {
          b5 = this;
        }
        for (var i4 = 0; i4 < b5.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b5.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a4;
        var b5;
        if (this.length > num.length) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        for (var i4 = 0; i4 < b5.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b5.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a4, b5;
        if (this.length > num.length) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b5.length; i4++) {
          r3 = (a4.words[i4] | 0) + (b5.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r3 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b5;
        if (cmp > 0) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b5.length; i4++) {
          r3 = (a4.words[i4] | 0) - (b5.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r3 = (a4.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self.words[0] | 0;
        var b5 = num.words[0] | 0;
        var r3 = a4 * b5;
        var lo2 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j3 = Math.max(0, k5 - self.length + 1); j3 <= maxJ; j3++) {
            var i4 = k5 - j3 | 0;
            a4 = self.words[i4] | 0;
            b5 = num.words[j3] | 0;
            r3 = a4 * b5 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a4 = self.words;
        var b5 = num.words;
        var o4 = out.words;
        var c5 = 0;
        var lo2;
        var mid;
        var hi3;
        var a0 = a4[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a4[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi3 = Math.imul(ah0, bh0);
        var w0 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi3 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi3 = hi3 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi3 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi3 = hi3 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi3 = hi3 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi3 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi3 = hi3 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi3 = hi3 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi3 = hi3 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi3 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi3 = hi3 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi3 = hi3 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi3 = hi3 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi3 = hi3 + Math.imul(ah0, bh4) | 0;
        var w4 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi3 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi3 = hi3 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi3 = hi3 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi3 = hi3 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi3 = hi3 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi3 = hi3 + Math.imul(ah0, bh5) | 0;
        var w5 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi3 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi3 = hi3 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi3 = hi3 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi3 = hi3 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi3 = hi3 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi3 = hi3 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi3 = hi3 + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi3 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi3 = hi3 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi3 = hi3 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi3 = hi3 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi3 = hi3 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi3 = hi3 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi3 = hi3 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi3 = hi3 + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi3 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi3 = hi3 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi3 = hi3 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi3 = hi3 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi3 = hi3 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi3 = hi3 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi3 = hi3 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi3 = hi3 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi3 = hi3 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi3 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi3 = hi3 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi3 = hi3 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi3 = hi3 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi3 = hi3 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi3 = hi3 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi3 = hi3 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi3 = hi3 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi3 = hi3 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi3 = hi3 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi3 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi3 = hi3 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi3 = hi3 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi3 = hi3 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi3 = hi3 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi3 = hi3 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi3 = hi3 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi3 = hi3 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi3 = hi3 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi3 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi3 = hi3 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi3 = hi3 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi3 = hi3 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi3 = hi3 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi3 = hi3 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi3 = hi3 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi3 = hi3 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi3 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi3 = hi3 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi3 = hi3 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi3 = hi3 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi3 = hi3 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi3 = hi3 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi3 = hi3 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi3 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi3 = hi3 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi3 = hi3 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi3 = hi3 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi3 = hi3 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi3 = hi3 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi3 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi3 = hi3 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi3 = hi3 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi3 = hi3 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi3 = hi3 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi3 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi3 = hi3 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi3 = hi3 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi3 = hi3 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi3 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi3 = hi3 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi3 = hi3 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi3 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi3 = hi3 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi3 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w4;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c5 !== 0) {
          o4[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j3 = Math.max(0, k5 - self.length + 1); j3 <= maxJ; j3++) {
            var i4 = k5 - j3;
            var a4 = self.words[i4] | 0;
            var b5 = num.words[j3] | 0;
            var r3 = a4 * b5;
            var lo2 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x8, y7) {
        this.x = x8;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t = new Array(N3);
        var l3 = BN.prototype._countBits(N3) - 1;
        for (var i4 = 0; i4 < N3; i4++) {
          t[i4] = this.revBin(i4, l3, N3);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x8, l3, N3) {
        if (x8 === 0 || x8 === N3 - 1) return x8;
        var rb = 0;
        for (var i4 = 0; i4 < l3; i4++) {
          rb |= (x8 & 1) << l3 - i4 - 1;
          x8 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i4 = 0; i4 < N3; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s2 = 1; s2 < N3; s2 <<= 1) {
          var l3 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l3);
          var itwdf = Math.sin(2 * Math.PI / l3);
          for (var p4 = 0; p4 < N3; p4 += l3) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j3 = 0; j3 < s2; j3++) {
              var re5 = rtws[p4 + j3];
              var ie5 = itws[p4 + j3];
              var ro2 = rtws[p4 + j3 + s2];
              var io2 = itws[p4 + j3 + s2];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p4 + j3] = re5 + ro2;
              itws[p4 + j3] = ie5 + io2;
              rtws[p4 + j3 + s2] = re5 - ro2;
              itws[p4 + j3 + s2] = ie5 - io2;
              if (j3 !== l3) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m) {
        var N3 = Math.max(m, n4) | 1;
        var odd = N3 & 1;
        var i4 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1) return;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var t = rws[i4];
          rws[i4] = rws[N3 - i4 - 1];
          rws[N3 - i4 - 1] = t;
          t = iws[i4];
          iws[i4] = -iws[N3 - i4 - 1];
          iws[N3 - i4 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var w4 = Math.round(ws2[2 * i4 + 1] / N3) * 8192 + Math.round(ws2[2 * i4] / N3) + carry;
          ws2[i4] = w4 & 67108863;
          if (w4 < 67108864) {
            carry = 0;
          } else {
            carry = w4 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N3; ++i4) {
          rws[i4] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i4 = 0; i4 < N3; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x8, y7, out) {
        var N3 = 2 * this.guessLen13b(x8.length, y7.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x8.words, x8.length, rws, N3);
        this.convert13b(y7.words, y7.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i4 = 0; i4 < N3; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x8.negative ^ y7.negative;
        out.length = x8.length + y7.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w4 = (this.words[i4] | 0) * num;
          var lo2 = (w4 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w4 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w4 = toBitArray(num);
        if (w4.length === 0) return new BN(1);
        var res = this;
        for (var i4 = 0; i4 < w4.length; i4++, res = res.sqr()) {
          if (w4[i4] !== 0) break;
        }
        if (++i4 < w4.length) {
          for (var q6 = res.sqr(); i4 < w4.length; i4++, q6 = q6.sqr()) {
            if (w4[i4] === 0) continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i4;
        if (r3 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c5 = (this.words[i4] | 0) - newCarry << r3;
            this.words[i4] = c5 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h4;
        if (hint) {
          h4 = (hint - hint % 26) / 26;
        } else {
          h4 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h4 -= s2;
        h4 = Math.max(0, h4);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h4); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) return false;
        var w4 = this.words[s2];
        return !!(w4 & q6);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w4;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w4 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w4 -= right & 67108863;
          carry = (w4 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w4 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w4 = (this.words[i4 + shift] | 0) + carry;
          carry = w4 >> 26;
          this.words[i4 + shift] = w4 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w4 = -(this.words[i4] | 0) + carry;
          carry = w4 >> 26;
          this.words[i4] = w4 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b5 = num;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a4.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m = a4.length - b5.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN(null);
          q6.length = m + 1;
          q6.words = new Array(q6.length);
          for (var i4 = 0; i4 < q6.length; i4++) {
            q6.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b5, 1, m);
        if (diff.negative === 0) {
          a4 = diff;
          if (q6) {
            q6.words[m] = 1;
          }
        }
        for (var j3 = m - 1; j3 >= 0; j3--) {
          var qj = (a4.words[b5.length + j3] | 0) * 67108864 + (a4.words[b5.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b5, qj, j3);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b5, 1, j3);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j3] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a4
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p4 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p4 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w4 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w4 / num | 0;
          carry = w4 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var x8 = this;
        var y7 = p4.clone();
        if (x8.negative !== 0) {
          x8 = x8.umod(p4);
        } else {
          x8 = x8.clone();
        }
        var A5 = new BN(1);
        var B7 = new BN(0);
        var C6 = new BN(0);
        var D5 = new BN(1);
        var g6 = 0;
        while (x8.isEven() && y7.isEven()) {
          x8.iushrn(1);
          y7.iushrn(1);
          ++g6;
        }
        var yp = y7.clone();
        var xp = x8.clone();
        while (!x8.isZero()) {
          for (var i4 = 0, im = 1; (x8.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            x8.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B7.isOdd()) {
                A5.iadd(yp);
                B7.isub(xp);
              }
              A5.iushrn(1);
              B7.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (y7.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
          if (j3 > 0) {
            y7.iushrn(j3);
            while (j3-- > 0) {
              if (C6.isOdd() || D5.isOdd()) {
                C6.iadd(yp);
                D5.isub(xp);
              }
              C6.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x8.cmp(y7) >= 0) {
            x8.isub(y7);
            A5.isub(C6);
            B7.isub(D5);
          } else {
            y7.isub(x8);
            C6.isub(A5);
            D5.isub(B7);
          }
        }
        return {
          a: C6,
          b: D5,
          gcd: y7.iushln(g6)
        };
      };
      BN.prototype._invmp = function _invmp(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var a4 = this;
        var b5 = p4.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p4);
        } else {
          a4 = a4.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b5.clone();
        while (a4.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (b5.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
          if (j3 > 0) {
            b5.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b5) >= 0) {
            a4.isub(b5);
            x1.isub(x22);
          } else {
            b5.isub(a4);
            x22.isub(x1);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p4);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a4 = this.clone();
        var b5 = num.clone();
        a4.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a4.isEven() && b5.isEven(); shift++) {
          a4.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r3 = a4.cmp(b5);
          if (r3 < 0) {
            var t = a4;
            a4 = b5;
            b5 = t;
          } else if (r3 === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a4.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q6;
          return this;
        }
        var carry = q6;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w4 = this.words[i4] | 0;
          w4 += carry;
          carry = w4 >>> 26;
          w4 &= 67108863;
          this.words[i4] = w4;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w4 = this.words[0] | 0;
          res = w4 === num ? 0 : w4 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b5 = num.words[i4] | 0;
          if (a4 === b5) continue;
          if (a4 < b5) {
            res = -1;
          } else if (a4 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt7(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt5(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p4) {
        this.name = name;
        this.p = new BN(p4, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w4 = num.words[i4] | 0;
          lo2 += w4 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w4 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi3 = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi3 & 67108863;
          hi3 >>>= 26;
          num.words[i4] = lo2;
          carry = hi3;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert(a4.negative === 0, "red works only with positives");
        assert(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b5) {
        assert((a4.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a4.red && a4.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime) return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b5) {
        this._verify2(a4, b5);
        return this.imod(a4.imul(b5));
      };
      Red.prototype.mul = function mul(a4, b5) {
        this._verify2(a4, b5);
        return this.imod(a4.mul(b5));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero()) return a4.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q6 = this.m.subn(1);
        var s2 = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s2++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z7 = this.m.bitLength();
        z7 = new BN(2 * z7 * z7).toRed(this);
        while (this.pow(z7, lpow).cmp(nOne) !== 0) {
          z7.redIAdd(nOne);
        }
        var c5 = this.pow(z7, q6);
        var r3 = this.pow(a4, q6.addn(1).iushrn(1));
        var t = this.pow(a4, q6);
        var m = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert(i4 < m);
          var b5 = this.pow(c5, new BN(1).iushln(m - i4 - 1));
          r3 = r3.redMul(b5);
          c5 = b5.redSqr();
          t = t.redMul(c5);
          m = i4;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j3 = start - 1; j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j3 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a4, b5) {
        if (a4.isZero() || b5.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t = a4.imul(b5);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t.isub(c5).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b5) {
        if (a4.isZero() || b5.isZero()) return new BN(0)._forceRed(this);
        var t = a4.mul(b5);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t.isub(c5).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = exports;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w4, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i4;
      for (i4 = 0; i4 < naf.length; i4 += 1) {
        naf[i4] = 0;
      }
      var ws2 = 1 << w4 + 1;
      var k5 = num.clone();
      for (i4 = 0; i4 < naf.length; i4++) {
        var z7;
        var mod = k5.andln(ws2 - 1);
        if (k5.isOdd()) {
          if (mod > (ws2 >> 1) - 1)
            z7 = (ws2 >> 1) - mod;
          else
            z7 = mod;
          k5.isubn(z7);
        } else {
          z7 = 0;
        }
        naf[i4] = z7;
        k5.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p4, k5) {
      assert(p4.precomputed);
      var doubles = p4._getDoubles();
      var naf = getNAF(k5, 1, this._bitLength);
      var I7 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I7 /= 3;
      var repr = [];
      var j3;
      var nafW;
      for (j3 = 0; j3 < naf.length; j3 += doubles.step) {
        nafW = 0;
        for (var l3 = j3 + doubles.step - 1; l3 >= j3; l3--)
          nafW = (nafW << 1) + naf[l3];
        repr.push(nafW);
      }
      var a4 = this.jpoint(null, null, null);
      var b5 = this.jpoint(null, null, null);
      for (var i4 = I7; i4 > 0; i4--) {
        for (j3 = 0; j3 < repr.length; j3++) {
          nafW = repr[j3];
          if (nafW === i4)
            b5 = b5.mixedAdd(doubles.points[j3]);
          else if (nafW === -i4)
            b5 = b5.mixedAdd(doubles.points[j3].neg());
        }
        a4 = a4.add(b5);
      }
      return a4.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p4, k5) {
      var w4 = 4;
      var nafPoints = p4._getNAFPoints(w4);
      w4 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k5, w4, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i4 = naf.length - 1; i4 >= 0; i4--) {
        for (var l3 = 0; i4 >= 0 && naf[i4] === 0; i4--)
          l3++;
        if (i4 >= 0)
          l3++;
        acc = acc.dblp(l3);
        if (i4 < 0)
          break;
        var z7 = naf[i4];
        assert(z7 !== 0);
        if (p4.type === "affine") {
          if (z7 > 0)
            acc = acc.mixedAdd(wnd[z7 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z7 - 1 >> 1].neg());
        } else {
          if (z7 > 0)
            acc = acc.add(wnd[z7 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z7 - 1 >> 1].neg());
        }
      }
      return p4.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i4;
      var j3;
      var p4;
      for (i4 = 0; i4 < len; i4++) {
        p4 = points[i4];
        var nafPoints = p4._getNAFPoints(defW);
        wndWidth[i4] = nafPoints.wnd;
        wnd[i4] = nafPoints.points;
      }
      for (i4 = len - 1; i4 >= 1; i4 -= 2) {
        var a4 = i4 - 1;
        var b5 = i4;
        if (wndWidth[a4] !== 1 || wndWidth[b5] !== 1) {
          naf[a4] = getNAF(coeffs[a4], wndWidth[a4], this._bitLength);
          naf[b5] = getNAF(coeffs[b5], wndWidth[b5], this._bitLength);
          max = Math.max(naf[a4].length, max);
          max = Math.max(naf[b5].length, max);
          continue;
        }
        var comb = [
          points[a4],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b5]
          /* 7 */
        ];
        if (points[a4].y.cmp(points[b5].y) === 0) {
          comb[1] = points[a4].add(points[b5]);
          comb[2] = points[a4].toJ().mixedAdd(points[b5].neg());
        } else if (points[a4].y.cmp(points[b5].y.redNeg()) === 0) {
          comb[1] = points[a4].toJ().mixedAdd(points[b5]);
          comb[2] = points[a4].add(points[b5].neg());
        } else {
          comb[1] = points[a4].toJ().mixedAdd(points[b5]);
          comb[2] = points[a4].toJ().mixedAdd(points[b5].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a4], coeffs[b5]);
        max = Math.max(jsf[0].length, max);
        naf[a4] = new Array(max);
        naf[b5] = new Array(max);
        for (j3 = 0; j3 < max; j3++) {
          var ja = jsf[0][j3] | 0;
          var jb = jsf[1][j3] | 0;
          naf[a4][j3] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b5][j3] = 0;
          wnd[a4] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i4 = max; i4 >= 0; i4--) {
        var k5 = 0;
        while (i4 >= 0) {
          var zero = true;
          for (j3 = 0; j3 < len; j3++) {
            tmp[j3] = naf[j3][i4] | 0;
            if (tmp[j3] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i4--;
        }
        if (i4 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i4 < 0)
          break;
        for (j3 = 0; j3 < len; j3++) {
          var z7 = tmp[j3];
          p4;
          if (z7 === 0)
            continue;
          else if (z7 > 0)
            p4 = wnd[j3][z7 - 1 >> 1];
          else if (z7 < 0)
            p4 = wnd[j3][-z7 - 1 >> 1].neg();
          if (p4.type === "affine")
            acc = acc.mixedAdd(p4);
          else
            acc = acc.add(p4);
        }
      }
      for (i4 = 0; i4 < len; i4++)
        wnd[i4] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x8 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x8);
      return [4].concat(x8, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i4 = 0; i4 < power; i4 += step) {
        for (var j3 = 0; j3 < step; j3++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i4 = 1; i4 < max; i4++)
        res[i4] = res[i4 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k5) {
      var r3 = this;
      for (var i4 = 0; i4 < k5; i4++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u3 = lambda;
      var v7 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i4 = 0;
      var r3;
      var x8;
      while (u3.cmpn(0) !== 0) {
        var q6 = v7.div(u3);
        r3 = v7.sub(q6.mul(u3));
        x8 = x22.sub(q6.mul(x1));
        var y7 = y22.sub(q6.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x8;
        } else if (a1 && ++i4 === 2) {
          break;
        }
        prevR = r3;
        v7 = u3;
        u3 = r3;
        x22 = x1;
        x1 = x8;
        y22 = y1;
        y1 = y7;
      }
      a22 = r3.neg();
      b22 = x8;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k5).divRound(this.n);
      var c22 = v1.b.neg().mul(k5).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k5.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var y22 = x8.redSqr().redMul(x8).redIAdd(x8.redMul(this.a)).redIAdd(this.b);
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x8, y7);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x8 = point.x;
      var y7 = point.y;
      var ax = this.a.redMul(x8);
      var rhs = x8.redSqr().redMul(x8).redIAdd(ax).redIAdd(this.b);
      return y7.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i4 = 0; i4 < points.length; i4++) {
        var split = this._endoSplit(coeffs[i4]);
        var p4 = points[i4];
        var beta = p4._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p4 = p4.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i4 * 2] = p4;
        npoints[i4 * 2 + 1] = beta;
        ncoeffs[i4 * 2] = split.k1;
        ncoeffs[i4 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
      for (var j3 = 0; j3 < i4 * 2; j3++) {
        npoints[j3] = null;
        ncoeffs[j3] = null;
      }
      return res;
    };
    function Point(curve, x8, y7, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x8 === null && y7 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x8, y7, isRed) {
      return new Point(this, x8, y7, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p4) {
          return curve.point(p4.x.redMul(curve.endo.beta), p4.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p4) {
      if (this.inf)
        return p4;
      if (p4.inf)
        return this;
      if (this.eq(p4))
        return this.dbl();
      if (this.neg().eq(p4))
        return this.curve.point(null, null);
      if (this.x.cmp(p4.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p4.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p4.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p4.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a4 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k5) {
      k5 = new BN(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p4) {
      return this === p4 || this.inf === p4.inf && (this.inf || this.x.cmp(p4.x) === 0 && this.y.cmp(p4.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p4) {
          return p4.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x8, y7, z7) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x8 === null && y7 === null && z7 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        this.z = new BN(z7, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x8, y7, z7) {
      return new JPoint(this, x8, y7, z7);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      var pz2 = p4.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p4.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p4.z));
      var s2 = p4.y.redMul(z22.redMul(this.z));
      var h4 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h4.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h4.redSqr();
      var h32 = h22.redMul(h4);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p4.z).redMul(h4);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p4) {
      if (this.isInfinity())
        return p4.toJ();
      if (p4.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p4.x.redMul(z22);
      var s1 = this.y;
      var s2 = p4.y.redMul(z22).redMul(this.z);
      var h4 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h4.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h4.redSqr();
      var h32 = h22.redMul(h4);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h4);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i4 = 0; i4 < pow; i4++)
          r3 = r3.dbl();
        return r3;
      }
      var a4 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i4 = 0; i4 < pow; i4++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c5.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i4 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a4 = this.x.redSqr();
        var b5 = this.y.redSqr();
        var c5 = b5.redSqr();
        var d4 = this.x.redAdd(b5).redSqr().redISub(a4).redISub(c5);
        d4 = d4.redIAdd(d4);
        var e = a4.redAdd(a4).redIAdd(a4);
        var f5 = e.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d4).redISub(d4);
        ny = e.redMul(d4.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a4 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee7 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u3 = m.redIAdd(e).redSqr().redISub(mm).redISub(ee7).redISub(t);
      var yyu4 = yy.redMul(u3);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee7).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u3.redMul(t.redISub(u3)).redISub(e.redMul(ee7)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k5, kbase) {
      k5 = new BN(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint.prototype.eq = function eq(p4) {
      if (p4.type === "affine")
        return this.eq(p4.toJ());
      if (this === p4)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p4.z.redSqr();
      if (this.x.redMul(pz2).redISub(p4.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p4.z);
      return this.y.redMul(pz3).redISub(p4.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x8) {
      var zs3 = this.z.redSqr();
      var rx = x8.toRed(this.curve.red).redMul(zs3);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t = this.curve.redN.redMul(zs3);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x8 = point.normalize().x;
      var x22 = x8.redSqr();
      var rhs = x22.redMul(x8).redAdd(x22.redMul(this.a)).redAdd(x8);
      var y7 = rhs.redSqrt();
      return y7.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x8, z7) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && z7 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x8, 16);
        this.z = new BN(z7, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x8, z7) {
      return new Point(this, x8, z7);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a4 = this.x.redAdd(this.z);
      var aa = a4.redSqr();
      var b5 = this.x.redSub(this.z);
      var bb = b5.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p4, diff) {
      var a4 = this.x.redAdd(this.z);
      var b5 = this.x.redSub(this.z);
      var c5 = p4.x.redAdd(p4.z);
      var d4 = p4.x.redSub(p4.z);
      var da = d4.redMul(a4);
      var cb = c5.redMul(b5);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k5) {
      var t = k5.clone();
      var a4 = this;
      var b5 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i4 = bits.length - 1; i4 >= 0; i4--) {
        if (bits[i4] === 0) {
          a4 = a4.diffAdd(b5, c5);
          b5 = b5.dbl();
        } else {
          b5 = a4.diffAdd(b5, c5);
          a4 = a4.dbl();
        }
      }
      return b5;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x8, y7, z7, t) {
      return this.point(x8, y7, z7, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var x22 = x8.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x8, y7);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y7, odd) {
      y7 = new BN(y7, 16);
      if (!y7.red)
        y7 = y7.toRed(this.red);
      var y22 = y7.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y7);
      }
      var x8 = x22.redSqrt();
      if (x8.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x8.fromRed().isOdd() !== odd)
        x8 = x8.redNeg();
      return this.point(x8, y7);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x8, y7, z7, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && y7 === null && z7 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        this.z = z7 ? new BN(z7, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x8, y7, z7, t) {
      return new Point(this, x8, y7, z7, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a4 = this.x.redSqr();
      var b5 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d4 = this.curve._mulA(a4);
      var e = this.x.redAdd(this.y).redSqr().redISub(a4).redISub(b5);
      var g6 = d4.redAdd(b5);
      var f5 = g6.redSub(c5);
      var h4 = d4.redSub(b5);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h4);
      var nt5 = e.redMul(h4);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b5 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d4 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h4;
      var j3;
      if (this.curve.twisted) {
        e = this.curve._mulA(c5);
        var f5 = e.redAdd(d4);
        if (this.zOne) {
          nx = b5.redSub(c5).redSub(d4).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e.redSub(d4));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h4 = this.z.redSqr();
          j3 = f5.redSub(h4).redISub(h4);
          nx = b5.redSub(c5).redISub(d4).redMul(j3);
          ny = f5.redMul(e.redSub(d4));
          nz = f5.redMul(j3);
        }
      } else {
        e = c5.redAdd(d4);
        h4 = this.curve._mulC(this.z).redSqr();
        j3 = e.redSub(h4).redSub(h4);
        nx = this.curve._mulC(b5.redISub(e)).redMul(j3);
        ny = this.curve._mulC(e).redMul(c5.redISub(d4));
        nz = e.redMul(j3);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p4) {
      var a4 = this.y.redSub(this.x).redMul(p4.y.redSub(p4.x));
      var b5 = this.y.redAdd(this.x).redMul(p4.y.redAdd(p4.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p4.t);
      var d4 = this.z.redMul(p4.z.redAdd(p4.z));
      var e = b5.redSub(a4);
      var f5 = d4.redSub(c5);
      var g6 = d4.redAdd(c5);
      var h4 = b5.redAdd(a4);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h4);
      var nt5 = e.redMul(h4);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projAdd = function _projAdd(p4) {
      var a4 = this.z.redMul(p4.z);
      var b5 = a4.redSqr();
      var c5 = this.x.redMul(p4.x);
      var d4 = this.y.redMul(p4.y);
      var e = this.curve.d.redMul(c5).redMul(d4);
      var f5 = b5.redSub(e);
      var g6 = b5.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p4.x.redAdd(p4.y)).redISub(c5).redISub(d4);
      var nx = a4.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a4.redMul(g6).redMul(d4.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g6);
      } else {
        ny = a4.redMul(g6).redMul(d4.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p4);
      else
        return this._projAdd(p4);
    };
    Point.prototype.mul = function mul(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi3 = this.z.redInvm();
      this.x = this.x.redMul(zi3);
      this.y = this.y.redMul(zi3);
      if (this.t)
        this.t = this.t.redMul(zi3);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x8) {
      var rx = x8.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature, options) {
      return this.ec.verify(msg, signature, this, void 0, options);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p4) {
      var initial = buf[p4.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p4.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i4 = 0, off = p4.place; i4 < octetLen; i4++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p4.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i4 = 0;
      var len = buf.length - 1;
      while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
        i4++;
      }
      if (i4 === 0) {
        return buf;
      }
      return buf.slice(i4);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p4 = new Position();
      if (data[p4.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p4);
      if (len === false) {
        return false;
      }
      if (len + p4.place !== data.length) {
        return false;
      }
      if (data[p4.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p4);
      if (rlen === false) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p4.place, rlen + p4.place);
      p4.place += rlen;
      if (data[p4.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p4);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p4.place) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p4.place, slen + p4.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k5.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p4;
      if (!this.curve._maxwellTrick) {
        p4 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p4.isInfinity())
          return false;
        return p4.getX().umod(this.n).cmp(r3) === 0;
      }
      p4 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p4.isInfinity())
        return false;
      return p4.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j3, enc) {
      assert((3 & j3) === j3, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j3 & 1;
      var isSecondKey = j3 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i4 = 0; i4 < 4; i4++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i4);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i4;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a4 = hash.slice(0, eddsa.encodingLength);
      a4[0] &= 248;
      a4[lastIx] &= 127;
      a4[lastIx] |= 64;
      return a4;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S8() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R4() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R4 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R4);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S8 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R4, S: S8, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h4 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h4));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i4 = 0; i4 < arguments.length; i4++)
        hash2.update(arguments[i4]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y7 = utils.intFromLE(normed);
      return this.curve.pointFromY(y7, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/@walletconnect/utils/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json
var require_package2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.7",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/bn.js/lib/bn.js"(exports, module) {
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j3, w4;
        var off = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j3 = 0; i4 >= 0; i4 -= 3) {
            w4 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j3 = 0; i4 < number.length; i4 += 3) {
            w4 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c5 = string.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r3 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r3 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r3;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j3 = 0;
        var w4;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start; i4 -= 2) {
            w4 = parseHexByte(number, start, i4) << off;
            this.words[j3] |= w4 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w4 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number.length; i4 += 2) {
            w4 = parseHexByte(number, start, i4) << off;
            this.words[j3] |= w4 & 67108863;
            if (off >= 18) {
              off -= 18;
              j3 += 1;
              this.words[j3] |= w4 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c5 = str.charCodeAt(i4) - 48;
          r3 *= mul;
          if (c5 >= 49) {
            r3 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r3 += c5 - 17 + 10;
          } else {
            r3 += c5;
          }
        }
        return r3;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r3 = new BN(null);
        this.copy(r3);
        return r3;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w4 = this.words[i4];
            var word = ((w4 << off | carry) & 16777215).toString(16);
            carry = w4 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r3 = c5.modn(groupBase).toString(base);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b5, i4;
        var q6 = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q6.isZero(); i4++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[reqLength - i4 - 1] = b5;
          }
        } else {
          for (i4 = 0; !q6.isZero(); i4++) {
            b5 = q6.andln(255);
            q6.iushrn(8);
            res[i4] = b5;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w4) {
          return 32 - Math.clz32(w4);
        };
      } else {
        BN.prototype._countBits = function _countBits(w4) {
          var t = w4;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w4) {
        if (w4 === 0) return 26;
        var t = w4;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN.prototype.bitLength = function bitLength() {
        var w4 = this.words[this.length - 1];
        var hi3 = this._countBits(w4);
        return (this.length - 1) * 26 + hi3;
      };
      function toBitArray(num) {
        var w4 = new Array(num.bitLength());
        for (var bit = 0; bit < w4.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w4;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b5 = this._zeroBits(this.words[i4]);
          r3 += b5;
          if (b5 !== 26) break;
        }
        return r3;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or4(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b5;
        if (this.length > num.length) {
          b5 = num;
        } else {
          b5 = this;
        }
        for (var i4 = 0; i4 < b5.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b5.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a4;
        var b5;
        if (this.length > num.length) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        for (var i4 = 0; i4 < b5.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b5.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a4, b5;
        if (this.length > num.length) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b5.length; i4++) {
          r3 = (a4.words[i4] | 0) + (b5.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r3 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b5;
        if (cmp > 0) {
          a4 = this;
          b5 = num;
        } else {
          a4 = num;
          b5 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b5.length; i4++) {
          r3 = (a4.words[i4] | 0) - (b5.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r3 = (a4.words[i4] | 0) + carry;
          carry = r3 >> 26;
          this.words[i4] = r3 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self.words[0] | 0;
        var b5 = num.words[0] | 0;
        var r3 = a4 * b5;
        var lo2 = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo2;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j3 = Math.max(0, k5 - self.length + 1); j3 <= maxJ; j3++) {
            var i4 = k5 - j3 | 0;
            a4 = self.words[i4] | 0;
            b5 = num.words[j3] | 0;
            r3 = a4 * b5 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a4 = self.words;
        var b5 = num.words;
        var o4 = out.words;
        var c5 = 0;
        var lo2;
        var mid;
        var hi3;
        var a0 = a4[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a4[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo2 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi3 = Math.imul(ah0, bh0);
        var w0 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo2 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi3 = Math.imul(ah1, bh0);
        lo2 = lo2 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi3 = hi3 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo2 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi3 = Math.imul(ah2, bh0);
        lo2 = lo2 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi3 = hi3 + Math.imul(ah1, bh1) | 0;
        lo2 = lo2 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi3 = hi3 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo2 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi3 = Math.imul(ah3, bh0);
        lo2 = lo2 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi3 = hi3 + Math.imul(ah2, bh1) | 0;
        lo2 = lo2 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi3 = hi3 + Math.imul(ah1, bh2) | 0;
        lo2 = lo2 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi3 = hi3 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo2 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi3 = Math.imul(ah4, bh0);
        lo2 = lo2 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi3 = hi3 + Math.imul(ah3, bh1) | 0;
        lo2 = lo2 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi3 = hi3 + Math.imul(ah2, bh2) | 0;
        lo2 = lo2 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi3 = hi3 + Math.imul(ah1, bh3) | 0;
        lo2 = lo2 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi3 = hi3 + Math.imul(ah0, bh4) | 0;
        var w4 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo2 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi3 = Math.imul(ah5, bh0);
        lo2 = lo2 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi3 = hi3 + Math.imul(ah4, bh1) | 0;
        lo2 = lo2 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi3 = hi3 + Math.imul(ah3, bh2) | 0;
        lo2 = lo2 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi3 = hi3 + Math.imul(ah2, bh3) | 0;
        lo2 = lo2 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi3 = hi3 + Math.imul(ah1, bh4) | 0;
        lo2 = lo2 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi3 = hi3 + Math.imul(ah0, bh5) | 0;
        var w5 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo2 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi3 = Math.imul(ah6, bh0);
        lo2 = lo2 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi3 = hi3 + Math.imul(ah5, bh1) | 0;
        lo2 = lo2 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi3 = hi3 + Math.imul(ah4, bh2) | 0;
        lo2 = lo2 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi3 = hi3 + Math.imul(ah3, bh3) | 0;
        lo2 = lo2 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi3 = hi3 + Math.imul(ah2, bh4) | 0;
        lo2 = lo2 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi3 = hi3 + Math.imul(ah1, bh5) | 0;
        lo2 = lo2 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi3 = hi3 + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo2 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi3 = Math.imul(ah7, bh0);
        lo2 = lo2 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi3 = hi3 + Math.imul(ah6, bh1) | 0;
        lo2 = lo2 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi3 = hi3 + Math.imul(ah5, bh2) | 0;
        lo2 = lo2 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi3 = hi3 + Math.imul(ah4, bh3) | 0;
        lo2 = lo2 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi3 = hi3 + Math.imul(ah3, bh4) | 0;
        lo2 = lo2 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi3 = hi3 + Math.imul(ah2, bh5) | 0;
        lo2 = lo2 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi3 = hi3 + Math.imul(ah1, bh6) | 0;
        lo2 = lo2 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi3 = hi3 + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo2 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi3 = Math.imul(ah8, bh0);
        lo2 = lo2 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi3 = hi3 + Math.imul(ah7, bh1) | 0;
        lo2 = lo2 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi3 = hi3 + Math.imul(ah6, bh2) | 0;
        lo2 = lo2 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi3 = hi3 + Math.imul(ah5, bh3) | 0;
        lo2 = lo2 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi3 = hi3 + Math.imul(ah4, bh4) | 0;
        lo2 = lo2 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi3 = hi3 + Math.imul(ah3, bh5) | 0;
        lo2 = lo2 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi3 = hi3 + Math.imul(ah2, bh6) | 0;
        lo2 = lo2 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi3 = hi3 + Math.imul(ah1, bh7) | 0;
        lo2 = lo2 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi3 = hi3 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo2 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi3 = Math.imul(ah9, bh0);
        lo2 = lo2 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi3 = hi3 + Math.imul(ah8, bh1) | 0;
        lo2 = lo2 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi3 = hi3 + Math.imul(ah7, bh2) | 0;
        lo2 = lo2 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi3 = hi3 + Math.imul(ah6, bh3) | 0;
        lo2 = lo2 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi3 = hi3 + Math.imul(ah5, bh4) | 0;
        lo2 = lo2 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi3 = hi3 + Math.imul(ah4, bh5) | 0;
        lo2 = lo2 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi3 = hi3 + Math.imul(ah3, bh6) | 0;
        lo2 = lo2 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi3 = hi3 + Math.imul(ah2, bh7) | 0;
        lo2 = lo2 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi3 = hi3 + Math.imul(ah1, bh8) | 0;
        lo2 = lo2 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi3 = hi3 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo2 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi3 = Math.imul(ah9, bh1);
        lo2 = lo2 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi3 = hi3 + Math.imul(ah8, bh2) | 0;
        lo2 = lo2 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi3 = hi3 + Math.imul(ah7, bh3) | 0;
        lo2 = lo2 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi3 = hi3 + Math.imul(ah6, bh4) | 0;
        lo2 = lo2 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi3 = hi3 + Math.imul(ah5, bh5) | 0;
        lo2 = lo2 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi3 = hi3 + Math.imul(ah4, bh6) | 0;
        lo2 = lo2 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi3 = hi3 + Math.imul(ah3, bh7) | 0;
        lo2 = lo2 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi3 = hi3 + Math.imul(ah2, bh8) | 0;
        lo2 = lo2 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi3 = hi3 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo2 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi3 = Math.imul(ah9, bh2);
        lo2 = lo2 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi3 = hi3 + Math.imul(ah8, bh3) | 0;
        lo2 = lo2 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi3 = hi3 + Math.imul(ah7, bh4) | 0;
        lo2 = lo2 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi3 = hi3 + Math.imul(ah6, bh5) | 0;
        lo2 = lo2 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi3 = hi3 + Math.imul(ah5, bh6) | 0;
        lo2 = lo2 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi3 = hi3 + Math.imul(ah4, bh7) | 0;
        lo2 = lo2 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi3 = hi3 + Math.imul(ah3, bh8) | 0;
        lo2 = lo2 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi3 = hi3 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo2 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi3 = Math.imul(ah9, bh3);
        lo2 = lo2 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi3 = hi3 + Math.imul(ah8, bh4) | 0;
        lo2 = lo2 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi3 = hi3 + Math.imul(ah7, bh5) | 0;
        lo2 = lo2 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi3 = hi3 + Math.imul(ah6, bh6) | 0;
        lo2 = lo2 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi3 = hi3 + Math.imul(ah5, bh7) | 0;
        lo2 = lo2 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi3 = hi3 + Math.imul(ah4, bh8) | 0;
        lo2 = lo2 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi3 = hi3 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo2 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi3 = Math.imul(ah9, bh4);
        lo2 = lo2 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi3 = hi3 + Math.imul(ah8, bh5) | 0;
        lo2 = lo2 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi3 = hi3 + Math.imul(ah7, bh6) | 0;
        lo2 = lo2 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi3 = hi3 + Math.imul(ah6, bh7) | 0;
        lo2 = lo2 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi3 = hi3 + Math.imul(ah5, bh8) | 0;
        lo2 = lo2 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi3 = hi3 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo2 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi3 = Math.imul(ah9, bh5);
        lo2 = lo2 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi3 = hi3 + Math.imul(ah8, bh6) | 0;
        lo2 = lo2 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi3 = hi3 + Math.imul(ah7, bh7) | 0;
        lo2 = lo2 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi3 = hi3 + Math.imul(ah6, bh8) | 0;
        lo2 = lo2 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi3 = hi3 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo2 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi3 = Math.imul(ah9, bh6);
        lo2 = lo2 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi3 = hi3 + Math.imul(ah8, bh7) | 0;
        lo2 = lo2 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi3 = hi3 + Math.imul(ah7, bh8) | 0;
        lo2 = lo2 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi3 = hi3 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo2 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi3 = Math.imul(ah9, bh7);
        lo2 = lo2 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi3 = hi3 + Math.imul(ah8, bh8) | 0;
        lo2 = lo2 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi3 = hi3 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo2 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi3 = Math.imul(ah9, bh8);
        lo2 = lo2 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi3 = hi3 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo2 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi3 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo2 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o4[0] = w0;
        o4[1] = w1;
        o4[2] = w22;
        o4[3] = w32;
        o4[4] = w4;
        o4[5] = w5;
        o4[6] = w6;
        o4[7] = w7;
        o4[8] = w8;
        o4[9] = w9;
        o4[10] = w10;
        o4[11] = w11;
        o4[12] = w12;
        o4[13] = w13;
        o4[14] = w14;
        o4[15] = w15;
        o4[16] = w16;
        o4[17] = w17;
        o4[18] = w18;
        if (c5 !== 0) {
          o4[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j3 = Math.max(0, k5 - self.length + 1); j3 <= maxJ; j3++) {
            var i4 = k5 - j3;
            var a4 = self.words[i4] | 0;
            var b5 = num.words[j3] | 0;
            var r3 = a4 * b5;
            var lo2 = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo2 = lo2 + rword | 0;
            rword = lo2 & 67108863;
            ncarry = ncarry + (lo2 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x8, y7) {
        this.x = x8;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t = new Array(N3);
        var l3 = BN.prototype._countBits(N3) - 1;
        for (var i4 = 0; i4 < N3; i4++) {
          t[i4] = this.revBin(i4, l3, N3);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x8, l3, N3) {
        if (x8 === 0 || x8 === N3 - 1) return x8;
        var rb = 0;
        for (var i4 = 0; i4 < l3; i4++) {
          rb |= (x8 & 1) << l3 - i4 - 1;
          x8 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i4 = 0; i4 < N3; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s2 = 1; s2 < N3; s2 <<= 1) {
          var l3 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l3);
          var itwdf = Math.sin(2 * Math.PI / l3);
          for (var p4 = 0; p4 < N3; p4 += l3) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j3 = 0; j3 < s2; j3++) {
              var re5 = rtws[p4 + j3];
              var ie5 = itws[p4 + j3];
              var ro2 = rtws[p4 + j3 + s2];
              var io2 = itws[p4 + j3 + s2];
              var rx = rtwdf_ * ro2 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro2;
              ro2 = rx;
              rtws[p4 + j3] = re5 + ro2;
              itws[p4 + j3] = ie5 + io2;
              rtws[p4 + j3 + s2] = re5 - ro2;
              itws[p4 + j3 + s2] = ie5 - io2;
              if (j3 !== l3) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n4, m) {
        var N3 = Math.max(m, n4) | 1;
        var odd = N3 & 1;
        var i4 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1) return;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var t = rws[i4];
          rws[i4] = rws[N3 - i4 - 1];
          rws[N3 - i4 - 1] = t;
          t = iws[i4];
          iws[i4] = -iws[N3 - i4 - 1];
          iws[N3 - i4 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < N3 / 2; i4++) {
          var w4 = Math.round(ws2[2 * i4 + 1] / N3) * 8192 + Math.round(ws2[2 * i4] / N3) + carry;
          ws2[i4] = w4 & 67108863;
          if (w4 < 67108864) {
            carry = 0;
          } else {
            carry = w4 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N3) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N3; ++i4) {
          rws[i4] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i4 = 0; i4 < N3; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x8, y7, out) {
        var N3 = 2 * this.guessLen13b(x8.length, y7.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x8.words, x8.length, rws, N3);
        this.convert13b(y7.words, y7.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i4 = 0; i4 < N3; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x8.negative ^ y7.negative;
        out.length = x8.length + y7.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w4 = (this.words[i4] | 0) * num;
          var lo2 = (w4 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w4 / 67108864 | 0;
          carry += lo2 >>> 26;
          this.words[i4] = lo2 & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w4 = toBitArray(num);
        if (w4.length === 0) return new BN(1);
        var res = this;
        for (var i4 = 0; i4 < w4.length; i4++, res = res.sqr()) {
          if (w4[i4] !== 0) break;
        }
        if (++i4 < w4.length) {
          for (var q6 = res.sqr(); i4 < w4.length; i4++, q6 = q6.sqr()) {
            if (w4[i4] === 0) continue;
            res = res.mul(q6);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i4;
        if (r3 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c5 = (this.words[i4] | 0) - newCarry << r3;
            this.words[i4] = c5 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h4;
        if (hint) {
          h4 = (hint - hint % 26) / 26;
        } else {
          h4 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h4 -= s2;
        h4 = Math.max(0, h4);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h4); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) return false;
        var w4 = this.words[s2];
        return !!(w4 & q6);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w4;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w4 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul;
          w4 -= right & 67108863;
          carry = (w4 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w4 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w4 = (this.words[i4 + shift] | 0) + carry;
          carry = w4 >> 26;
          this.words[i4 + shift] = w4 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w4 = -(this.words[i4] | 0) + carry;
          carry = w4 >> 26;
          this.words[i4] = w4 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b5 = num;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a4.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m = a4.length - b5.length;
        var q6;
        if (mode !== "mod") {
          q6 = new BN(null);
          q6.length = m + 1;
          q6.words = new Array(q6.length);
          for (var i4 = 0; i4 < q6.length; i4++) {
            q6.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b5, 1, m);
        if (diff.negative === 0) {
          a4 = diff;
          if (q6) {
            q6.words[m] = 1;
          }
        }
        for (var j3 = m - 1; j3 >= 0; j3--) {
          var qj = (a4.words[b5.length + j3] | 0) * 67108864 + (a4.words[b5.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b5, qj, j3);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b5, 1, j3);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q6) {
            q6.words[j3] = qj;
          }
        }
        if (q6) {
          q6.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q6 || null,
          mod: a4
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p4 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p4 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w4 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w4 / num | 0;
          carry = w4 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var x8 = this;
        var y7 = p4.clone();
        if (x8.negative !== 0) {
          x8 = x8.umod(p4);
        } else {
          x8 = x8.clone();
        }
        var A5 = new BN(1);
        var B7 = new BN(0);
        var C6 = new BN(0);
        var D5 = new BN(1);
        var g6 = 0;
        while (x8.isEven() && y7.isEven()) {
          x8.iushrn(1);
          y7.iushrn(1);
          ++g6;
        }
        var yp = y7.clone();
        var xp = x8.clone();
        while (!x8.isZero()) {
          for (var i4 = 0, im = 1; (x8.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            x8.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B7.isOdd()) {
                A5.iadd(yp);
                B7.isub(xp);
              }
              A5.iushrn(1);
              B7.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (y7.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
          if (j3 > 0) {
            y7.iushrn(j3);
            while (j3-- > 0) {
              if (C6.isOdd() || D5.isOdd()) {
                C6.iadd(yp);
                D5.isub(xp);
              }
              C6.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x8.cmp(y7) >= 0) {
            x8.isub(y7);
            A5.isub(C6);
            B7.isub(D5);
          } else {
            y7.isub(x8);
            C6.isub(A5);
            D5.isub(B7);
          }
        }
        return {
          a: C6,
          b: D5,
          gcd: y7.iushln(g6)
        };
      };
      BN.prototype._invmp = function _invmp(p4) {
        assert(p4.negative === 0);
        assert(!p4.isZero());
        var a4 = this;
        var b5 = p4.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p4);
        } else {
          a4 = a4.clone();
        }
        var x1 = new BN(1);
        var x22 = new BN(0);
        var delta = b5.clone();
        while (a4.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (b5.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
          if (j3 > 0) {
            b5.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b5) >= 0) {
            a4.isub(b5);
            x1.isub(x22);
          } else {
            b5.isub(a4);
            x22.isub(x1);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p4);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a4 = this.clone();
        var b5 = num.clone();
        a4.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a4.isEven() && b5.isEven(); shift++) {
          a4.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r3 = a4.cmp(b5);
          if (r3 < 0) {
            var t = a4;
            a4 = b5;
            b5 = t;
          } else if (r3 === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a4.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q6 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q6;
          return this;
        }
        var carry = q6;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w4 = this.words[i4] | 0;
          w4 += carry;
          carry = w4 >>> 26;
          w4 &= 67108863;
          this.words[i4] = w4;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w4 = this.words[0] | 0;
          res = w4 === num ? 0 : w4 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b5 = num.words[i4] | 0;
          if (a4 === b5) continue;
          if (a4 < b5) {
            res = -1;
          } else if (a4 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt7(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt5(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p4) {
        this.name = name;
        this.p = new BN(p4, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          if (r3.strip !== void 0) {
            r3.strip();
          } else {
            r3._strip();
          }
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo2 = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w4 = num.words[i4] | 0;
          lo2 += w4 * 977;
          num.words[i4] = lo2 & 67108863;
          lo2 = w4 * 64 + (lo2 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi3 = (num.words[i4] | 0) * 19 + carry;
          var lo2 = hi3 & 67108863;
          hi3 >>>= 26;
          num.words[i4] = lo2;
          carry = hi3;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert(a4.negative === 0, "red works only with positives");
        assert(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b5) {
        assert((a4.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a4.red && a4.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime) return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b5) {
        this._verify2(a4, b5);
        var res = a4.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b5) {
        this._verify2(a4, b5);
        return this.imod(a4.imul(b5));
      };
      Red.prototype.mul = function mul(a4, b5) {
        this._verify2(a4, b5);
        return this.imod(a4.mul(b5));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero()) return a4.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q6 = this.m.subn(1);
        var s2 = 0;
        while (!q6.isZero() && q6.andln(1) === 0) {
          s2++;
          q6.iushrn(1);
        }
        assert(!q6.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z7 = this.m.bitLength();
        z7 = new BN(2 * z7 * z7).toRed(this);
        while (this.pow(z7, lpow).cmp(nOne) !== 0) {
          z7.redIAdd(nOne);
        }
        var c5 = this.pow(z7, q6);
        var r3 = this.pow(a4, q6.addn(1).iushrn(1));
        var t = this.pow(a4, q6);
        var m = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert(i4 < m);
          var b5 = this.pow(c5, new BN(1).iushln(m - i4 - 1));
          r3 = r3.redMul(b5);
          c5 = b5.redSqr();
          t = t.redMul(c5);
          m = i4;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j3 = start - 1; j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j3 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a4, b5) {
        if (a4.isZero() || b5.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t = a4.imul(b5);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t.isub(c5).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a4, b5) {
        if (a4.isZero() || b5.isZero()) return new BN(0)._forceRed(this);
        var t = a4.mul(b5);
        var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t.isub(c5).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w4, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i4;
      for (i4 = 0; i4 < naf.length; i4 += 1) {
        naf[i4] = 0;
      }
      var ws2 = 1 << w4 + 1;
      var k5 = num.clone();
      for (i4 = 0; i4 < naf.length; i4++) {
        var z7;
        var mod = k5.andln(ws2 - 1);
        if (k5.isOdd()) {
          if (mod > (ws2 >> 1) - 1)
            z7 = (ws2 >> 1) - mod;
          else
            z7 = mod;
          k5.isubn(z7);
        } else {
          z7 = 0;
        }
        naf[i4] = z7;
        k5.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p4, k5) {
      assert(p4.precomputed);
      var doubles = p4._getDoubles();
      var naf = getNAF(k5, 1, this._bitLength);
      var I7 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I7 /= 3;
      var repr = [];
      var j3;
      var nafW;
      for (j3 = 0; j3 < naf.length; j3 += doubles.step) {
        nafW = 0;
        for (var l3 = j3 + doubles.step - 1; l3 >= j3; l3--)
          nafW = (nafW << 1) + naf[l3];
        repr.push(nafW);
      }
      var a4 = this.jpoint(null, null, null);
      var b5 = this.jpoint(null, null, null);
      for (var i4 = I7; i4 > 0; i4--) {
        for (j3 = 0; j3 < repr.length; j3++) {
          nafW = repr[j3];
          if (nafW === i4)
            b5 = b5.mixedAdd(doubles.points[j3]);
          else if (nafW === -i4)
            b5 = b5.mixedAdd(doubles.points[j3].neg());
        }
        a4 = a4.add(b5);
      }
      return a4.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p4, k5) {
      var w4 = 4;
      var nafPoints = p4._getNAFPoints(w4);
      w4 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k5, w4, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i4 = naf.length - 1; i4 >= 0; i4--) {
        for (var l3 = 0; i4 >= 0 && naf[i4] === 0; i4--)
          l3++;
        if (i4 >= 0)
          l3++;
        acc = acc.dblp(l3);
        if (i4 < 0)
          break;
        var z7 = naf[i4];
        assert(z7 !== 0);
        if (p4.type === "affine") {
          if (z7 > 0)
            acc = acc.mixedAdd(wnd[z7 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z7 - 1 >> 1].neg());
        } else {
          if (z7 > 0)
            acc = acc.add(wnd[z7 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z7 - 1 >> 1].neg());
        }
      }
      return p4.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i4;
      var j3;
      var p4;
      for (i4 = 0; i4 < len; i4++) {
        p4 = points[i4];
        var nafPoints = p4._getNAFPoints(defW);
        wndWidth[i4] = nafPoints.wnd;
        wnd[i4] = nafPoints.points;
      }
      for (i4 = len - 1; i4 >= 1; i4 -= 2) {
        var a4 = i4 - 1;
        var b5 = i4;
        if (wndWidth[a4] !== 1 || wndWidth[b5] !== 1) {
          naf[a4] = getNAF(coeffs[a4], wndWidth[a4], this._bitLength);
          naf[b5] = getNAF(coeffs[b5], wndWidth[b5], this._bitLength);
          max = Math.max(naf[a4].length, max);
          max = Math.max(naf[b5].length, max);
          continue;
        }
        var comb = [
          points[a4],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b5]
          /* 7 */
        ];
        if (points[a4].y.cmp(points[b5].y) === 0) {
          comb[1] = points[a4].add(points[b5]);
          comb[2] = points[a4].toJ().mixedAdd(points[b5].neg());
        } else if (points[a4].y.cmp(points[b5].y.redNeg()) === 0) {
          comb[1] = points[a4].toJ().mixedAdd(points[b5]);
          comb[2] = points[a4].add(points[b5].neg());
        } else {
          comb[1] = points[a4].toJ().mixedAdd(points[b5]);
          comb[2] = points[a4].toJ().mixedAdd(points[b5].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a4], coeffs[b5]);
        max = Math.max(jsf[0].length, max);
        naf[a4] = new Array(max);
        naf[b5] = new Array(max);
        for (j3 = 0; j3 < max; j3++) {
          var ja = jsf[0][j3] | 0;
          var jb = jsf[1][j3] | 0;
          naf[a4][j3] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b5][j3] = 0;
          wnd[a4] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i4 = max; i4 >= 0; i4--) {
        var k5 = 0;
        while (i4 >= 0) {
          var zero = true;
          for (j3 = 0; j3 < len; j3++) {
            tmp[j3] = naf[j3][i4] | 0;
            if (tmp[j3] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k5++;
          i4--;
        }
        if (i4 >= 0)
          k5++;
        acc = acc.dblp(k5);
        if (i4 < 0)
          break;
        for (j3 = 0; j3 < len; j3++) {
          var z7 = tmp[j3];
          p4;
          if (z7 === 0)
            continue;
          else if (z7 > 0)
            p4 = wnd[j3][z7 - 1 >> 1];
          else if (z7 < 0)
            p4 = wnd[j3][-z7 - 1 >> 1].neg();
          if (p4.type === "affine")
            acc = acc.mixedAdd(p4);
          else
            acc = acc.add(p4);
        }
      }
      for (i4 = 0; i4 < len; i4++)
        wnd[i4] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x8 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x8);
      return [4].concat(x8, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i4 = 0; i4 < power; i4 += step) {
        for (var j3 = 0; j3 < step; j3++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i4 = 1; i4 < max; i4++)
        res[i4] = res[i4 - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k5) {
      var r3 = this;
      for (var i4 = 0; i4 < k5; i4++)
        r3 = r3.dbl();
      return r3;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s2 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s2).fromRed();
      var l22 = ntinv.redSub(s2).fromRed();
      return [l1, l22];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u3 = lambda;
      var v7 = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x22 = new BN(0);
      var y22 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i4 = 0;
      var r3;
      var x8;
      while (u3.cmpn(0) !== 0) {
        var q6 = v7.div(u3);
        r3 = v7.sub(q6.mul(u3));
        x8 = x22.sub(q6.mul(x1));
        var y7 = y22.sub(q6.mul(y1));
        if (!a1 && r3.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r3.neg();
          b1 = x8;
        } else if (a1 && ++i4 === 2) {
          break;
        }
        prevR = r3;
        v7 = u3;
        u3 = r3;
        x22 = x1;
        x1 = x8;
        y22 = y1;
        y1 = y7;
      }
      a22 = r3.neg();
      b22 = x8;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c12 = v22.b.mul(k5).divRound(this.n);
      var c22 = v1.b.neg().mul(k5).divRound(this.n);
      var p1 = c12.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c12.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k5.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var y22 = x8.redSqr().redMul(x8).redIAdd(x8.redMul(this.a)).redIAdd(this.b);
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x8, y7);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x8 = point.x;
      var y7 = point.y;
      var ax = this.a.redMul(x8);
      var rhs = x8.redSqr().redMul(x8).redIAdd(ax).redIAdd(this.b);
      return y7.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i4 = 0; i4 < points.length; i4++) {
        var split = this._endoSplit(coeffs[i4]);
        var p4 = points[i4];
        var beta = p4._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p4 = p4.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i4 * 2] = p4;
        npoints[i4 * 2 + 1] = beta;
        ncoeffs[i4 * 2] = split.k1;
        ncoeffs[i4 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
      for (var j3 = 0; j3 < i4 * 2; j3++) {
        npoints[j3] = null;
        ncoeffs[j3] = null;
      }
      return res;
    };
    function Point(curve, x8, y7, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x8 === null && y7 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x8, y7, isRed) {
      return new Point(this, x8, y7, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p4) {
          return curve.point(p4.x.redMul(curve.endo.beta), p4.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p4) {
      if (this.inf)
        return p4;
      if (p4.inf)
        return this;
      if (this.eq(p4))
        return this.dbl();
      if (this.neg().eq(p4))
        return this.curve.point(null, null);
      if (this.x.cmp(p4.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p4.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p4.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p4.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a4 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k5) {
      k5 = new BN(k5, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k5]);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p4) {
      return this === p4 || this.inf === p4.inf && (this.inf || this.x.cmp(p4.x) === 0 && this.y.cmp(p4.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p4) {
          return p4.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x8, y7, z7) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x8 === null && y7 === null && z7 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        this.z = new BN(z7, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x8, y7, z7) {
      return new JPoint(this, x8, y7, z7);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      var pz2 = p4.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p4.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p4.z));
      var s2 = p4.y.redMul(z22.redMul(this.z));
      var h4 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h4.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h4.redSqr();
      var h32 = h22.redMul(h4);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p4.z).redMul(h4);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p4) {
      if (this.isInfinity())
        return p4.toJ();
      if (p4.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p4.x.redMul(z22);
      var s1 = this.y;
      var s2 = p4.y.redMul(z22).redMul(this.z);
      var h4 = u1.redSub(u22);
      var r3 = s1.redSub(s2);
      if (h4.cmpn(0) === 0) {
        if (r3.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h4.redSqr();
      var h32 = h22.redMul(h4);
      var v7 = u1.redMul(h22);
      var nx = r3.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
      var ny = r3.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h4);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i4;
      if (this.curve.zeroA || this.curve.threeA) {
        var r3 = this;
        for (i4 = 0; i4 < pow; i4++)
          r3 = r3.dbl();
        return r3;
      }
      var a4 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i4 = 0; i4 < pow; i4++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c5.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i4 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s2).redISub(s2);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a4 = this.x.redSqr();
        var b5 = this.y.redSqr();
        var c5 = b5.redSqr();
        var d4 = this.x.redAdd(b5).redSqr().redISub(a4).redISub(c5);
        d4 = d4.redIAdd(d4);
        var e = a4.redAdd(a4).redIAdd(a4);
        var f5 = e.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d4).redISub(d4);
        ny = e.redMul(d4.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s2 = s2.redIAdd(s2);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s2).redISub(s2);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s2.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a4 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee7 = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u3 = m.redIAdd(e).redSqr().redISub(mm).redISub(ee7).redISub(t);
      var yyu4 = yy.redMul(u3);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee7).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u3.redMul(t.redISub(u3)).redISub(e.redMul(ee7)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k5, kbase) {
      k5 = new BN(k5, kbase);
      return this.curve._wnafMul(this, k5);
    };
    JPoint.prototype.eq = function eq(p4) {
      if (p4.type === "affine")
        return this.eq(p4.toJ());
      if (this === p4)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p4.z.redSqr();
      if (this.x.redMul(pz2).redISub(p4.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p4.z);
      return this.y.redMul(pz3).redISub(p4.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x8) {
      var zs3 = this.z.redSqr();
      var rx = x8.toRed(this.curve.red).redMul(zs3);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t = this.curve.redN.redMul(zs3);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x8 = point.normalize().x;
      var x22 = x8.redSqr();
      var rhs = x22.redMul(x8).redAdd(x22.redMul(this.a)).redAdd(x8);
      var y7 = rhs.redSqrt();
      return y7.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x8, z7) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && z7 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x8, 16);
        this.z = new BN(z7, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x8, z7) {
      return new Point(this, x8, z7);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a4 = this.x.redAdd(this.z);
      var aa = a4.redSqr();
      var b5 = this.x.redSub(this.z);
      var bb = b5.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p4, diff) {
      var a4 = this.x.redAdd(this.z);
      var b5 = this.x.redSub(this.z);
      var c5 = p4.x.redAdd(p4.z);
      var d4 = p4.x.redSub(p4.z);
      var da = d4.redMul(a4);
      var cb = c5.redMul(b5);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k5) {
      var t = k5.clone();
      var a4 = this;
      var b5 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i4 = bits.length - 1; i4 >= 0; i4--) {
        if (bits[i4] === 0) {
          a4 = a4.diffAdd(b5, c5);
          b5 = b5.dbl();
        } else {
          b5 = a4.diffAdd(b5, c5);
          a4 = a4.dbl();
        }
      }
      return b5;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x8, y7, z7, t) {
      return this.point(x8, y7, z7, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x8, odd) {
      x8 = new BN(x8, 16);
      if (!x8.red)
        x8 = x8.toRed(this.red);
      var x22 = x8.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x8, y7);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y7, odd) {
      y7 = new BN(y7, 16);
      if (!y7.red)
        y7 = y7.toRed(this.red);
      var y22 = y7.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y7);
      }
      var x8 = x22.redSqrt();
      if (x8.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x8.fromRed().isOdd() !== odd)
        x8 = x8.redNeg();
      return this.point(x8, y7);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x22 = point.x.redSqr();
      var y22 = point.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x8, y7, z7, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x8 === null && y7 === null && z7 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x8, 16);
        this.y = new BN(y7, 16);
        this.z = z7 ? new BN(z7, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x8, y7, z7, t) {
      return new Point(this, x8, y7, z7, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a4 = this.x.redSqr();
      var b5 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d4 = this.curve._mulA(a4);
      var e = this.x.redAdd(this.y).redSqr().redISub(a4).redISub(b5);
      var g6 = d4.redAdd(b5);
      var f5 = g6.redSub(c5);
      var h4 = d4.redSub(b5);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h4);
      var nt5 = e.redMul(h4);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b5 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d4 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h4;
      var j3;
      if (this.curve.twisted) {
        e = this.curve._mulA(c5);
        var f5 = e.redAdd(d4);
        if (this.zOne) {
          nx = b5.redSub(c5).redSub(d4).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e.redSub(d4));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h4 = this.z.redSqr();
          j3 = f5.redSub(h4).redISub(h4);
          nx = b5.redSub(c5).redISub(d4).redMul(j3);
          ny = f5.redMul(e.redSub(d4));
          nz = f5.redMul(j3);
        }
      } else {
        e = c5.redAdd(d4);
        h4 = this.curve._mulC(this.z).redSqr();
        j3 = e.redSub(h4).redSub(h4);
        nx = this.curve._mulC(b5.redISub(e)).redMul(j3);
        ny = this.curve._mulC(e).redMul(c5.redISub(d4));
        nz = e.redMul(j3);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p4) {
      var a4 = this.y.redSub(this.x).redMul(p4.y.redSub(p4.x));
      var b5 = this.y.redAdd(this.x).redMul(p4.y.redAdd(p4.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p4.t);
      var d4 = this.z.redMul(p4.z.redAdd(p4.z));
      var e = b5.redSub(a4);
      var f5 = d4.redSub(c5);
      var g6 = d4.redAdd(c5);
      var h4 = b5.redAdd(a4);
      var nx = e.redMul(f5);
      var ny = g6.redMul(h4);
      var nt5 = e.redMul(h4);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt5);
    };
    Point.prototype._projAdd = function _projAdd(p4) {
      var a4 = this.z.redMul(p4.z);
      var b5 = a4.redSqr();
      var c5 = this.x.redMul(p4.x);
      var d4 = this.y.redMul(p4.y);
      var e = this.curve.d.redMul(c5).redMul(d4);
      var f5 = b5.redSub(e);
      var g6 = b5.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p4.x.redAdd(p4.y)).redISub(c5).redISub(d4);
      var nx = a4.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a4.redMul(g6).redMul(d4.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g6);
      } else {
        ny = a4.redMul(g6).redMul(d4.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p4) {
      if (this.isInfinity())
        return p4;
      if (p4.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p4);
      else
        return this._projAdd(p4);
    };
    Point.prototype.mul = function mul(k5) {
      if (this._hasDoubles(k5))
        return this.curve._fixedNafMul(this, k5);
      else
        return this.curve._wnafMul(this, k5);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p4, k22) {
      return this.curve._wnafMulAdd(1, [this, p4], [k1, k22], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi3 = this.z.redInvm();
      this.x = this.x.redMul(zi3);
      this.y = this.y.redMul(zi3);
      if (this.t)
        this.t = this.t.redMul(zi3);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x8) {
      var rx = x8.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x8.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var curve = exports;
    curve.base = require_base2();
    curve.short = require_short2();
    curve.mont = require_mont2();
    curve.edwards = require_edwards2();
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js
var require_curves2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve2();
    var utils = require_utils4();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k12();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature3 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p4) {
      var initial = buf[p4.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p4.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i4 = 0, off = p4.place; i4 < octetLen; i4++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p4.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i4 = 0;
      var len = buf.length - 1;
      while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
        i4++;
      }
      if (i4 === 0) {
        return buf;
      }
      return buf.slice(i4);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p4 = new Position();
      if (data[p4.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p4);
      if (len === false) {
        return false;
      }
      if (len + p4.place !== data.length) {
        return false;
      }
      if (data[p4.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p4);
      if (rlen === false) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var r3 = data.slice(p4.place, rlen + p4.place);
      p4.place += rlen;
      if (data[p4.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p4);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p4.place) {
        return false;
      }
      if ((data[p4.place] & 128) !== 0) {
        return false;
      }
      var s2 = data.slice(p4.place, slen + p4.place);
      if (r3[0] === 0) {
        if (r3[1] & 128) {
          r3 = r3.slice(1);
        } else {
          return false;
        }
      }
      if (s2[0] === 0) {
        if (s2[1] & 128) {
          s2 = s2.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r3);
      this.s = new BN(s2);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r3 = this.r.toArray();
      var s2 = this.s.toArray();
      if (r3[0] & 128)
        r3 = [0].concat(r3);
      if (s2[0] & 128)
        s2 = [0].concat(s2);
      r3 = rmPadding(r3);
      s2 = rmPadding(s2);
      while (!s2[0] && !(s2[1] & 128)) {
        s2 = s2.slice(1);
      }
      var arr = [2];
      constructLength(arr, r3.length);
      arr = arr.concat(r3);
      arr.push(2);
      constructLength(arr, s2.length);
      var backHalf = arr.concat(s2);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves2();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key3();
    var Signature = require_signature3();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k5 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k5 = this._truncateToN(k5, true);
        if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k5);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r3 = kpX.umod(this.n);
        if (r3.cmpn(0) === 0)
          continue;
        var s2 = k5.invm(this.n).mul(r3.mul(key.getPrivate()).iadd(msg));
        s2 = s2.umod(this.n);
        if (s2.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r3) !== 0 ? 2 : 0);
        if (options.canonical && s2.cmp(this.nh) > 0) {
          s2 = this.n.sub(s2);
          recoveryParam ^= 1;
        }
        return new Signature({ r: r3, s: s2, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r3 = signature.r;
      var s2 = signature.s;
      if (r3.cmpn(1) < 0 || r3.cmp(this.n) >= 0)
        return false;
      if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
        return false;
      var sinv = s2.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r3).umod(this.n);
      var p4;
      if (!this.curve._maxwellTrick) {
        p4 = this.g.mulAdd(u1, key.getPublic(), u22);
        if (p4.isInfinity())
          return false;
        return p4.getX().umod(this.n).cmp(r3) === 0;
      }
      p4 = this.g.jmulAdd(u1, key.getPublic(), u22);
      if (p4.isInfinity())
        return false;
      return p4.eqXToP(r3);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j3, enc) {
      assert((3 & j3) === j3, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n4 = this.n;
      var e = new BN(msg);
      var r3 = signature.r;
      var s2 = signature.s;
      var isYOdd = j3 & 1;
      var isSecondKey = j3 >> 1;
      if (r3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r3 = this.curve.pointFromX(r3.add(this.curve.n), isYOdd);
      else
        r3 = this.curve.pointFromX(r3, isYOdd);
      var rInv = signature.r.invm(n4);
      var s1 = n4.sub(e).mul(rInv).umod(n4);
      var s22 = s2.mul(rInv).umod(n4);
      return this.g.mulAdd(s1, r3, s22);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q5, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i4 = 0; i4 < 4; i4++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i4);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i4;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a4 = hash.slice(0, eddsa.encodingLength);
      a4[0] &= 248;
      a4[lastIx] &= 127;
      a4[lastIx] |= 64;
      return a4;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature4 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var BN = require_bn2();
    var utils = require_utils4();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S8() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R4() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var hash = require_hash();
    var curves = require_curves2();
    var utils = require_utils4();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key4();
    var Signature = require_signature4();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r3 = this.hashInt(key.messagePrefix(), message);
      var R4 = this.g.mul(r3);
      var Rencoded = this.encodePoint(R4);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S8 = r3.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R4, S: S8, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h4 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h4));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i4 = 0; i4 < arguments.length; i4++)
        hash2.update(arguments[i4]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y7 = utils.intFromLE(normed);
      return this.curve.pointFromY(y7, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var import_dist139 = __toESM(require_dist());
    var import_dist140 = __toESM(require_dist2());
    var import_dist141 = __toESM(require_dist3());
    var elliptic = exports;
    elliptic.version = require_package2().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve2();
    elliptic.curves = require_curves2();
    elliptic.ec = require_ec2();
    elliptic.eddsa = require_eddsa2();
  }
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_dist136 = __toESM(require_dist());
var import_dist137 = __toESM(require_dist2());
var import_dist138 = __toESM(require_dist3());

// node_modules/@walletconnect/core/dist/index.es.js
var import_dist13 = __toESM(require_dist());
var import_dist14 = __toESM(require_dist2());
var import_dist15 = __toESM(require_dist3());
var import_events6 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_esm();
var n = class extends IEvents {
  constructor(e) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r2 = { pulse: "heartbeat_pulse" };
var i = class _i extends n {
  constructor(e) {
    super(e), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e == null ? void 0 : e.interval) || s;
  }
  static async init(e) {
    const t = new _i(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r2.pulse);
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());
init_esm();
var import_events4 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p = class {
  constructor(s2, t, e, f5) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y2 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C2 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_dist7 = __toESM(require_dist());
var import_dist8 = __toESM(require_dist2());
var import_dist9 = __toESM(require_dist3());
var import_time2 = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var q = __toESM(require_query_string());
init_lib();
init_lib2();
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var _e = __toESM(require_x25519());
var import_elliptic = __toESM(require_elliptic());
var gt = Object.defineProperty;
var Ke = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var bt = Object.prototype.propertyIsEnumerable;
var Le = (e, n4, t) => n4 in e ? gt(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var Fe = (e, n4) => {
  for (var t in n4 || (n4 = {})) vt.call(n4, t) && Le(e, t, n4[t]);
  if (Ke) for (var t of Ke(n4)) bt.call(n4, t) && Le(e, t, n4[t]);
  return e;
};
var qe = "ReactNative";
var y3 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var He = "js";
function ce() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function _() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === qe;
}
function V() {
  return !ce() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function P() {
  return _() ? y3.reactNative : ce() ? y3.node : V() ? y3.browser : y3.unknown;
}
function Ot() {
  var e;
  try {
    return _() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function We(e, n4) {
  let t = q.parse(e);
  return t = Fe(Fe({}, t), n4), e = q.stringify(t), e;
}
function Nt() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Je() {
  if (P() === y3.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r3 } = global.Platform;
    return [t, r3].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function ze() {
  var e;
  const n4 = P();
  return n4 === y3.browser ? [n4, ((e = (0, import_window_getters.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ge(e, n4, t) {
  const r3 = Je(), o4 = ze();
  return [[e, n4].join("-"), [He, t].join("-"), r3, o4].join("/");
}
function $t({ protocol: e, version: n4, relayUrl: t, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i4, bundleId: u3 }) {
  const l3 = t.split("?"), c5 = Ge(e, n4, r3), d4 = { auth: o4, ua: c5, projectId: s2, useOnCloseEvent: i4 || void 0, origin: u3 || void 0 }, a4 = We(l3[1] || "", d4);
  return l3[0] + "?" + a4;
}
function Tt(e) {
  return Object.fromEntries(e.entries());
}
function Pt(e) {
  return new Map(Object.entries(e));
}
function _t(e = import_time2.FIVE_MINUTES, n4) {
  const t = (0, import_time2.toMiliseconds)(e || import_time2.FIVE_MINUTES);
  let r3, o4, s2;
  return { resolve: (i4) => {
    s2 && r3 && (clearTimeout(s2), r3(i4));
  }, reject: (i4) => {
    s2 && o4 && (clearTimeout(s2), o4(i4));
  }, done: () => new Promise((i4, u3) => {
    s2 = setTimeout(() => {
      u3(new Error(n4));
    }, t), r3 = i4, o4 = u3;
  }) };
}
function kt(e, n4, t) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(t)), n4);
    try {
      const i4 = await e;
      r3(i4);
    } catch (i4) {
      o4(i4);
    }
    clearTimeout(s2);
  });
}
function ae(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`)) return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function Dt(e) {
  return ae("topic", e);
}
function xt(e) {
  return ae("id", e);
}
function Vt(e) {
  const [n4, t] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string") r3.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t))) r3.id = Number(t);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r3;
}
function Mt(e, n4) {
  return (0, import_time2.fromMiliseconds)((n4 || Date.now()) + (0, import_time2.toMiliseconds)(e));
}
function Kt(e) {
  return Date.now() >= (0, import_time2.toMiliseconds)(e);
}
function Lt(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
function Ht() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const n4 = Math.random() * 16 | 0;
    return (e === "x" ? n4 : n4 & 3 | 8).toString(16);
  });
}
function Wt() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function le(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
var ye = "base10";
var g2 = "base16";
var ge = "base64pad";
var k2 = "utf8";
var ve = 0;
var D = 1;
var M = 2;
var dr = 0;
var wn = 1;
var K = 12;
var be = 32;
function fr() {
  const e = _e.generateKeyPair();
  return { privateKey: toString(e.secretKey, g2), publicKey: toString(e.publicKey, g2) };
}
function pr() {
  const e = (0, import_random.randomBytes)(be);
  return toString(e, g2);
}
function mr(e, n4) {
  const t = _e.sharedKey(fromString(e, g2), fromString(n4, g2), true), r3 = new import_hkdf.HKDF(import_sha256.SHA256, t).expand(be);
  return toString(r3, g2);
}
function hr(e) {
  const n4 = (0, import_sha256.hash)(fromString(e, g2));
  return toString(n4, g2);
}
function yr(e) {
  const n4 = (0, import_sha256.hash)(fromString(e, k2));
  return toString(n4, g2);
}
function Ee(e) {
  return fromString(`${e}`, ye);
}
function A2(e) {
  return Number(toString(e, ye));
}
function gr(e) {
  const n4 = Ee(typeof e.type < "u" ? e.type : ve);
  if (A2(n4) === D && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, g2) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, g2) : (0, import_random.randomBytes)(K), o4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g2)).seal(r3, fromString(e.message, k2));
  return we({ type: n4, sealed: o4, iv: r3, senderPublicKey: t, encoding: e.encoding });
}
function vr(e, n4) {
  const t = Ee(M), r3 = (0, import_random.randomBytes)(K), o4 = fromString(e, k2);
  return we({ type: t, sealed: o4, iv: r3, encoding: n4 });
}
function br(e) {
  const n4 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e.symKey, g2)), { sealed: t, iv: r3 } = Q({ encoded: e.encoded, encoding: e == null ? void 0 : e.encoding }), o4 = n4.open(r3, t);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString(o4, k2);
}
function Er(e, n4) {
  const { sealed: t } = Q({ encoded: e, encoding: n4 });
  return toString(t, k2);
}
function we(e) {
  const { encoding: n4 = ge } = e;
  if (A2(e.type) === M) return toString(concat([e.type, e.sealed]), n4);
  if (A2(e.type) === D) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), n4);
  }
  return toString(concat([e.type, e.iv, e.sealed]), n4);
}
function Q(e) {
  const { encoded: n4, encoding: t = ge } = e, r3 = fromString(n4, t), o4 = r3.slice(dr, wn), s2 = wn;
  if (A2(o4) === D) {
    const c5 = s2 + be, d4 = c5 + K, a4 = r3.slice(s2, c5), f5 = r3.slice(c5, d4), h4 = r3.slice(d4);
    return { type: o4, sealed: h4, iv: f5, senderPublicKey: a4 };
  }
  if (A2(o4) === M) {
    const c5 = r3.slice(s2), d4 = (0, import_random.randomBytes)(K);
    return { type: o4, sealed: c5, iv: d4 };
  }
  const i4 = s2 + K, u3 = r3.slice(s2, i4), l3 = r3.slice(i4);
  return { type: o4, sealed: l3, iv: u3 };
}
function wr(e, n4) {
  const t = Q({ encoded: e, encoding: n4 == null ? void 0 : n4.encoding });
  return On({ type: A2(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, g2) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function On(e) {
  const n4 = (e == null ? void 0 : e.type) || ve;
  if (n4 === D) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Or(e) {
  return e.type === D && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function Nr(e) {
  return e.type === M;
}
function Nn(e) {
  return new import_elliptic.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function Sr(e) {
  let n4 = e.replace(/-/g, "+").replace(/_/g, "/");
  const t = n4.length % 4;
  return t > 0 && (n4 += "=".repeat(4 - t)), n4;
}
function $r(e) {
  return Buffer.from(Sr(e), "base64");
}
function Rr(e, n4) {
  const [t, r3, o4] = e.split("."), s2 = $r(o4);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), u3 = s2.slice(32, 64).toString("hex"), l3 = `${t}.${r3}`, c5 = new import_sha256.SHA256().update(Buffer.from(l3)).digest(), d4 = Nn(n4), a4 = Buffer.from(c5).toString("hex");
  if (!d4.verify(a4, { r: i4, s: u3 })) throw new Error("Invalid signature");
  return decodeJWT(e).payload;
}
var Sn = "irn";
function Ir(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Sn };
}
function jr(e) {
  const n4 = C[e];
  if (typeof n4 > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var Tr = Object.defineProperty;
var Pr = Object.defineProperties;
var Ar = Object.getOwnPropertyDescriptors;
var $n = Object.getOwnPropertySymbols;
var Cr = Object.prototype.hasOwnProperty;
var Ur = Object.prototype.propertyIsEnumerable;
var Rn = (e, n4, t) => n4 in e ? Tr(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var In = (e, n4) => {
  for (var t in n4 || (n4 = {})) Cr.call(n4, t) && Rn(e, t, n4[t]);
  if ($n) for (var t of $n(n4)) Ur.call(n4, t) && Rn(e, t, n4[t]);
  return e;
};
var _r = (e, n4) => Pr(e, Ar(n4));
function jn(e, n4 = "-") {
  const t = {}, r3 = "relay" + n4;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i4 = e[o4];
      t[s2] = i4;
    }
  }), t;
}
function kr(e) {
  if (!e.includes("wc:")) {
    const l3 = le(e);
    l3 != null && l3.includes("wc:") && (e = l3);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, n4), o4 = e.substring(n4 + 1, t).split("@"), s2 = typeof t < "u" ? e.substring(t) : "", i4 = q.parse(s2), u3 = typeof i4.methods == "string" ? i4.methods.split(",") : void 0;
  return { protocol: r3, topic: Tn(o4[0]), version: parseInt(o4[1], 10), symKey: i4.symKey, relay: jn(i4), methods: u3, expiryTimestamp: i4.expiryTimestamp ? parseInt(i4.expiryTimestamp, 10) : void 0 };
}
function Tn(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function Pn(e, n4 = "-") {
  const t = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = t + n4 + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function Dr(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + q.stringify(In(_r(In({ symKey: e.symKey }, Pn(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {}));
}
var Vn = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Mn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S(e, n4) {
  const { message: t, code: r3 } = Mn[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function U(e, n4) {
  const { message: t, code: r3 } = Vn[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function L(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function I(e) {
  return typeof e > "u";
}
function b(e, n4) {
  return n4 && I(e) ? true : typeof e == "string" && !!e.trim().length;
}
function X(e, n4) {
  return n4 && I(e) ? true : typeof e == "number" && !isNaN(e);
}
function Gr(e) {
  function n4(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (b(e, false)) {
      if (n4(e)) return true;
      const t = le(e);
      return n4(t);
    }
  } catch {
  }
  return false;
}
function Yr(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function Qr(e) {
  return e == null ? void 0 : e.topic;
}
function to(e) {
  return typeof e < "u" && typeof e !== null;
}
function po(e, n4) {
  return X(e, false) && e <= n4.max && e >= n4.min;
}
function mo() {
  const e = P();
  return new Promise((n4) => {
    switch (e) {
      case y3.browser:
        n4(Yn());
        break;
      case y3.reactNative:
        n4(Qn());
        break;
      case y3.node:
        n4(Zn());
        break;
      default:
        n4(true);
    }
  });
}
function Yn() {
  return V() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn() {
  if (_() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Zn() {
  return true;
}
function ho(e) {
  switch (P()) {
    case y3.browser:
      Xn(e);
      break;
    case y3.reactNative:
      et(e);
      break;
    case y3.node:
      break;
  }
}
function Xn(e) {
  !_() && V() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function et(e) {
  _() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());
var import_events5 = __toESM(require_events());
var o2 = class extends r {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  async request(t, e) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e);
  }
  async requestStrict(t, e) {
    return new Promise(async (i4, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i4(n4.result);
      });
      try {
        await this.connection.send(t, e);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_window_getters2 = __toESM(require_cjs2());
var ye2 = "wc";
var De = 2;
var ie = "core";
var x2 = `${ye2}@2:${ie}:`;
var Ye = { name: ie, logger: "error" };
var Je2 = { database: ":memory:" };
var Xe = "crypto";
var me = "client_ed25519_seed";
var We2 = import_time3.ONE_DAY;
var Ze = "keychain";
var Qe = "0.3";
var et2 = "messages";
var tt = "0.3";
var it2 = import_time3.SIX_HOURS;
var st2 = "publisher";
var rt = "irn";
var nt = "error";
var be2 = "wss://relay.walletconnect.org";
var ot = "relayer";
var v2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var at2 = "_subscription";
var I2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht = 0.1;
var se = "2.17.2";
var M2 = { link_mode: "link_mode", relay: "relay" };
var ct = "0.3";
var lt = "WALLETCONNECT_CLIENT_ID";
var fe = "WALLETCONNECT_LINK_MODE_APPS";
var O = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var ut2 = "subscription";
var dt = "0.3";
var pt = import_time3.FIVE_SECONDS * 1e3;
var gt2 = "pairing";
var yt = "0.3";
var B2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var V2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Dt2 = "history";
var mt = "0.3";
var bt2 = "expirer";
var S2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var ft = "0.3";
var _t2 = "verify-api";
var vs = "https://verify.walletconnect.com";
var Et = "https://verify.walletconnect.org";
var J = Et;
var vt2 = `${J}/v3`;
var wt = [vs, Et];
var It = "echo";
var Tt2 = "https://echo.walletconnect.com";
var z = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $ = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Ct = 0.1;
var Pt2 = "event-client";
var St = 86400;
var Rt = "https://pulse.walletconnect.org/batch";
function Ss(o4, e) {
  if (o4.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i4 = 0; i4 < o4.length; i4++) {
    var r3 = o4.charAt(i4), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i4;
  }
  var a4 = o4.length, h4 = o4.charAt(0), c5 = Math.log(a4) / Math.log(256), l3 = Math.log(256) / Math.log(a4);
  function p4(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u3.length === 0) return "";
    for (var g6 = 0, _4 = 0, y7 = 0, b5 = u3.length; y7 !== b5 && u3[y7] === 0; ) y7++, g6++;
    for (var A5 = (b5 - y7) * l3 + 1 >>> 0, T3 = new Uint8Array(A5); y7 !== b5; ) {
      for (var N3 = u3[y7], k5 = 0, R4 = A5 - 1; (N3 !== 0 || k5 < _4) && R4 !== -1; R4--, k5++) N3 += 256 * T3[R4] >>> 0, T3[R4] = N3 % a4 >>> 0, N3 = N3 / a4 >>> 0;
      if (N3 !== 0) throw new Error("Non-zero carry");
      _4 = k5, y7++;
    }
    for (var L5 = A5 - _4; L5 !== A5 && T3[L5] === 0; ) L5++;
    for (var Q5 = h4.repeat(g6); L5 < A5; ++L5) Q5 += o4.charAt(T3[L5]);
    return Q5;
  }
  function D5(u3) {
    if (typeof u3 != "string") throw new TypeError("Expected String");
    if (u3.length === 0) return new Uint8Array();
    var g6 = 0;
    if (u3[g6] !== " ") {
      for (var _4 = 0, y7 = 0; u3[g6] === h4; ) _4++, g6++;
      for (var b5 = (u3.length - g6) * c5 + 1 >>> 0, A5 = new Uint8Array(b5); u3[g6]; ) {
        var T3 = t[u3.charCodeAt(g6)];
        if (T3 === 255) return;
        for (var N3 = 0, k5 = b5 - 1; (T3 !== 0 || N3 < y7) && k5 !== -1; k5--, N3++) T3 += a4 * A5[k5] >>> 0, A5[k5] = T3 % 256 >>> 0, T3 = T3 / 256 >>> 0;
        if (T3 !== 0) throw new Error("Non-zero carry");
        y7 = N3, g6++;
      }
      if (u3[g6] !== " ") {
        for (var R4 = b5 - y7; R4 !== b5 && A5[R4] === 0; ) R4++;
        for (var L5 = new Uint8Array(_4 + (b5 - R4)), Q5 = _4; R4 !== b5; ) L5[Q5++] = A5[R4++];
        return L5;
      }
    }
  }
  function m(u3) {
    var g6 = D5(u3);
    if (g6) return g6;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p4, decodeUnsafe: D5, decode: m };
}
var Rs = Ss;
var xs = Rs;
var xt2 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array") return o4;
  if (o4 instanceof ArrayBuffer) return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4)) return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Os = (o4) => new TextEncoder().encode(o4);
var As = (o4) => new TextDecoder().decode(o4);
var Ns = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var zs = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ot2(this, e);
  }
};
var Ls = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ot2(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ot2 = (o4, e) => new Ls({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var $s = class {
  constructor(e, t, s2, i4) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Ns(e, t, s2), this.decoder = new zs(e, t, i4);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var re = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new $s(o4, e, t, s2);
var X2 = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i4 } = xs(t, e);
  return re({ prefix: o4, name: e, encode: s2, decode: (r3) => xt2(i4(r3)) });
};
var ks = (o4, e, t, s2) => {
  const i4 = {};
  for (let l3 = 0; l3 < e.length; ++l3) i4[e[l3]] = l3;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a4 = 0, h4 = 0, c5 = 0;
  for (let l3 = 0; l3 < r3; ++l3) {
    const p4 = i4[o4[l3]];
    if (p4 === void 0) throw new SyntaxError(`Non-${s2} character`);
    h4 = h4 << t | p4, a4 += t, a4 >= 8 && (a4 -= 8, n4[c5++] = 255 & h4 >> a4);
  }
  if (a4 >= t || 255 & h4 << 8 - a4) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Ms = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i4 = (1 << t) - 1;
  let r3 = "", n4 = 0, a4 = 0;
  for (let h4 = 0; h4 < o4.length; ++h4) for (a4 = a4 << 8 | o4[h4], n4 += 8; n4 > t; ) n4 -= t, r3 += e[i4 & a4 >> n4];
  if (n4 && (r3 += e[i4 & a4 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var f2 = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => re({ prefix: e, name: o4, encode(i4) {
  return Ms(i4, s2, t);
}, decode(i4) {
  return ks(i4, s2, t, o4);
} });
var Us = re({ prefix: "\0", name: "identity", encode: (o4) => As(o4), decode: (o4) => Os(o4) });
var Fs = Object.freeze({ __proto__: null, identity: Us });
var Ks = f2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs = Object.freeze({ __proto__: null, base2: Ks });
var Vs = f2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js = Object.freeze({ __proto__: null, base8: Vs });
var qs = X2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs = Object.freeze({ __proto__: null, base10: qs });
var Hs = f2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ys = f2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js = Object.freeze({ __proto__: null, base16: Hs, base16upper: Ys });
var Xs = f2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ws = f2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Zs = f2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Qs = f2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var er = f2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var tr = f2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ir = f2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var sr = f2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var rr = f2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr = Object.freeze({ __proto__: null, base32: Xs, base32upper: Ws, base32pad: Zs, base32padupper: Qs, base32hex: er, base32hexupper: tr, base32hexpad: ir, base32hexpadupper: sr, base32z: rr });
var or = X2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ar = X2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr2 = Object.freeze({ __proto__: null, base36: or, base36upper: ar });
var cr = X2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var lr = X2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur = Object.freeze({ __proto__: null, base58btc: cr, base58flickr: lr });
var dr2 = f2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var pr2 = f2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var gr2 = f2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var yr2 = f2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr2 = Object.freeze({ __proto__: null, base64: dr2, base64pad: pr2, base64url: gr2, base64urlpad: yr2 });
var At = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var mr2 = At.reduce((o4, e, t) => (o4[t] = e, o4), []);
var br2 = At.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function fr2(o4) {
  return o4.reduce((e, t) => (e += mr2[t], e), "");
}
function _r2(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = br2[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Er2 = re({ prefix: "🚀", name: "base256emoji", encode: fr2, decode: _r2 });
var vr2 = Object.freeze({ __proto__: null, base256emoji: Er2 });
var wr2 = zt;
var Nt2 = 128;
var Ir2 = 127;
var Tr2 = ~Ir2;
var Cr2 = Math.pow(2, 31);
function zt(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Cr2; ) e[t++] = o4 & 255 | Nt2, o4 /= 128;
  for (; o4 & Tr2; ) e[t++] = o4 & 255 | Nt2, o4 >>>= 7;
  return e[t] = o4 | 0, zt.bytes = t - s2 + 1, e;
}
var Pr2 = _e2;
var Sr2 = 128;
var Lt2 = 127;
function _e2(o4, s2) {
  var t = 0, s2 = s2 || 0, i4 = 0, r3 = s2, n4, a4 = o4.length;
  do {
    if (r3 >= a4) throw _e2.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i4 < 28 ? (n4 & Lt2) << i4 : (n4 & Lt2) * Math.pow(2, i4), i4 += 7;
  } while (n4 >= Sr2);
  return _e2.bytes = r3 - s2, t;
}
var Rr2 = Math.pow(2, 7);
var xr = Math.pow(2, 14);
var Or2 = Math.pow(2, 21);
var Ar2 = Math.pow(2, 28);
var Nr2 = Math.pow(2, 35);
var zr = Math.pow(2, 42);
var Lr = Math.pow(2, 49);
var $r2 = Math.pow(2, 56);
var kr2 = Math.pow(2, 63);
var Mr = function(o4) {
  return o4 < Rr2 ? 1 : o4 < xr ? 2 : o4 < Or2 ? 3 : o4 < Ar2 ? 4 : o4 < Nr2 ? 5 : o4 < zr ? 6 : o4 < Lr ? 7 : o4 < $r2 ? 8 : o4 < kr2 ? 9 : 10;
};
var Ur2 = { encode: wr2, decode: Pr2, encodingLength: Mr };
var $t2 = Ur2;
var kt2 = (o4, e, t = 0) => ($t2.encode(o4, e, t), e);
var Mt2 = (o4) => $t2.encodingLength(o4);
var Ee2 = (o4, e) => {
  const t = e.byteLength, s2 = Mt2(o4), i4 = s2 + Mt2(t), r3 = new Uint8Array(i4 + t);
  return kt2(o4, r3, 0), kt2(t, r3, s2), r3.set(e, i4), new Fr(o4, t, e, r3);
};
var Fr = class {
  constructor(e, t, s2, i4) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i4;
  }
};
var Ut = ({ name: o4, code: e, encode: t }) => new Kr(o4, e, t);
var Kr = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ee2(this.code, t) : t.then((s2) => Ee2(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ft = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var Br = Ut({ name: "sha2-256", code: 18, encode: Ft("SHA-256") });
var Vr = Ut({ name: "sha2-512", code: 19, encode: Ft("SHA-512") });
var jr2 = Object.freeze({ __proto__: null, sha256: Br, sha512: Vr });
var Kt2 = 0;
var qr = "identity";
var Bt = xt2;
var Gr2 = (o4) => Ee2(Kt2, Bt(o4));
var Hr = { code: Kt2, name: qr, encode: Bt, digest: Gr2 };
var Yr2 = Object.freeze({ __proto__: null, identity: Hr });
new TextEncoder(), new TextDecoder();
var Vt2 = { ...Fs, ...Bs, ...js, ...Gs, ...Js, ...nr, ...hr2, ...ur, ...Dr2, ...vr2 };
({ ...jr2, ...Yr2 });
function Jr(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function jt(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var qt = jt("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var ve2 = jt("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++) e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = Jr(o4.length);
  for (let t = 0; t < o4.length; t++) e[t] = o4.charCodeAt(t);
  return e;
});
var Xr = { utf8: qt, "utf-8": qt, hex: Vt2.base16, latin1: ve2, ascii: ve2, binary: ve2, ...Vt2 };
function Wr(o4, e = "utf8") {
  const t = Xr[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Gt = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze, this.version = Qe, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = S("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Tt(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ht2 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Xe, this.randomSessionIdentifier = pr(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i4) => (this.isInitialized(), this.keychain.has(i4)), this.getClientId = async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = generateKeyPair(i4);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i4 = fr();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }, this.signJWT = async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a4 = this.randomSessionIdentifier, h4 = We2;
      return await signJWT(a4, i4, h4, n4);
    }, this.generateSharedKey = (i4, r3, n4) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(i4), h4 = mr(a4, r3);
      return this.setSymKey(h4, n4);
    }, this.setSymKey = async (i4, r3) => {
      this.isInitialized();
      const n4 = r3 || hr(i4);
      return await this.keychain.set(n4, i4), n4;
    }, this.deleteKeyPair = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.deleteSymKey = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.encode = async (i4, r3, n4) => {
      this.isInitialized();
      const a4 = On(n4), h4 = safeJsonStringify(r3);
      if (Nr(a4)) return vr(h4, n4 == null ? void 0 : n4.encoding);
      if (Or(a4)) {
        const D5 = a4.senderPublicKey, m = a4.receiverPublicKey;
        i4 = await this.generateSharedKey(D5, m);
      }
      const c5 = this.getSymKey(i4), { type: l3, senderPublicKey: p4 } = a4;
      return gr({ type: l3, symKey: c5, message: h4, senderPublicKey: p4, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i4, r3, n4) => {
      this.isInitialized();
      const a4 = wr(r3, n4);
      if (Nr(a4)) {
        const h4 = Er(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(h4);
      }
      if (Or(a4)) {
        const h4 = a4.receiverPublicKey, c5 = a4.senderPublicKey;
        i4 = await this.generateSharedKey(h4, c5);
      }
      try {
        const h4 = this.getSymKey(i4), c5 = br({ symKey: h4, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(c5);
      } catch (h4) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(h4);
      }
    }, this.getPayloadType = (i4, r3 = ge) => {
      const n4 = Q({ encoded: i4, encoding: r3 });
      return A2(n4.type);
    }, this.getPayloadSenderPublicKey = (i4, r3 = ge) => {
      const n4 = Q({ encoded: i4, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, g2) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Gt(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me);
    } catch {
      e = pr(), await this.keychain.set(me, e);
    }
    return Wr(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt = class extends a2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = et2, this.version = tt, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i4) => {
      this.isInitialized();
      const r3 = yr(i4);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i4, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }, this.has = (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = yr(i4);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Tt(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zr = class extends g {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events6.EventEmitter(), this.name = st2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.failedPublishTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i4, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a4 = (r3 == null ? void 0 : r3.ttl) || it2, h4 = Ir(r3), c5 = (r3 == null ? void 0 : r3.prompt) || false, l3 = (r3 == null ? void 0 : r3.tag) || 0, p4 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D5 = { topic: s2, message: i4, opts: { ttl: a4, relay: h4, prompt: c5, tag: l3, id: p4, attestation: r3 == null ? void 0 : r3.attestation } }, m = `Failed to publish payload, please try again. id:${p4} tag:${l3}`, u3 = Date.now();
      let g6, _4 = 1;
      try {
        for (; g6 === void 0; ) {
          if (Date.now() - u3 > this.publishTimeout) throw new Error(m);
          this.logger.trace({ id: p4, attempts: _4 }, `publisher.publish - attempt ${_4}`), g6 = await await kt(this.rpcPublish(s2, i4, a4, h4, c5, l3, p4, r3 == null ? void 0 : r3.attestation).catch((y7) => this.logger.warn(y7)), this.publishTimeout, m), _4++, g6 || await new Promise((y7) => setTimeout(y7, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v2.publish, D5), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p4, topic: s2, message: i4, opts: r3 } });
      } catch (y7) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(y7), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw y7;
        this.queue.set(p4, D5);
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e, t, s2, i4, r3, n4, a4, h4) {
    var c5, l3, p4, D5;
    const m = { method: jr(i4.protocol).publish, params: { topic: e, message: t, ttl: s2, prompt: r3, tag: n4, attestation: h4 }, id: a4 };
    return I((c5 = m.params) == null ? void 0 : c5.prompt) && ((l3 = m.params) == null || delete l3.prompt), I((p4 = m.params) == null ? void 0 : p4.tag) && ((D5 = m.params) == null || delete D5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m }), this.relayer.request(m);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: s2, opts: i4 } = e;
      await this.publish(t, s2, i4);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v2.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Qr2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s2 = this.get(e);
      if (!this.exists(e, t)) return;
      const i4 = s2.filter((r3) => r3 !== t);
      if (!i4.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i4);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var en = Object.defineProperty;
var tn = Object.defineProperties;
var sn = Object.getOwnPropertyDescriptors;
var Jt = Object.getOwnPropertySymbols;
var rn = Object.prototype.hasOwnProperty;
var nn = Object.prototype.propertyIsEnumerable;
var Xt = (o4, e, t) => e in o4 ? en(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var W = (o4, e) => {
  for (var t in e || (e = {})) rn.call(e, t) && Xt(o4, t, e[t]);
  if (Jt) for (var t of Jt(e)) nn.call(e, t) && Xt(o4, t, e[t]);
  return o4;
};
var we2 = (o4, e) => tn(o4, sn(e));
var Wt2 = class extends d {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr2(), this.events = new import_events6.EventEmitter(), this.name = ut2, this.version = dt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x2, this.subscribeTimeout = (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = Ir(i4), n4 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, n4);
        const a4 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a4 == "string" && (this.onSubscribe(a4, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a4;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i4) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a4 = new import_time3.Watch();
        a4.start(i4);
        const h4 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(h4), a4.stop(i4), r3(true)), a4.elapsed(i4) >= pt && (clearInterval(h4), a4.stop(i4), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e, i4, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i4 = Ir(s2);
      await this.rpcUnsubscribe(e, t, i4);
      const r3 = U("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i4;
    (s2 == null ? void 0 : s2.transportType) === M2.relay && await this.restartToComplete();
    const r3 = { method: jr(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const n4 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a4 = yr(e + this.clientId);
      if ((s2 == null ? void 0 : s2.transportType) === M2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((c5) => this.logger.warn(c5));
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND)), a4;
      const h4 = await kt(this.relayer.request(r3).catch((c5) => this.logger.warn(c5)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h4 && n4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h4 ? a4 : null;
    } catch (a4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v2.connection_stalled), n4) throw a4;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr(t.protocol).batchSubscribe, params: { topics: e.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await kt(this.relayer.request(s2).catch((i4) => this.logger.warn(i4)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await kt(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v2.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e, t, s2) {
    const i4 = { method: jr(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, we2(W({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, W({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, W({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = S("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(O.deleted, we2(W({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(O.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = S("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const t = await this.rpcBatchSubscribe(e);
    L(t) && this.onBatchSubscribe(t.map((s2, i4) => we2(W({}, e[i4]), { id: s2 })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O.created, async (e) => {
      const t = O.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(O.deleted, async (e) => {
      const t = O.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var on = Object.defineProperty;
var Zt = Object.getOwnPropertySymbols;
var an = Object.prototype.hasOwnProperty;
var hn = Object.prototype.propertyIsEnumerable;
var Qt = (o4, e, t) => e in o4 ? on(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ei = (o4, e) => {
  for (var t in e || (e = {})) an.call(e, t) && Qt(o4, t, e[t]);
  if (Zt) for (var t of Zt(e)) hn.call(e, t) && Qt(o4, t, e[t]);
  return o4;
};
var ti = class extends u {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events6.EventEmitter(), this.name = ot, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time3.toMiliseconds)(import_time3.THIRTY_SECONDS + import_time3.ONE_SECOND), this.request = async (t) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a4 = await new Promise(async (h4, c5) => {
          const l3 = () => {
            c5(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(I2.disconnect, l3);
          const p4 = await n4;
          this.provider.off(I2.disconnect, l3), h4(p4);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - published"), a4;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (ce()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i4;
          (i4 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(v2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I2.payload, this.onPayloadHandler), this.provider.on(I2.connect, this.onConnectHandler), this.provider.on(I2.disconnect, this.onDisconnectHandler), this.provider.on(I2.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || nt })), this.messages = new Yt(this.logger, e.core), this.subscriber = new Wt2(this, this.logger), this.publisher = new Zr(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || be2, this.projectId = e.projectId, this.bundleId = Ot(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: M2.relay });
  }
  async subscribe(e, t) {
    var s2, i4, r3;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    const n4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a4 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", h4;
    const c5 = (l3) => {
      l3.topic === e && (this.subscriber.off(O.created, c5), h4());
    };
    return await Promise.all([new Promise((l3) => {
      h4 = l3, this.subscriber.on(O.created, c5);
    }), new Promise(async (l3, p4) => {
      a4 = await this.subscriber.subscribe(e, ei({ internal: { throwOnFailedPublish: n4 } }, t)).catch((D5) => {
        n4 && p4(D5);
      }) || a4, l3();
    })]), a4;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await kt(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i4 = () => {
          this.provider.off(I2.disconnect, i4), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I2.disconnect, i4), await kt(this.provider.connect(), (0, import_time3.toMiliseconds)(import_time3.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i4) {
      this.logger.warn(i4);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i4 = Mt(import_time3.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(v2.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, t, s2, i4, r3;
    if (ce()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f($t({ sdkVersion: se, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i4 = this.messages.has(t, s2);
    return i4 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(at2)) return;
      const t = e.params, { topic: s2, message: i4, publishedAt: r3, attestation: n4 } = t.data, a4 = { topic: s2, message: i4, publishedAt: r3, transportType: M2.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei({ type: "event", event: t.id }, a4)), this.events.emit(t.id, a4), await this.acknowledgePayload(e), await this.onMessageEvent(a4);
    } else isJsonRpcResponse(e) && this.events.emit(v2.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v2.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(I2.payload, this.onPayloadHandler), this.provider.off(I2.connect, this.onConnectHandler), this.provider.off(I2.disconnect, this.onDisconnectHandler), this.provider.off(I2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await mo();
    ho(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v2.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time3.toMiliseconds)(ht))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var cn = Object.defineProperty;
var ii = Object.getOwnPropertySymbols;
var ln = Object.prototype.hasOwnProperty;
var un = Object.prototype.propertyIsEnumerable;
var si = (o4, e, t) => e in o4 ? cn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ri = (o4, e) => {
  for (var t in e || (e = {})) ln.call(e, t) && si(o4, t, e[t]);
  if (ii) for (var t of ii(e)) un.call(e, t) && si(o4, t, e[t]);
  return o4;
};
var ni = class extends p {
  constructor(e, t, s2, i4 = x2, r3 = void 0) {
    super(e, t, s2, i4), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = ct, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !I(n4) ? this.map.set(this.getKey(n4), n4) : Yr(n4) ? this.map.set(n4.id, n4) : Qr(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a4 }), this.map.set(n4, a4), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a4) => Object.keys(n4).every((h4) => (0, import_lodash.default)(a4[h4], n4[h4]))) : this.values), this.update = async (n4, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a4 });
      const h4 = ri(ri({}, this.getData(n4)), a4);
      this.map.set(n4, h4), await this.persist();
    }, this.delete = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a4 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i4 } = S("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = S("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = S("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var oi = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = gt2, this.version = yt, this.events = new import_events6.default(), this.initialized = false, this.storagePrefix = x2, this.ignoredPayloadTypes = [D], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i4 = pr(), r3 = await this.core.crypto.setSymKey(i4), n4 = Mt(import_time3.FIVE_MINUTES), a4 = { protocol: rt }, h4 = { topic: r3, expiry: n4, relay: a4, active: false, methods: s2 == null ? void 0 : s2.methods }, c5 = Dr({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a4, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(V2.create, h4), this.core.expirer.set(r3, n4), await this.pairings.set(r3, h4), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: c5 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: n4, relay: a4, expiryTimestamp: h4, methods: c5 } = kr(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(z.pairing_uri_validation_success), i4.addTrace(z.pairing_uri_not_expired);
      let l3;
      if (this.pairings.keys.includes(r3)) {
        if (l3 = this.pairings.get(r3), i4.addTrace(z.existing_pairing), l3.active) throw i4.setError($.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(z.pairing_not_expired);
      }
      const p4 = h4 || Mt(import_time3.FIVE_MINUTES), D5 = { topic: r3, relay: a4, expiry: p4, active: false, methods: c5 };
      this.core.expirer.set(r3, p4), await this.pairings.set(r3, D5), i4.addTrace(z.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(V2.create, D5), i4.addTrace(z.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i4.addTrace(z.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError($.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a4 });
      } catch (m) {
        throw i4.setError($.subscribe_pairing_topic_failure), m;
      }
      return i4.addTrace(z.subscribe_pairing_topic_success), D5;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = Mt(import_time3.THIRTY_DAYS);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: n4, resolve: a4, reject: h4 } = _t();
        this.events.once(Lt("pairing_ping", r3), ({ error: c5 }) => {
          c5 ? h4(c5) : a4();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(i4));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: n4, methods: a4 } = s2, h4 = this.core.crypto.keychain.get(i4);
      return Dr({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: h4, relay: r3, expiryTimestamp: n4, methods: a4 });
    }, this.sendRequest = async (s2, i4, r3) => {
      const n4 = formatJsonRpcRequest(i4, r3), a4 = await this.core.crypto.encode(s2, n4), h4 = B2[i4].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a4, h4), n4.id;
    }, this.sendResult = async (s2, i4, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a4 = await this.core.crypto.encode(i4, n4), h4 = await this.core.history.get(i4, s2), c5 = B2[h4.request.method].res;
      await this.core.relayer.publish(i4, a4, c5), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i4, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a4 = await this.core.crypto.encode(i4, n4), h4 = await this.core.history.get(i4, s2), c5 = B2[h4.request.method] ? B2[h4.request.method].res : B2.unregistered_method.res;
      await this.core.relayer.publish(i4, a4, c5), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i4) => Kt(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i4, payload: r3 } = s2, n4 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(V2.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(Lt("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(Lt("pairing_ping", r3), { error: i4.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(V2.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i4) => {
      const { id: r3, method: n4 } = i4;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a4 = U("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(U("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i4) => {
      var r3;
      if (!to(s2)) {
        const { message: a4 } = S("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (!Gr(s2.uri)) {
        const { message: a4 } = S("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError($.malformed_pairing_uri), new Error(a4);
      }
      const n4 = kr(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a4 } = S("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a4 } = S("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time3.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i4.setError($.pairing_expired);
        const { message: a4 } = S("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }, this.isValidPing = async (s2) => {
      if (!to(s2)) {
        const { message: r3 } = S("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidDisconnect = async (s2) => {
      if (!to(s2)) {
        const { message: r3 } = S("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidPairingTopic = async (s2) => {
      if (!b(s2, false)) {
        const { message: i4 } = S("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = S("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (Kt(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = S("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new ni(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v2.message, async (e) => {
      const { topic: t, message: s2, transportType: i4 } = e;
      if (!this.pairings.keys.includes(t) || i4 === M2.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S2.expired, async (e) => {
      const { topic: t } = Vt(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V2.expire, { topic: t }));
    });
  }
};
var ai = class extends h2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events6.EventEmitter(), this.name = Dt2, this.version = mt, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id)) return;
      const n4 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: Mt(import_time3.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P2.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(P2.updated, i4));
    }, this.get = async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4)), this.delete = (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4) return;
          this.records.delete(r3.id), this.events.emit(P2.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false), this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = S("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = S("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(P2.created, (e) => {
      const t = P2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P2.updated, (e) => {
      const t = P2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P2.deleted, (e) => {
      const t = P2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time3.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var hi = class extends x {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events6.EventEmitter(), this.name = bt2, this.version = ft, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i4 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(S2.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(S2.deleted, { target: i4, expiration: r3 });
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Dt(e);
    if (typeof e == "number") return xt(e);
    const { message: t } = S("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = S("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = S("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time3.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(S2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(S2.created, (e) => {
      const t = S2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S2.expired, (e) => {
      const t = S2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S2.deleted, (e) => {
      const t = S2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ci = class extends y2 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = _t2, this.verifyUrlV3 = vt2, this.storagePrefix = x2, this.version = De, this.init = async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time3.toMiliseconds)((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i4) => {
      if (!V() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a4 } = i4, h4 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a4}`;
      try {
        const c5 = (0, import_window_getters2.getDocument)(), l3 = this.startAbortTimer(import_time3.ONE_SECOND * 5), p4 = await new Promise((D5, m) => {
          const u3 = () => {
            window.removeEventListener("message", _4), c5.body.removeChild(g6), m("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u3);
          const g6 = c5.createElement("iframe");
          g6.src = h4, g6.style.display = "none", g6.addEventListener("error", u3, { signal: this.abortController.signal });
          const _4 = (y7) => {
            if (y7.data && typeof y7.data == "string") try {
              const b5 = JSON.parse(y7.data);
              if (b5.type === "verify_attestation") {
                if (decodeJWT(b5.attestation).payload.id !== n4) return;
                clearInterval(l3), c5.body.removeChild(g6), this.abortController.signal.removeEventListener("abort", u3), window.removeEventListener("message", _4), D5(b5.attestation === null ? "" : b5.attestation);
              }
            } catch (b5) {
              this.logger.warn(b5);
            }
          };
          c5.body.appendChild(g6), window.addEventListener("message", _4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p4), p4;
      } catch (c5) {
        this.logger.warn(c5);
      }
      return "";
    }, this.resolve = async (i4) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a4 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a4) return;
        const c5 = await this.isValidJwtAttestation(r3);
        if (c5) {
          if (!c5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return c5;
        }
      }
      if (!n4) return;
      const h4 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(n4, h4);
    }, this.fetchAttestation = async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time3.ONE_SECOND * 5), a4 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a4.status === 200 ? await a4.json() : void 0;
    }, this.getVerifyUrl = (i4) => {
      let r3 = i4 || J;
      return wt.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${J}`), r3 = J), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(import_time3.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.persistPublicKey = async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i4, r3);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i4, n4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }, this.validateAttestation = (i4, r3) => {
      const n4 = Rr(i4, r3.publicKey), a4 = { hasExpired: (0, import_time3.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a4.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e));
  }
};
var li = class extends v {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = It, this.registerDeviceToken = async (s2) => {
      const { clientId: i4, token: r3, notificationType: n4, enableEncrypted: a4 = false } = s2, h4 = `${Tt2}/${this.projectId}/clients`;
      await fetch(h4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: n4, token: r3, always_raw: a4 }) });
    }, this.logger = E(t, this.context);
  }
};
var dn = Object.defineProperty;
var ui = Object.getOwnPropertySymbols;
var pn = Object.prototype.hasOwnProperty;
var gn = Object.prototype.propertyIsEnumerable;
var di = (o4, e, t) => e in o4 ? dn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Z = (o4, e) => {
  for (var t in e || (e = {})) pn.call(e, t) && di(o4, t, e[t]);
  if (ui) for (var t of ui(e)) gn.call(e, t) && di(o4, t, e[t]);
  return o4;
};
var pi = class extends C2 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = Pt2, this.storagePrefix = x2, this.storageVersion = Ct, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Wt()) try {
        const i4 = { eventId: Ht(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge(this.core.relayer.protocol, this.core.relayer.version, se) } } };
        await this.sendEvent([i4]);
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.createEvent = (i4) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a4, trace: h4 } } = i4, c5 = Ht(), l3 = this.core.projectId || "", p4 = Date.now(), D5 = Z({ eventId: c5, timestamp: p4, props: { event: r3, type: n4, properties: { topic: a4, trace: h4 } }, bundleId: l3, domain: this.getAppDomain() }, this.setMethods(c5));
      return this.telemetryEnabled && (this.events.set(c5, D5), this.shouldPersist = true), D5;
    }, this.getEvent = (i4) => {
      const { eventId: r3, topic: n4 } = i4;
      if (r3) return this.events.get(r3);
      const a4 = Array.from(this.events.values()).find((h4) => h4.props.properties.topic === n4);
      if (a4) return Z(Z({}, a4), this.setMethods(a4.eventId));
    }, this.deleteEvent = (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          (0, import_time3.fromMiliseconds)(Date.now()) - (0, import_time3.fromMiliseconds)(i4.timestamp) > St && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) }), this.addTrace = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.setError = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length) return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, Z(Z({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i4 = [];
      for (const [r3, n4] of this.events) n4.props.type && i4.push(n4);
      if (i4.length !== 0) try {
        if ((await this.sendEvent(i4)).ok) for (const r3 of i4) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }, this.getAppDomain = () => Nt().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var yn = Object.defineProperty;
var gi = Object.getOwnPropertySymbols;
var Dn = Object.prototype.hasOwnProperty;
var mn = Object.prototype.propertyIsEnumerable;
var yi = (o4, e, t) => e in o4 ? yn(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Di = (o4, e) => {
  for (var t in e || (e = {})) Dn.call(e, t) && yi(o4, t, e[t]);
  if (gi) for (var t of gi(e)) mn.call(e, t) && yi(o4, t, e[t]);
  return o4;
};
var ne2 = class _ne extends n2 {
  constructor(e) {
    var t;
    super(e), this.protocol = ye2, this.version = De, this.name = ie, this.events = new import_events6.EventEmitter(), this.initialized = false, this.on = (n4, a4) => this.events.on(n4, a4), this.once = (n4, a4) => this.events.once(n4, a4), this.off = (n4, a4) => this.events.off(n4, a4), this.removeListener = (n4, a4) => this.events.removeListener(n4, a4), this.dispatchEnvelope = ({ topic: n4, message: a4, sessionExists: h4 }) => {
      if (!n4 || !a4) return;
      const c5 = { topic: n4, message: a4, publishedAt: Date.now(), transportType: M2.link_mode };
      this.relayer.onLinkMessageEvent(c5, { sessionExists: h4 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || be2, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Ye.logger }), { logger: i4, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a4;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a4 = this.logChunkController) == null || a4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i4, this.name), this.heartbeat = new i(), this.crypto = new Ht2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ai(this, this.logger), this.expirer = new hi(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Di(Di({}, Je2), e == null ? void 0 : e.storageOptions)), this.relayer = new ti({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi(this, this.logger), this.verify = new ci(this, this.logger, this.storage), this.echoClient = new li(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _ne(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(lt, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(fe, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var bn = ne2;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var import_dist31 = __toESM(require_dist());
var import_dist32 = __toESM(require_dist2());
var import_dist33 = __toESM(require_dist3());

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_dist16 = __toESM(require_dist());
var import_dist17 = __toESM(require_dist2());
var import_dist18 = __toESM(require_dist3());
var import_events7 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time4.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 3001 } } };
var U4 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var $2 = "wc";
var Q2 = 1;
var Z2 = "auth";
var B3 = "authClient";
var F2 = `${$2}@${1}:${Z2}:`;
var x3 = `${F2}:PUB_KEY`;
function z2(r3) {
  return r3 == null ? void 0 : r3.split(":");
}
function Ze2(r3) {
  const t = r3 && z2(r3);
  if (t) return t[3];
}
function We3(r3) {
  const t = r3 && z2(r3);
  if (t) return t[2] + ":" + t[3];
}
function W2(r3) {
  const t = r3 && z2(r3);
  if (t) return t.pop();
}
async function et3(r3, t, e, i4, n4) {
  switch (e.t) {
    case "eip191":
      return tt2(r3, t, e.s);
    case "eip1271":
      return await rt2(r3, t, e.s, i4, n4);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt2(r3, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r3.toLowerCase();
}
async function rt2(r3, t, e, i4, n4) {
  try {
    const s2 = "0x1626ba7e", o4 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", a4 = e.substring(2), c5 = hashMessage(t).substring(2), h4 = s2 + c5 + o4 + u3 + a4, f5 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i4}&projectId=${n4}`, { method: "POST", body: JSON.stringify({ id: it3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r3, data: h4 }, "latest"] }) }), { result: p4 } = await f5.json();
    return p4 ? p4.slice(0, s2.length).toLowerCase() === s2.toLowerCase() : false;
  } catch (s2) {
    return console.error("isValidEip1271Signature: ", s2), false;
  }
}
function it3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee3(r3) {
  return r3.getAll().filter((t) => "requester" in t);
}
function te(r3, t) {
  return ee3(r3).find((e) => e.id === t);
}
function nt2(r3) {
  const t = Gr(r3.aud), e = new RegExp(`${r3.domain}`).test(r3.aud), i4 = !!r3.nonce, n4 = r3.type ? r3.type === "eip4361" : true, s2 = r3.expiry;
  if (s2 && !po(s2, U4)) {
    const { message: o4 } = S("MISSING_OR_INVALID", `request() expiry: ${s2}. Expiry must be a number (in seconds) between ${U4.min} and ${U4.max}`);
    throw new Error(o4);
  }
  return !!(t && e && i4 && n4);
}
function st3(r3, t) {
  return !!te(t, r3.id);
}
function ot2(r3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r3) : new Uint8Array(r3);
}
function ut3(r3, t) {
  if (r3.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i4 = 0; i4 < e.length; i4++) e[i4] = 255;
  for (var n4 = 0; n4 < r3.length; n4++) {
    var s2 = r3.charAt(n4), o4 = s2.charCodeAt(0);
    if (e[o4] !== 255) throw new TypeError(s2 + " is ambiguous");
    e[o4] = n4;
  }
  var u3 = r3.length, a4 = r3.charAt(0), c5 = Math.log(u3) / Math.log(256), h4 = Math.log(256) / Math.log(u3);
  function f5(D5) {
    if (D5 instanceof Uint8Array || (ArrayBuffer.isView(D5) ? D5 = new Uint8Array(D5.buffer, D5.byteOffset, D5.byteLength) : Array.isArray(D5) && (D5 = Uint8Array.from(D5))), !(D5 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (D5.length === 0) return "";
    for (var l3 = 0, m = 0, E3 = 0, y7 = D5.length; E3 !== y7 && D5[E3] === 0; ) E3++, l3++;
    for (var w4 = (y7 - E3) * h4 + 1 >>> 0, g6 = new Uint8Array(w4); E3 !== y7; ) {
      for (var C6 = D5[E3], _4 = 0, b5 = w4 - 1; (C6 !== 0 || _4 < m) && b5 !== -1; b5--, _4++) C6 += 256 * g6[b5] >>> 0, g6[b5] = C6 % u3 >>> 0, C6 = C6 / u3 >>> 0;
      if (C6 !== 0) throw new Error("Non-zero carry");
      m = _4, E3++;
    }
    for (var v7 = w4 - m; v7 !== w4 && g6[v7] === 0; ) v7++;
    for (var q6 = a4.repeat(l3); v7 < w4; ++v7) q6 += r3.charAt(g6[v7]);
    return q6;
  }
  function p4(D5) {
    if (typeof D5 != "string") throw new TypeError("Expected String");
    if (D5.length === 0) return new Uint8Array();
    var l3 = 0;
    if (D5[l3] !== " ") {
      for (var m = 0, E3 = 0; D5[l3] === a4; ) m++, l3++;
      for (var y7 = (D5.length - l3) * c5 + 1 >>> 0, w4 = new Uint8Array(y7); D5[l3]; ) {
        var g6 = e[D5.charCodeAt(l3)];
        if (g6 === 255) return;
        for (var C6 = 0, _4 = y7 - 1; (g6 !== 0 || C6 < E3) && _4 !== -1; _4--, C6++) g6 += u3 * w4[_4] >>> 0, w4[_4] = g6 % 256 >>> 0, g6 = g6 / 256 >>> 0;
        if (g6 !== 0) throw new Error("Non-zero carry");
        E3 = C6, l3++;
      }
      if (D5[l3] !== " ") {
        for (var b5 = y7 - E3; b5 !== y7 && w4[b5] === 0; ) b5++;
        for (var v7 = new Uint8Array(m + (y7 - b5)), q6 = m; b5 !== y7; ) v7[q6++] = w4[b5++];
        return v7;
      }
    }
  }
  function A5(D5) {
    var l3 = p4(D5);
    if (l3) return l3;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f5, decodeUnsafe: p4, decode: A5 };
}
var at3 = ut3;
var Dt3 = at3;
var re2 = (r3) => {
  if (r3 instanceof Uint8Array && r3.constructor.name === "Uint8Array") return r3;
  if (r3 instanceof ArrayBuffer) return new Uint8Array(r3);
  if (ArrayBuffer.isView(r3)) return new Uint8Array(r3.buffer, r3.byteOffset, r3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct2 = (r3) => new TextEncoder().encode(r3);
var ht2 = (r3) => new TextDecoder().decode(r3);
var lt2 = class {
  constructor(t, e, i4) {
    this.name = t, this.prefix = e, this.baseEncode = i4;
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt2 = class {
  constructor(t, e, i4) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i4;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie2(this, t);
  }
};
var pt2 = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie2(this, t);
  }
  decode(t) {
    const e = t[0], i4 = this.decoders[e];
    if (i4) return i4.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie2 = (r3, t) => new pt2({ ...r3.decoders || { [r3.prefix]: r3 }, ...t.decoders || { [t.prefix]: t } });
var ft2 = class {
  constructor(t, e, i4, n4) {
    this.name = t, this.prefix = e, this.baseEncode = i4, this.baseDecode = n4, this.encoder = new lt2(t, e, i4), this.decoder = new dt2(t, e, n4);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O2 = ({ name: r3, prefix: t, encode: e, decode: i4 }) => new ft2(r3, t, e, i4);
var T = ({ prefix: r3, name: t, alphabet: e }) => {
  const { encode: i4, decode: n4 } = Dt3(e, t);
  return O2({ prefix: r3, name: t, encode: i4, decode: (s2) => re2(n4(s2)) });
};
var gt3 = (r3, t, e, i4) => {
  const n4 = {};
  for (let h4 = 0; h4 < t.length; ++h4) n4[t[h4]] = h4;
  let s2 = r3.length;
  for (; r3[s2 - 1] === "="; ) --s2;
  const o4 = new Uint8Array(s2 * e / 8 | 0);
  let u3 = 0, a4 = 0, c5 = 0;
  for (let h4 = 0; h4 < s2; ++h4) {
    const f5 = n4[r3[h4]];
    if (f5 === void 0) throw new SyntaxError(`Non-${i4} character`);
    a4 = a4 << e | f5, u3 += e, u3 >= 8 && (u3 -= 8, o4[c5++] = 255 & a4 >> u3);
  }
  if (u3 >= e || 255 & a4 << 8 - u3) throw new SyntaxError("Unexpected end of data");
  return o4;
};
var Et2 = (r3, t, e) => {
  const i4 = t[t.length - 1] === "=", n4 = (1 << e) - 1;
  let s2 = "", o4 = 0, u3 = 0;
  for (let a4 = 0; a4 < r3.length; ++a4) for (u3 = u3 << 8 | r3[a4], o4 += 8; o4 > e; ) o4 -= e, s2 += t[n4 & u3 >> o4];
  if (o4 && (s2 += t[n4 & u3 << e - o4]), i4) for (; s2.length * e & 7; ) s2 += "=";
  return s2;
};
var d2 = ({ name: r3, prefix: t, bitsPerChar: e, alphabet: i4 }) => O2({ prefix: t, name: r3, encode(n4) {
  return Et2(n4, i4, e);
}, decode(n4) {
  return gt3(n4, i4, e, r3);
} });
var bt3 = O2({ prefix: "\0", name: "identity", encode: (r3) => ht2(r3), decode: (r3) => ct2(r3) });
var yt2 = Object.freeze({ __proto__: null, identity: bt3 });
var wt2 = d2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct2 = Object.freeze({ __proto__: null, base2: wt2 });
var mt2 = d2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt3 = Object.freeze({ __proto__: null, base8: mt2 });
var At2 = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t3 = Object.freeze({ __proto__: null, base10: At2 });
var xt3 = d2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt2 = d2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft2 = Object.freeze({ __proto__: null, base16: xt3, base16upper: Rt2 });
var Tt3 = d2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It2 = d2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt2 = d2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut2 = d2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot3 = d2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St2 = d2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt3 = d2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt3 = d2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t3 = d2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt2 = Object.freeze({ __proto__: null, base32: Tt3, base32upper: It2, base32pad: qt2, base32padupper: Ut2, base32hex: Ot3, base32hexupper: St2, base32hexpad: Pt3, base32hexpadupper: Nt3, base32z: $t3 });
var zt2 = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt2 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt3 = Object.freeze({ __proto__: null, base36: zt2, base36upper: jt2 });
var Lt3 = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt3 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt3 = Object.freeze({ __proto__: null, base58btc: Lt3, base58flickr: Kt3 });
var kt3 = d2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt2 = d2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt2 = d2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt2 = d2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht3 = Object.freeze({ __proto__: null, base64: kt3, base64pad: Jt2, base64url: Xt2, base64urlpad: Gt2 });
var ne3 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Yt2 = ne3.reduce((r3, t, e) => (r3[e] = t, r3), []);
var Qt2 = ne3.reduce((r3, t, e) => (r3[t.codePointAt(0)] = e, r3), []);
function Zt2(r3) {
  return r3.reduce((t, e) => (t += Yt2[e], t), "");
}
function Wt3(r3) {
  const t = [];
  for (const e of r3) {
    const i4 = Qt2[e.codePointAt(0)];
    if (i4 === void 0) throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i4);
  }
  return new Uint8Array(t);
}
var er2 = O2({ prefix: "🚀", name: "base256emoji", encode: Zt2, decode: Wt3 });
var tr2 = Object.freeze({ __proto__: null, base256emoji: er2 });
var rr2 = oe2;
var se2 = 128;
var ir2 = 127;
var nr2 = ~ir2;
var sr2 = Math.pow(2, 31);
function oe2(r3, t, e) {
  t = t || [], e = e || 0;
  for (var i4 = e; r3 >= sr2; ) t[e++] = r3 & 255 | se2, r3 /= 128;
  for (; r3 & nr2; ) t[e++] = r3 & 255 | se2, r3 >>>= 7;
  return t[e] = r3 | 0, oe2.bytes = e - i4 + 1, t;
}
var or2 = j;
var ur2 = 128;
var ue = 127;
function j(r3, i4) {
  var e = 0, i4 = i4 || 0, n4 = 0, s2 = i4, o4, u3 = r3.length;
  do {
    if (s2 >= u3) throw j.bytes = 0, new RangeError("Could not decode varint");
    o4 = r3[s2++], e += n4 < 28 ? (o4 & ue) << n4 : (o4 & ue) * Math.pow(2, n4), n4 += 7;
  } while (o4 >= ur2);
  return j.bytes = s2 - i4, e;
}
var ar2 = Math.pow(2, 7);
var Dr3 = Math.pow(2, 14);
var cr2 = Math.pow(2, 21);
var hr3 = Math.pow(2, 28);
var lr2 = Math.pow(2, 35);
var dr3 = Math.pow(2, 42);
var pr3 = Math.pow(2, 49);
var fr3 = Math.pow(2, 56);
var gr3 = Math.pow(2, 63);
var Er3 = function(r3) {
  return r3 < ar2 ? 1 : r3 < Dr3 ? 2 : r3 < cr2 ? 3 : r3 < hr3 ? 4 : r3 < lr2 ? 5 : r3 < dr3 ? 6 : r3 < pr3 ? 7 : r3 < fr3 ? 8 : r3 < gr3 ? 9 : 10;
};
var br3 = { encode: rr2, decode: or2, encodingLength: Er3 };
var ae3 = br3;
var De2 = (r3, t, e = 0) => (ae3.encode(r3, t, e), t);
var ce2 = (r3) => ae3.encodingLength(r3);
var M3 = (r3, t) => {
  const e = t.byteLength, i4 = ce2(r3), n4 = i4 + ce2(e), s2 = new Uint8Array(n4 + e);
  return De2(r3, s2, 0), De2(e, s2, i4), s2.set(t, n4), new yr3(r3, e, t, s2);
};
var yr3 = class {
  constructor(t, e, i4, n4) {
    this.code = t, this.size = e, this.digest = i4, this.bytes = n4;
  }
};
var he2 = ({ name: r3, code: t, encode: e }) => new wr3(r3, t, e);
var wr3 = class {
  constructor(t, e, i4) {
    this.name = t, this.code = e, this.encode = i4;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M3(this.code, e) : e.then((i4) => M3(this.code, i4));
    } else throw Error("Unknown type, must be binary type");
  }
};
var le2 = (r3) => async (t) => new Uint8Array(await crypto.subtle.digest(r3, t));
var Cr3 = he2({ name: "sha2-256", code: 18, encode: le2("SHA-256") });
var mr3 = he2({ name: "sha2-512", code: 19, encode: le2("SHA-512") });
var vr3 = Object.freeze({ __proto__: null, sha256: Cr3, sha512: mr3 });
var de = 0;
var Ar3 = "identity";
var pe = re2;
var _r3 = (r3) => M3(de, pe(r3));
var xr2 = { code: de, name: Ar3, encode: pe, digest: _r3 };
var Rr3 = Object.freeze({ __proto__: null, identity: xr2 });
new TextEncoder(), new TextDecoder();
var fe2 = { ...yt2, ...Ct2, ...vt3, ..._t3, ...Ft2, ...Bt2, ...Mt3, ...Vt3, ...Ht3, ...tr2 };
({ ...vr3, ...Rr3 });
function ge2(r3, t, e, i4) {
  return { name: r3, prefix: t, encoder: { name: r3, prefix: t, encode: e }, decoder: { decode: i4 } };
}
var Ee3 = ge2("utf8", "u", (r3) => "u" + new TextDecoder("utf8").decode(r3), (r3) => new TextEncoder().encode(r3.substring(1)));
var L2 = ge2("ascii", "a", (r3) => {
  let t = "a";
  for (let e = 0; e < r3.length; e++) t += String.fromCharCode(r3[e]);
  return t;
}, (r3) => {
  r3 = r3.substring(1);
  const t = ot2(r3.length);
  for (let e = 0; e < r3.length; e++) t[e] = r3.charCodeAt(e);
  return t;
});
var be3 = { utf8: Ee3, "utf-8": Ee3, hex: fe2.base16, latin1: L2, ascii: L2, binary: L2, ...fe2 };
function Fr2(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3, "utf8") : e.decoder.decode(`${e.prefix}${r3}`);
}
function Tr3(r3, t = "utf8") {
  const e = be3[t];
  if (!e) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r3.buffer, r3.byteOffset, r3.byteLength).toString("utf8") : e.encoder.encode(r3).substring(1);
}
var ye3 = "base16";
var we3 = "utf8";
function K2(r3) {
  const t = (0, import_sha2562.hash)(Fr2(r3, we3));
  return Tr3(t, ye3);
}
var Or3 = Object.defineProperty;
var Sr3 = Object.defineProperties;
var Pr3 = Object.getOwnPropertyDescriptors;
var Ce3 = Object.getOwnPropertySymbols;
var Nr3 = Object.prototype.hasOwnProperty;
var $r3 = Object.prototype.propertyIsEnumerable;
var me2 = (r3, t, e) => t in r3 ? Or3(r3, t, { enumerable: true, configurable: true, writable: true, value: e }) : r3[t] = e;
var I3 = (r3, t) => {
  for (var e in t || (t = {})) Nr3.call(t, e) && me2(r3, e, t[e]);
  if (Ce3) for (var e of Ce3(t)) $r3.call(t, e) && me2(r3, e, t[e]);
  return r3;
};
var V3 = (r3, t) => Sr3(r3, Pr3(t));
var Br2 = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e, i4) => {
      if (this.isInitialized(), !nt2(e)) throw new Error("Invalid request");
      if (i4 != null && i4.topic) return await this.requestOnKnownPairing(i4.topic, e);
      const { chainId: n4, statement: s2, aud: o4, domain: u3, nonce: a4, type: c5, exp: h4, nbf: f5 } = e, { topic: p4, uri: A5 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p4, uri: A5 } });
      const D5 = await this.client.core.crypto.generateKeyPair(), l3 = hr(D5);
      await this.client.authKeys.set(x3, { responseTopic: l3, publicKey: D5 }), await this.client.pairingTopics.set(l3, { topic: l3, pairingTopic: p4 }), await this.client.core.relayer.subscribe(l3), this.client.logger.info(`sending request to new pairing topic: ${p4}`);
      const m = await this.sendRequest(p4, "wc_authRequest", { payloadParams: { type: c5 ?? "eip4361", chainId: n4, statement: s2, aud: o4, domain: u3, version: "1", nonce: a4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: h4, nbf: f5 }, requester: { publicKey: D5, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p4}`), { uri: A5, id: m };
    }, this.respond = async (e, i4) => {
      if (this.isInitialized(), !st3(e, this.client.requests)) throw new Error("Invalid response");
      const n4 = te(this.client.requests, e.id);
      if (!n4) throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s2 = n4.requester.publicKey, o4 = await this.client.core.crypto.generateKeyPair(), u3 = hr(s2), a4 = { type: D, receiverPublicKey: s2, senderPublicKey: o4 };
      if ("error" in e) {
        await this.sendError(n4.id, u3, e, a4);
        return;
      }
      const c5 = { h: { t: "eip4361" }, p: V3(I3({}, n4.cacaoPayload), { iss: i4 }), s: e.signature };
      await this.sendResult(n4.id, u3, c5, a4), await this.client.core.pairing.activate({ topic: n4.pairingTopic }), await this.client.requests.update(n4.id, I3({}, c5));
    }, this.getPendingRequests = () => ee3(this.client.requests), this.formatMessage = (e, i4) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n4 = `${e.domain} wants you to sign in with your Ethereum account:`, s2 = W2(i4), o4 = e.statement, u3 = `URI: ${e.aud}`, a4 = `Version: ${e.version}`, c5 = `Chain ID: ${Ze2(i4)}`, h4 = `Nonce: ${e.nonce}`, f5 = `Issued At: ${e.iat}`, p4 = e.exp ? `Expiry: ${e.exp}` : void 0, A5 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D5) => `- ${D5}`).join(`
`)}` : void 0;
      return [n4, s2, "", o4, "", u3, a4, c5, h4, f5, p4, A5].filter((D5) => D5 != null).join(`
`);
    }, this.setExpiry = async (e, i4) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i4 }), this.client.core.expirer.set(e, i4);
    }, this.sendRequest = async (e, i4, n4, s2, o4) => {
      const u3 = formatJsonRpcRequest(i4, n4), a4 = await this.client.core.crypto.encode(e, u3, s2), c5 = R[i4].req;
      if (o4 && (c5.ttl = o4), this.client.core.history.set(e, u3), V()) {
        const h4 = K2(JSON.stringify(u3));
        this.client.core.verify.register({ attestationId: h4 });
      }
      return await this.client.core.relayer.publish(e, a4, V3(I3({}, c5), { internal: { throwOnFailedPublish: true } })), u3.id;
    }, this.sendResult = async (e, i4, n4, s2) => {
      const o4 = formatJsonRpcResult(e, n4), u3 = await this.client.core.crypto.encode(i4, o4, s2), a4 = await this.client.core.history.get(i4, e), c5 = R[a4.request.method].res;
      return await this.client.core.relayer.publish(i4, u3, V3(I3({}, c5), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o4), o4.id;
    }, this.sendError = async (e, i4, n4, s2) => {
      const o4 = formatJsonRpcError(e, n4.error), u3 = await this.client.core.crypto.encode(i4, o4, s2), a4 = await this.client.core.history.get(i4, e), c5 = R[a4.request.method].res;
      return await this.client.core.relayer.publish(i4, u3, c5), await this.client.core.history.resolve(o4), o4.id;
    }, this.requestOnKnownPairing = async (e, i4) => {
      const n4 = this.client.core.pairing.pairings.getAll({ active: true }).find((A5) => A5.topic === e);
      if (!n4) throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s2 } = this.client.authKeys.get(x3), { chainId: o4, statement: u3, aud: a4, domain: c5, nonce: h4, type: f5 } = i4, p4 = await this.sendRequest(n4.topic, "wc_authRequest", { payloadParams: { type: f5 ?? "eip4361", chainId: o4, statement: u3, aud: a4, domain: c5, version: "1", nonce: h4, iat: (/* @__PURE__ */ new Date()).toISOString() }, requester: { publicKey: s2, metadata: this.client.metadata } }, {}, i4.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n4.topic}`), { id: p4 };
    }, this.onPairingCreated = (e) => {
      const i4 = this.getPendingRequests();
      if (i4) {
        const n4 = Object.values(i4).find((s2) => s2.pairingTopic === e.topic);
        n4 && this.handleAuthRequest(n4);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i4, payload: n4 } = e, s2 = n4.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthRequest(i4, n4);
        default:
          return this.client.logger.info(`Unsupported request method ${s2}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i4, payload: n4 } = e, s2 = (await this.client.core.history.get(i4, n4.id)).request.method;
      switch (s2) {
        case "wc_authRequest":
          return this.onAuthResponse(i4, n4);
        default:
          return this.client.logger.info(`Unsupported response method ${s2}`);
      }
    }, this.onAuthRequest = async (e, i4) => {
      const { requester: n4, payloadParams: s2 } = i4.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i4 });
      const o4 = K2(JSON.stringify(i4)), u3 = await this.getVerifyContext(o4, this.client.metadata), a4 = { requester: n4, pairingTopic: e, id: i4.id, cacaoPayload: s2, verifyContext: u3 };
      await this.client.requests.set(i4.id, a4), this.handleAuthRequest(a4);
    }, this.handleAuthRequest = async (e) => {
      const { id: i4, pairingTopic: n4, requester: s2, cacaoPayload: o4, verifyContext: u3 } = e;
      try {
        this.client.emit("auth_request", { id: i4, topic: n4, params: { requester: s2, cacaoPayload: o4 }, verifyContext: u3 });
      } catch (a4) {
        await this.sendError(e.id, e.pairingTopic, a4), this.client.logger.error(a4);
      }
    }, this.onAuthResponse = async (e, i4) => {
      const { id: n4 } = i4;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i4 }), isJsonRpcResult(i4)) {
        const { pairingTopic: s2 } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s2 });
        const { s: o4, p: u3 } = i4.result;
        await this.client.requests.set(n4, I3({ id: n4, pairingTopic: s2 }, i4.result));
        const a4 = this.formatMessage(u3, u3.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a4)), this.client.logger.debug("payload.iss:", u3.iss), this.client.logger.debug("signature:", o4);
        const c5 = W2(u3.iss), h4 = We3(u3.iss);
        if (!c5) throw new Error("Could not derive address from `payload.iss`");
        if (!h4) throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c5), await et3(c5, a4, o4, h4, this.client.projectId) ? this.client.emit("auth_response", { id: n4, topic: e, params: i4 }) : this.client.emit("auth_response", { id: n4, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else isJsonRpcError(i4) && this.client.emit("auth_response", { id: n4, topic: e, params: i4 });
    }, this.getVerifyContext = async (e, i4) => {
      const n4 = { verified: { verifyUrl: i4.verifyUrl || "", validation: "UNKNOWN", origin: i4.url || "" } };
      try {
        const s2 = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i4.verifyUrl });
        s2 && (n4.verified.origin = s2.origin, n4.verified.isScam = s2.isScam, n4.verified.validation = origin === new URL(i4.url).origin ? "VALID" : "INVALID");
      } catch (s2) {
        this.client.logger.error(s2);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n4)}`), n4;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = S("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v2.message, async (t) => {
      const { topic: e, message: i4 } = t, { responseTopic: n4, publicKey: s2 } = this.client.authKeys.keys.includes(x3) ? this.client.authKeys.get(x3) : { responseTopic: void 0, publicKey: void 0 };
      if (n4 && e !== n4) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o4 = await this.client.core.crypto.decode(e, i4, { receiverPublicKey: s2 });
      isJsonRpcRequest(o4) ? (this.client.core.history.set(e, o4), this.onRelayEventRequest({ topic: e, payload: o4 })) : isJsonRpcResponse(o4) && (await this.client.core.history.resolve(o4), this.onRelayEventResponse({ topic: e, payload: o4 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V2.create, (t) => this.onPairingCreated(t));
  }
};
var S3 = class _S extends H {
  constructor(t) {
    super(t), this.protocol = $2, this.version = Q2, this.name = B3, this.events = new import_events7.EventEmitter(), this.emit = (i4, n4) => this.events.emit(i4, n4), this.on = (i4, n4) => this.events.on(i4, n4), this.once = (i4, n4) => this.events.once(i4, n4), this.off = (i4, n4) => this.events.off(i4, n4), this.removeListener = (i4, n4) => this.events.removeListener(i4, n4), this.request = async (i4, n4) => {
      try {
        return await this.engine.request(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (i4, n4) => {
      try {
        return await this.engine.respond(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }, this.formatMessage = (i4, n4) => {
      try {
        return this.engine.formatMessage(i4, n4);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_pino.default)(k({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B3, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new bn(t), this.logger = E(e, this.name), this.authKeys = new ni(this.core, this.logger, "authKeys", F2, () => x3), this.pairingTopics = new ni(this.core, this.logger, "pairingTopics", F2), this.requests = new ni(this.core, this.logger, "requests", F2, (i4) => i4.id), this.engine = new Br2(this);
  }
  static async init(t) {
    const e = new _S(t);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr2 = S3;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_dist28 = __toESM(require_dist());
var import_dist29 = __toESM(require_dist2());
var import_dist30 = __toESM(require_dist3());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_dist25 = __toESM(require_dist());
var import_dist26 = __toESM(require_dist2());
var import_dist27 = __toESM(require_dist3());
var import_events10 = __toESM(require_events());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
var import_dist19 = __toESM(require_dist());
var import_dist20 = __toESM(require_dist2());
var import_dist21 = __toESM(require_dist3());
init_esm();
var import_events9 = __toESM(require_events());
var n3 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h3 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g3 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u2 = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p2 = class {
  constructor(s2, t, e, f5) {
    this.core = s2, this.logger = t, this.name = e;
  }
};
var d3 = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x4 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y4 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.store = e;
  }
};
var v3 = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C3 = class {
  constructor(s2, t, e) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e;
  }
};
var S4 = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M4 = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_time6 = __toESM(require_cjs());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_dist22 = __toESM(require_dist());
var import_dist23 = __toESM(require_dist2());
var import_dist24 = __toESM(require_dist3());
var import_time5 = __toESM(require_cjs());
var import_window_getters3 = __toESM(require_cjs2());
var import_window_metadata2 = __toESM(require_cjs3());
var q3 = __toESM(require_query_string());
init_lib();
init_lib2();
var import_chacha20poly13052 = __toESM(require_chacha20poly1305());
var import_hkdf2 = __toESM(require_hkdf());
var import_random3 = __toESM(require_random());
var import_sha2563 = __toESM(require_sha256());
var _e3 = __toESM(require_x25519());
var import_elliptic2 = __toESM(require_elliptic2());
var H2 = ":";
function re3(e) {
  const [n4, t] = e.split(H2);
  return { namespace: n4, reference: t };
}
function W3(e, n4) {
  return e.includes(":") ? [e] : n4.chains || [];
}
var gt4 = Object.defineProperty;
var Ke3 = Object.getOwnPropertySymbols;
var vt4 = Object.prototype.hasOwnProperty;
var bt4 = Object.prototype.propertyIsEnumerable;
var Le3 = (e, n4, t) => n4 in e ? gt4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var Fe2 = (e, n4) => {
  for (var t in n4 || (n4 = {})) vt4.call(n4, t) && Le3(e, t, n4[t]);
  if (Ke3) for (var t of Ke3(n4)) bt4.call(n4, t) && Le3(e, t, n4[t]);
  return e;
};
var qe2 = "ReactNative";
var y5 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var He2 = "js";
function ce3() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function _2() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === qe2;
}
function V4() {
  return !ce3() && !!(0, import_window_getters3.getNavigator)() && !!(0, import_window_getters3.getDocument)();
}
function P3() {
  return _2() ? y5.reactNative : ce3() ? y5.node : V4() ? y5.browser : y5.unknown;
}
function Ot4() {
  var e;
  try {
    return _2() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0;
  } catch {
    return;
  }
}
function We4(e, n4) {
  let t = q3.parse(e);
  return t = Fe2(Fe2({}, t), n4), e = q3.stringify(t), e;
}
function Nt4() {
  return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function Je4() {
  if (P3() === y5.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: r3 } = global.Platform;
    return [t, r3].join("-");
  }
  const e = detect();
  if (e === null) return "unknown";
  const n4 = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [n4, e.name, e.version].join("-") : [n4, e.version].join("-");
}
function ze2() {
  var e;
  const n4 = P3();
  return n4 === y5.browser ? [n4, ((e = (0, import_window_getters3.getLocation)()) == null ? void 0 : e.host) || "unknown"].join(":") : n4;
}
function Ge2(e, n4, t) {
  const r3 = Je4(), o4 = ze2();
  return [[e, n4].join("-"), [He2, t].join("-"), r3, o4].join("/");
}
function $t4({ protocol: e, version: n4, relayUrl: t, sdkVersion: r3, auth: o4, projectId: s2, useOnCloseEvent: i4, bundleId: u3 }) {
  const l3 = t.split("?"), c5 = Ge2(e, n4, r3), d4 = { auth: o4, ua: c5, projectId: s2, useOnCloseEvent: i4 || void 0, origin: u3 || void 0 }, a4 = We4(l3[1] || "", d4);
  return l3[0] + "?" + a4;
}
function $3(e, n4) {
  return e.filter((t) => n4.includes(t)).length === e.length;
}
function Tt4(e) {
  return Object.fromEntries(e.entries());
}
function Pt4(e) {
  return new Map(Object.entries(e));
}
function _t4(e = import_time5.FIVE_MINUTES, n4) {
  const t = (0, import_time5.toMiliseconds)(e || import_time5.FIVE_MINUTES);
  let r3, o4, s2;
  return { resolve: (i4) => {
    s2 && r3 && (clearTimeout(s2), r3(i4));
  }, reject: (i4) => {
    s2 && o4 && (clearTimeout(s2), o4(i4));
  }, done: () => new Promise((i4, u3) => {
    s2 = setTimeout(() => {
      u3(new Error(n4));
    }, t), r3 = i4, o4 = u3;
  }) };
}
function kt4(e, n4, t) {
  return new Promise(async (r3, o4) => {
    const s2 = setTimeout(() => o4(new Error(t)), n4);
    try {
      const i4 = await e;
      r3(i4);
    } catch (i4) {
      o4(i4);
    }
    clearTimeout(s2);
  });
}
function ae4(e, n4) {
  if (typeof n4 == "string" && n4.startsWith(`${e}:`)) return n4;
  if (e.toLowerCase() === "topic") {
    if (typeof n4 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n4}`;
  } else if (e.toLowerCase() === "id") {
    if (typeof n4 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n4}`;
  }
  throw new Error(`Unknown expirer target type: ${e}`);
}
function Dt4(e) {
  return ae4("topic", e);
}
function xt4(e) {
  return ae4("id", e);
}
function Vt4(e) {
  const [n4, t] = e.split(":"), r3 = { id: void 0, topic: void 0 };
  if (n4 === "topic" && typeof t == "string") r3.topic = t;
  else if (n4 === "id" && Number.isInteger(Number(t))) r3.id = Number(t);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${n4}:${t}`);
  return r3;
}
function Mt4(e, n4) {
  return (0, import_time5.fromMiliseconds)((n4 || Date.now()) + (0, import_time5.toMiliseconds)(e));
}
function Kt4(e) {
  return Date.now() >= (0, import_time5.toMiliseconds)(e);
}
function Lt4(e, n4) {
  return `${e}${n4 ? `:${n4}` : ""}`;
}
function N2(e = [], n4 = []) {
  return [.../* @__PURE__ */ new Set([...e, ...n4])];
}
async function Ft3({ id: e, topic: n4, wcDeepLink: t }) {
  var r3;
  try {
    if (!t) return;
    const o4 = typeof t == "string" ? JSON.parse(t) : t, s2 = o4 == null ? void 0 : o4.href;
    if (typeof s2 != "string") return;
    const i4 = Xe3(s2, e, n4), u3 = P3();
    if (u3 === y5.browser) {
      if (!((r3 = (0, import_window_getters3.getDocument)()) != null && r3.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      i4.startsWith("https://") || i4.startsWith("http://") ? window.open(i4, "_blank", "noreferrer noopener") : window.open(i4, en2() ? "_blank" : "_self", "noreferrer noopener");
    } else u3 === y5.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i4);
  } catch (o4) {
    console.error(o4);
  }
}
function Xe3(e, n4, t) {
  const r3 = `requestId=${n4}&sessionTopic=${t}`;
  e.endsWith("/") && (e = e.slice(0, -1));
  let o4 = `${e}`;
  if (e.startsWith("https://t.me")) {
    const s2 = e.includes("?") ? "&startapp=" : "?startapp=";
    o4 = `${o4}${s2}${nn2(r3, true)}`;
  } else o4 = `${o4}/wc?${r3}`;
  return o4;
}
async function qt3(e, n4) {
  let t = "";
  try {
    if (V4() && (t = localStorage.getItem(n4), t)) return t;
    t = await e.getItem(n4);
  } catch (r3) {
    console.error(r3);
  }
  return t;
}
function Bt3(e, n4) {
  if (!e.includes(n4)) return null;
  const t = e.split(/([&,?,=])/), r3 = t.indexOf(n4);
  return t[r3 + 2];
}
function Ht4() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e) => {
    const n4 = Math.random() * 16 | 0;
    return (e === "x" ? n4 : n4 & 3 | 8).toString(16);
  });
}
function Wt4() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function en2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function nn2(e, n4 = false) {
  const t = Buffer.from(e).toString("base64");
  return n4 ? t.replace(/[=]/g, "") : t;
}
function le3(e) {
  return Buffer.from(e, "base64").toString("utf-8");
}
var Jt3 = "https://rpc.walletconnect.org/v1";
async function tn2(e, n4, t, r3, o4, s2) {
  switch (t.t) {
    case "eip191":
      return rn2(e, n4, t.s);
    case "eip1271":
      return await on2(e, n4, t.s, r3, o4, s2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
  }
}
function rn2(e, n4, t) {
  return recoverAddress(hashMessage(n4), t).toLowerCase() === e.toLowerCase();
}
async function on2(e, n4, t, r3, o4, s2) {
  const i4 = re3(r3);
  if (!i4.namespace || !i4.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r3}`);
  try {
    const u3 = "0x1626ba7e", l3 = "0000000000000000000000000000000000000000000000000000000000000040", c5 = "0000000000000000000000000000000000000000000000000000000000000041", d4 = t.substring(2), a4 = hashMessage(n4).substring(2), f5 = u3 + a4 + l3 + c5 + d4, h4 = await fetch(`${s2 || Jt3}/?chainId=${r3}&projectId=${o4}`, { method: "POST", body: JSON.stringify({ id: zt3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e, data: f5 }, "latest"] }) }), { result: p4 } = await h4.json();
    return p4 ? p4.slice(0, u3.length).toLowerCase() === u3.toLowerCase() : false;
  } catch (u3) {
    return console.error("isValidEip1271Signature: ", u3), false;
  }
}
function zt3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Gt3 = Object.defineProperty;
var Yt3 = Object.defineProperties;
var Qt3 = Object.getOwnPropertyDescriptors;
var sn2 = Object.getOwnPropertySymbols;
var Zt3 = Object.prototype.hasOwnProperty;
var Xt3 = Object.prototype.propertyIsEnumerable;
var cn2 = (e, n4, t) => n4 in e ? Gt3(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var de2 = (e, n4) => {
  for (var t in n4 || (n4 = {})) Zt3.call(n4, t) && cn2(e, t, n4[t]);
  if (sn2) for (var t of sn2(n4)) Xt3.call(n4, t) && cn2(e, t, n4[t]);
  return e;
};
var an2 = (e, n4) => Yt3(e, Qt3(n4));
var er3 = "did:pkh:";
var z3 = (e) => e == null ? void 0 : e.split(":");
var un2 = (e) => {
  const n4 = e && z3(e);
  if (n4) return e.includes(er3) ? n4[3] : n4[1];
};
var ln2 = (e) => {
  const n4 = e && z3(e);
  if (n4) return n4[2] + ":" + n4[3];
};
var fe3 = (e) => {
  const n4 = e && z3(e);
  if (n4) return n4.pop();
};
async function nr3(e) {
  const { cacao: n4, projectId: t } = e, { s: r3, p: o4 } = n4, s2 = dn2(o4, o4.iss), i4 = fe3(o4.iss);
  return await tn2(i4, s2, r3, ln2(o4.iss), t);
}
var dn2 = (e, n4) => {
  const t = `${e.domain} wants you to sign in with your Ethereum account:`, r3 = fe3(n4);
  if (!e.aud && !e.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o4 = e.statement || void 0;
  const s2 = `URI: ${e.aud || e.uri}`, i4 = `Version: ${e.version}`, u3 = `Chain ID: ${un2(n4)}`, l3 = `Nonce: ${e.nonce}`, c5 = `Issued At: ${e.iat}`, d4 = e.exp ? `Expiration Time: ${e.exp}` : void 0, a4 = e.nbf ? `Not Before: ${e.nbf}` : void 0, f5 = e.requestId ? `Request ID: ${e.requestId}` : void 0, h4 = e.resources ? `Resources:${e.resources.map((m) => `
- ${m}`).join("")}` : void 0, p4 = Y2(e.resources);
  if (p4) {
    const m = R2(p4);
    o4 = he3(o4, m);
  }
  return [t, r3, "", o4, "", s2, i4, u3, l3, c5, d4, a4, f5, h4].filter((m) => m != null).join(`
`);
};
function hn2(e) {
  return Buffer.from(JSON.stringify(e)).toString("base64");
}
function yn2(e) {
  return JSON.parse(Buffer.from(e, "base64").toString("utf-8"));
}
function O3(e) {
  if (!e) throw new Error("No recap provided, value is undefined");
  if (!e.att) throw new Error("No `att` property found");
  const n4 = Object.keys(e.att);
  if (!(n4 != null && n4.length)) throw new Error("No resources found in `att` property");
  n4.forEach((t) => {
    const r3 = e.att[t];
    if (Array.isArray(r3)) throw new Error(`Resource must be an object: ${t}`);
    if (typeof r3 != "object") throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(r3).length) throw new Error(`Resource object is empty: ${t}`);
    Object.keys(r3).forEach((o4) => {
      const s2 = r3[o4];
      if (!Array.isArray(s2)) throw new Error(`Ability limits ${o4} must be an array of objects, found: ${s2}`);
      if (!s2.length) throw new Error(`Value of ${o4} is empty array, must be an array with objects`);
      s2.forEach((i4) => {
        if (typeof i4 != "object") throw new Error(`Ability limits (${o4}) must be an array of objects, found: ${i4}`);
      });
    });
  });
}
function gn2(e, n4, t, r3 = {}) {
  return t == null ? void 0 : t.sort((o4, s2) => o4.localeCompare(s2)), { att: { [e]: pe2(n4, t, r3) } };
}
function pe2(e, n4, t = {}) {
  n4 = n4 == null ? void 0 : n4.sort((o4, s2) => o4.localeCompare(s2));
  const r3 = n4.map((o4) => ({ [`${e}/${o4}`]: [t] }));
  return Object.assign({}, ...r3);
}
function G2(e) {
  return O3(e), `urn:recap:${hn2(e).replace(/=/g, "")}`;
}
function R2(e) {
  const n4 = yn2(e.replace("urn:recap:", ""));
  return O3(n4), n4;
}
function ir3(e, n4, t) {
  const r3 = gn2(e, n4, t);
  return G2(r3);
}
function me3(e) {
  return e && e.includes("urn:recap:");
}
function cr3(e, n4) {
  const t = R2(e), r3 = R2(n4), o4 = bn2(t, r3);
  return G2(o4);
}
function bn2(e, n4) {
  O3(e), O3(n4);
  const t = Object.keys(e.att).concat(Object.keys(n4.att)).sort((o4, s2) => o4.localeCompare(s2)), r3 = { att: {} };
  return t.forEach((o4) => {
    var s2, i4;
    Object.keys(((s2 = e.att) == null ? void 0 : s2[o4]) || {}).concat(Object.keys(((i4 = n4.att) == null ? void 0 : i4[o4]) || {})).sort((u3, l3) => u3.localeCompare(l3)).forEach((u3) => {
      var l3, c5;
      r3.att[o4] = an2(de2({}, r3.att[o4]), { [u3]: ((l3 = e.att[o4]) == null ? void 0 : l3[u3]) || ((c5 = n4.att[o4]) == null ? void 0 : c5[u3]) });
    });
  }), r3;
}
function he3(e = "", n4) {
  O3(n4);
  const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e.includes(t)) return e;
  const r3 = [];
  let o4 = 0;
  Object.keys(n4.att).forEach((u3) => {
    const l3 = Object.keys(n4.att[u3]).map((a4) => ({ ability: a4.split("/")[0], action: a4.split("/")[1] }));
    l3.sort((a4, f5) => a4.action.localeCompare(f5.action));
    const c5 = {};
    l3.forEach((a4) => {
      c5[a4.ability] || (c5[a4.ability] = []), c5[a4.ability].push(a4.action);
    });
    const d4 = Object.keys(c5).map((a4) => (o4++, `(${o4}) '${a4}': '${c5[a4].join("', '")}' for '${u3}'.`));
    r3.push(d4.join(", ").replace(".,", "."));
  });
  const s2 = r3.join(" "), i4 = `${t}${s2}`;
  return `${e ? e + " " : ""}${i4}`;
}
function ar3(e) {
  var n4;
  const t = R2(e);
  O3(t);
  const r3 = (n4 = t.att) == null ? void 0 : n4.eip155;
  return r3 ? Object.keys(r3).map((o4) => o4.split("/")[1]) : [];
}
function ur3(e) {
  const n4 = R2(e);
  O3(n4);
  const t = [];
  return Object.values(n4.att).forEach((r3) => {
    Object.values(r3).forEach((o4) => {
      var s2;
      (s2 = o4 == null ? void 0 : o4[0]) != null && s2.chains && t.push(o4[0].chains);
    });
  }), [...new Set(t.flat())];
}
function Y2(e) {
  if (!e) return;
  const n4 = e == null ? void 0 : e[e.length - 1];
  return me3(n4) ? n4 : void 0;
}
var ye4 = "base10";
var g4 = "base16";
var ge3 = "base64pad";
var lr3 = "base64url";
var k3 = "utf8";
var ve3 = 0;
var D2 = 1;
var M5 = 2;
var dr4 = 0;
var wn2 = 1;
var K3 = 12;
var be4 = 32;
function fr4() {
  const e = _e3.generateKeyPair();
  return { privateKey: toString(e.secretKey, g4), publicKey: toString(e.publicKey, g4) };
}
function pr4() {
  const e = (0, import_random3.randomBytes)(be4);
  return toString(e, g4);
}
function mr4(e, n4) {
  const t = _e3.sharedKey(fromString(e, g4), fromString(n4, g4), true), r3 = new import_hkdf2.HKDF(import_sha2563.SHA256, t).expand(be4);
  return toString(r3, g4);
}
function hr4(e) {
  const n4 = (0, import_sha2563.hash)(fromString(e, g4));
  return toString(n4, g4);
}
function yr4(e) {
  const n4 = (0, import_sha2563.hash)(fromString(e, k3));
  return toString(n4, g4);
}
function Ee4(e) {
  return fromString(`${e}`, ye4);
}
function A3(e) {
  return Number(toString(e, ye4));
}
function gr4(e) {
  const n4 = Ee4(typeof e.type < "u" ? e.type : ve3);
  if (A3(n4) === D2 && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof e.senderPublicKey < "u" ? fromString(e.senderPublicKey, g4) : void 0, r3 = typeof e.iv < "u" ? fromString(e.iv, g4) : (0, import_random3.randomBytes)(K3), o4 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, g4)).seal(r3, fromString(e.message, k3));
  return we4({ type: n4, sealed: o4, iv: r3, senderPublicKey: t, encoding: e.encoding });
}
function vr4(e, n4) {
  const t = Ee4(M5), r3 = (0, import_random3.randomBytes)(K3), o4 = fromString(e, k3);
  return we4({ type: t, sealed: o4, iv: r3, encoding: n4 });
}
function br4(e) {
  const n4 = new import_chacha20poly13052.ChaCha20Poly1305(fromString(e.symKey, g4)), { sealed: t, iv: r3 } = Q3({ encoded: e.encoded, encoding: e == null ? void 0 : e.encoding }), o4 = n4.open(r3, t);
  if (o4 === null) throw new Error("Failed to decrypt");
  return toString(o4, k3);
}
function Er4(e, n4) {
  const { sealed: t } = Q3({ encoded: e, encoding: n4 });
  return toString(t, k3);
}
function we4(e) {
  const { encoding: n4 = ge3 } = e;
  if (A3(e.type) === M5) return toString(concat([e.type, e.sealed]), n4);
  if (A3(e.type) === D2) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), n4);
  }
  return toString(concat([e.type, e.iv, e.sealed]), n4);
}
function Q3(e) {
  const { encoded: n4, encoding: t = ge3 } = e, r3 = fromString(n4, t), o4 = r3.slice(dr4, wn2), s2 = wn2;
  if (A3(o4) === D2) {
    const c5 = s2 + be4, d4 = c5 + K3, a4 = r3.slice(s2, c5), f5 = r3.slice(c5, d4), h4 = r3.slice(d4);
    return { type: o4, sealed: h4, iv: f5, senderPublicKey: a4 };
  }
  if (A3(o4) === M5) {
    const c5 = r3.slice(s2), d4 = (0, import_random3.randomBytes)(K3);
    return { type: o4, sealed: c5, iv: d4 };
  }
  const i4 = s2 + K3, u3 = r3.slice(s2, i4), l3 = r3.slice(i4);
  return { type: o4, sealed: l3, iv: u3 };
}
function wr4(e, n4) {
  const t = Q3({ encoded: e, encoding: n4 == null ? void 0 : n4.encoding });
  return On2({ type: A3(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? toString(t.senderPublicKey, g4) : void 0, receiverPublicKey: n4 == null ? void 0 : n4.receiverPublicKey });
}
function On2(e) {
  const n4 = (e == null ? void 0 : e.type) || ve3;
  if (n4 === D2) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: n4, senderPublicKey: e == null ? void 0 : e.senderPublicKey, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey };
}
function Or4(e) {
  return e.type === D2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
}
function Nr4(e) {
  return e.type === M5;
}
function Nn2(e) {
  return new import_elliptic2.ec("p256").keyFromPublic({ x: Buffer.from(e.x, "base64").toString("hex"), y: Buffer.from(e.y, "base64").toString("hex") }, "hex");
}
function Sr4(e) {
  let n4 = e.replace(/-/g, "+").replace(/_/g, "/");
  const t = n4.length % 4;
  return t > 0 && (n4 += "=".repeat(4 - t)), n4;
}
function $r4(e) {
  return Buffer.from(Sr4(e), "base64");
}
function Rr4(e, n4) {
  const [t, r3, o4] = e.split("."), s2 = $r4(o4);
  if (s2.length !== 64) throw new Error("Invalid signature length");
  const i4 = s2.slice(0, 32).toString("hex"), u3 = s2.slice(32, 64).toString("hex"), l3 = `${t}.${r3}`, c5 = new import_sha2563.SHA256().update(Buffer.from(l3)).digest(), d4 = Nn2(n4), a4 = Buffer.from(c5).toString("hex");
  if (!d4.verify(a4, { r: i4, s: u3 })) throw new Error("Invalid signature");
  return decodeJWT(e).payload;
}
var Sn2 = "irn";
function Ir3(e) {
  return (e == null ? void 0 : e.relay) || { protocol: Sn2 };
}
function jr3(e) {
  const n4 = C[e];
  if (typeof n4 > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return n4;
}
var Tr4 = Object.defineProperty;
var Pr4 = Object.defineProperties;
var Ar4 = Object.getOwnPropertyDescriptors;
var $n2 = Object.getOwnPropertySymbols;
var Cr4 = Object.prototype.hasOwnProperty;
var Ur3 = Object.prototype.propertyIsEnumerable;
var Rn2 = (e, n4, t) => n4 in e ? Tr4(e, n4, { enumerable: true, configurable: true, writable: true, value: t }) : e[n4] = t;
var In2 = (e, n4) => {
  for (var t in n4 || (n4 = {})) Cr4.call(n4, t) && Rn2(e, t, n4[t]);
  if ($n2) for (var t of $n2(n4)) Ur3.call(n4, t) && Rn2(e, t, n4[t]);
  return e;
};
var _r4 = (e, n4) => Pr4(e, Ar4(n4));
function jn2(e, n4 = "-") {
  const t = {}, r3 = "relay" + n4;
  return Object.keys(e).forEach((o4) => {
    if (o4.startsWith(r3)) {
      const s2 = o4.replace(r3, ""), i4 = e[o4];
      t[s2] = i4;
    }
  }), t;
}
function kr3(e) {
  if (!e.includes("wc:")) {
    const l3 = le3(e);
    l3 != null && l3.includes("wc:") && (e = l3);
  }
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const n4 = e.indexOf(":"), t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0, r3 = e.substring(0, n4), o4 = e.substring(n4 + 1, t).split("@"), s2 = typeof t < "u" ? e.substring(t) : "", i4 = q3.parse(s2), u3 = typeof i4.methods == "string" ? i4.methods.split(",") : void 0;
  return { protocol: r3, topic: Tn2(o4[0]), version: parseInt(o4[1], 10), symKey: i4.symKey, relay: jn2(i4), methods: u3, expiryTimestamp: i4.expiryTimestamp ? parseInt(i4.expiryTimestamp, 10) : void 0 };
}
function Tn2(e) {
  return e.startsWith("//") ? e.substring(2) : e;
}
function Pn2(e, n4 = "-") {
  const t = "relay", r3 = {};
  return Object.keys(e).forEach((o4) => {
    const s2 = t + n4 + o4;
    e[o4] && (r3[s2] = e[o4]);
  }), r3;
}
function Dr4(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + q3.stringify(In2(_r4(In2({ symKey: e.symKey }, Pn2(e.relay)), { expiryTimestamp: e.expiryTimestamp }), e.methods ? { methods: e.methods.join(",") } : {}));
}
function xr3(e, n4, t) {
  return `${e}?wc_ev=${t}&topic=${n4}`;
}
function C4(e) {
  const n4 = [];
  return e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4.push(`${r3}:${o4}`);
  }), n4;
}
function Un(e) {
  const n4 = [];
  return Object.values(e).forEach((t) => {
    n4.push(...C4(t.accounts));
  }), n4;
}
function _n(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C4(r3.accounts).includes(n4) && t.push(...r3.methods);
  }), t;
}
function kn(e, n4) {
  const t = [];
  return Object.values(e).forEach((r3) => {
    C4(r3.accounts).includes(n4) && t.push(...r3.events);
  }), t;
}
function xn(e) {
  const n4 = {};
  return e == null ? void 0 : e.forEach((t) => {
    const [r3, o4] = t.split(":");
    n4[r3] || (n4[r3] = { accounts: [], chains: [], events: [] }), n4[r3].accounts.push(t), n4[r3].chains.push(`${r3}:${o4}`);
  }), n4;
}
function Jr2(e, n4) {
  n4 = n4.map((r3) => r3.replace("did:pkh:", ""));
  const t = xn(n4);
  for (const [r3, o4] of Object.entries(t)) o4.methods ? o4.methods = N2(o4.methods, e) : o4.methods = e, o4.events = ["chainChanged", "accountsChanged"];
  return t;
}
var Vn2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Mn2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function S5(e, n4) {
  const { message: t, code: r3 } = Mn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function U5(e, n4) {
  const { message: t, code: r3 } = Vn2[e];
  return { message: n4 ? `${t} ${n4}` : t, code: r3 };
}
function L3(e, n4) {
  return Array.isArray(e) ? typeof n4 < "u" && e.length ? e.every(n4) : true : false;
}
function Z3(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
function I4(e) {
  return typeof e > "u";
}
function b2(e, n4) {
  return n4 && I4(e) ? true : typeof e == "string" && !!e.trim().length;
}
function X3(e, n4) {
  return n4 && I4(e) ? true : typeof e == "number" && !isNaN(e);
}
function zr3(e, n4) {
  const { requiredNamespaces: t } = n4, r3 = Object.keys(e.namespaces), o4 = Object.keys(t);
  let s2 = true;
  return $3(o4, r3) ? (r3.forEach((i4) => {
    const { accounts: u3, methods: l3, events: c5 } = e.namespaces[i4], d4 = C4(u3), a4 = t[i4];
    (!$3(W3(i4, a4), d4) || !$3(a4.methods, l3) || !$3(a4.events, c5)) && (s2 = false);
  }), s2) : false;
}
function F3(e) {
  return b2(e, false) && e.includes(":") ? e.split(":").length === 2 : false;
}
function Kn(e) {
  if (b2(e, false) && e.includes(":")) {
    const n4 = e.split(":");
    if (n4.length === 3) {
      const t = n4[0] + ":" + n4[1];
      return !!n4[2] && F3(t);
    }
  }
  return false;
}
function Gr3(e) {
  function n4(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (b2(e, false)) {
      if (n4(e)) return true;
      const t = le3(e);
      return n4(t);
    }
  } catch {
  }
  return false;
}
function Yr3(e) {
  var n4;
  return (n4 = e == null ? void 0 : e.proposer) == null ? void 0 : n4.publicKey;
}
function Qr3(e) {
  return e == null ? void 0 : e.topic;
}
function Zr2(e, n4) {
  let t = null;
  return b2(e == null ? void 0 : e.publicKey, false) || (t = S5("MISSING_OR_INVALID", `${n4} controller public key should be a string`)), t;
}
function Se(e) {
  let n4 = true;
  return L3(e) ? e.length && (n4 = e.every((t) => b2(t, false))) : n4 = false, n4;
}
function Ln(e, n4, t) {
  let r3 = null;
  return L3(n4) && n4.length ? n4.forEach((o4) => {
    r3 || F3(o4) || (r3 = U5("UNSUPPORTED_CHAINS", `${t}, chain ${o4} should be a string and conform to "namespace:chainId" format`));
  }) : F3(e) || (r3 = U5("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r3;
}
function Fn(e, n4, t) {
  let r3 = null;
  return Object.entries(e).forEach(([o4, s2]) => {
    if (r3) return;
    const i4 = Ln(o4, W3(o4, s2), `${n4} ${t}`);
    i4 && (r3 = i4);
  }), r3;
}
function qn(e, n4) {
  let t = null;
  return L3(e) ? e.forEach((r3) => {
    t || Kn(r3) || (t = U5("UNSUPPORTED_ACCOUNTS", `${n4}, account ${r3} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = U5("UNSUPPORTED_ACCOUNTS", `${n4}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function Bn(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t) return;
    const o4 = qn(r3 == null ? void 0 : r3.accounts, `${n4} namespace`);
    o4 && (t = o4);
  }), t;
}
function Hn(e, n4) {
  let t = null;
  return Se(e == null ? void 0 : e.methods) ? Se(e == null ? void 0 : e.events) || (t = U5("UNSUPPORTED_EVENTS", `${n4}, events should be an array of strings or empty array for no events`)) : t = U5("UNSUPPORTED_METHODS", `${n4}, methods should be an array of strings or empty array for no methods`), t;
}
function $e(e, n4) {
  let t = null;
  return Object.values(e).forEach((r3) => {
    if (t) return;
    const o4 = Hn(r3, `${n4}, namespace`);
    o4 && (t = o4);
  }), t;
}
function Xr2(e, n4, t) {
  let r3 = null;
  if (e && Z3(e)) {
    const o4 = $e(e, n4);
    o4 && (r3 = o4);
    const s2 = Fn(e, n4, t);
    s2 && (r3 = s2);
  } else r3 = S5("MISSING_OR_INVALID", `${n4}, ${t} should be an object with data`);
  return r3;
}
function Wn(e, n4) {
  let t = null;
  if (e && Z3(e)) {
    const r3 = $e(e, n4);
    r3 && (t = r3);
    const o4 = Bn(e, n4);
    o4 && (t = o4);
  } else t = S5("MISSING_OR_INVALID", `${n4}, namespaces should be an object with data`);
  return t;
}
function Jn(e) {
  return b2(e.protocol, true);
}
function eo(e, n4) {
  let t = false;
  return n4 && !e ? t = true : e && L3(e) && e.length && e.forEach((r3) => {
    t = Jn(r3);
  }), t;
}
function no(e) {
  return typeof e == "number";
}
function to2(e) {
  return typeof e < "u" && typeof e !== null;
}
function ro(e) {
  return !(!e || typeof e != "object" || !e.code || !X3(e.code, false) || !e.message || !b2(e.message, false));
}
function oo(e) {
  return !(I4(e) || !b2(e.method, false));
}
function so(e) {
  return !(I4(e) || I4(e.result) && I4(e.error) || !X3(e.id, false) || !b2(e.jsonrpc, false));
}
function io(e) {
  return !(I4(e) || !b2(e.name, false));
}
function co(e, n4) {
  return !(!F3(n4) || !Un(e).includes(n4));
}
function ao(e, n4, t) {
  return b2(t, false) ? _n(e, n4).includes(t) : false;
}
function uo(e, n4, t) {
  return b2(t, false) ? kn(e, n4).includes(t) : false;
}
function zn(e, n4, t) {
  let r3 = null;
  const o4 = lo(e), s2 = fo(n4), i4 = Object.keys(o4), u3 = Object.keys(s2), l3 = Gn(Object.keys(e)), c5 = Gn(Object.keys(n4)), d4 = l3.filter((a4) => !c5.includes(a4));
  return d4.length && (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d4.toString()}
      Received: ${Object.keys(n4).toString()}`)), $3(i4, u3) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${u3.toString()}`)), Object.keys(n4).forEach((a4) => {
    if (!a4.includes(":") || r3) return;
    const f5 = C4(n4[a4].accounts);
    f5.includes(a4) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${a4}
        Required: ${a4}
        Approved: ${f5.toString()}`));
  }), i4.forEach((a4) => {
    r3 || ($3(o4[a4].methods, s2[a4].methods) ? $3(o4[a4].events, s2[a4].events) || (r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${a4}`)) : r3 = S5("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${a4}`));
  }), r3;
}
function lo(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    var r3;
    t.includes(":") ? n4[t] = e[t] : (r3 = e[t].chains) == null || r3.forEach((o4) => {
      n4[o4] = { methods: e[t].methods, events: e[t].events };
    });
  }), n4;
}
function Gn(e) {
  return [...new Set(e.map((n4) => n4.includes(":") ? n4.split(":")[0] : n4))];
}
function fo(e) {
  const n4 = {};
  return Object.keys(e).forEach((t) => {
    if (t.includes(":")) n4[t] = e[t];
    else {
      const r3 = C4(e[t].accounts);
      r3 == null ? void 0 : r3.forEach((o4) => {
        n4[o4] = { accounts: e[t].accounts.filter((s2) => s2.includes(`${o4}:`)), methods: e[t].methods, events: e[t].events };
      });
    }
  }), n4;
}
function po2(e, n4) {
  return X3(e, false) && e <= n4.max && e >= n4.min;
}
function mo2() {
  const e = P3();
  return new Promise((n4) => {
    switch (e) {
      case y5.browser:
        n4(Yn2());
        break;
      case y5.reactNative:
        n4(Qn2());
        break;
      case y5.node:
        n4(Zn2());
        break;
      default:
        n4(true);
    }
  });
}
function Yn2() {
  return V4() && (navigator == null ? void 0 : navigator.onLine);
}
async function Qn2() {
  if (_2() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected;
  }
  return true;
}
function Zn2() {
  return true;
}
function ho2(e) {
  switch (P3()) {
    case y5.browser:
      Xn2(e);
      break;
    case y5.reactNative:
      et4(e);
      break;
    case y5.node:
      break;
  }
}
function Xn2(e) {
  !_2() && V4() && (window.addEventListener("online", () => e(true)), window.addEventListener("offline", () => e(false)));
}
function et4(e) {
  _2() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n4) => e(n4 == null ? void 0 : n4.isConnected)));
}
var Re = {};
var yo = class {
  static get(n4) {
    return Re[n4];
  }
  static set(n4, t) {
    Re[n4] = t;
  }
  static delete(n4) {
    delete Re[n4];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash2 = __toESM(require_lodash());
var import_window_getters4 = __toESM(require_cjs2());
var ye5 = "wc";
var De3 = 2;
var ie3 = "core";
var x5 = `${ye5}@2:${ie3}:`;
var Ye2 = { name: ie3, logger: "error" };
var Je5 = { database: ":memory:" };
var Xe4 = "crypto";
var me4 = "client_ed25519_seed";
var We5 = import_time6.ONE_DAY;
var Ze3 = "keychain";
var Qe2 = "0.3";
var et5 = "messages";
var tt3 = "0.3";
var it5 = import_time6.SIX_HOURS;
var st5 = "publisher";
var rt3 = "irn";
var nt3 = "error";
var be5 = "wss://relay.walletconnect.org";
var ot3 = "relayer";
var v4 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var at5 = "_subscription";
var I5 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht3 = 0.1;
var se3 = "2.17.1";
var M6 = { link_mode: "link_mode", relay: "relay" };
var ct3 = "0.3";
var lt3 = "WALLETCONNECT_CLIENT_ID";
var fe4 = "WALLETCONNECT_LINK_MODE_APPS";
var O4 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var ut5 = "subscription";
var dt3 = "0.3";
var pt3 = import_time6.FIVE_SECONDS * 1e3;
var gt5 = "pairing";
var yt3 = "0.3";
var B5 = { wc_pairingDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 0 } } };
var V5 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P4 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Dt5 = "history";
var mt3 = "0.3";
var bt5 = "expirer";
var S6 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var ft3 = "0.3";
var _t5 = "verify-api";
var vs2 = "https://verify.walletconnect.com";
var Et3 = "https://verify.walletconnect.org";
var J2 = Et3;
var vt5 = `${J2}/v3`;
var wt3 = [vs2, Et3];
var It3 = "echo";
var Tt5 = "https://echo.walletconnect.com";
var z4 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $4 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Is = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ts = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Cs = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Ps = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Ct3 = 0.1;
var Pt5 = "event-client";
var St3 = 86400;
var Rt3 = "https://pulse.walletconnect.org/batch";
function Ss2(o4, e) {
  if (o4.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i4 = 0; i4 < o4.length; i4++) {
    var r3 = o4.charAt(i4), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i4;
  }
  var a4 = o4.length, h4 = o4.charAt(0), c5 = Math.log(a4) / Math.log(256), l3 = Math.log(256) / Math.log(a4);
  function p4(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u3.length === 0) return "";
    for (var g6 = 0, _4 = 0, y7 = 0, b5 = u3.length; y7 !== b5 && u3[y7] === 0; ) y7++, g6++;
    for (var A5 = (b5 - y7) * l3 + 1 >>> 0, T3 = new Uint8Array(A5); y7 !== b5; ) {
      for (var N3 = u3[y7], k5 = 0, R4 = A5 - 1; (N3 !== 0 || k5 < _4) && R4 !== -1; R4--, k5++) N3 += 256 * T3[R4] >>> 0, T3[R4] = N3 % a4 >>> 0, N3 = N3 / a4 >>> 0;
      if (N3 !== 0) throw new Error("Non-zero carry");
      _4 = k5, y7++;
    }
    for (var L5 = A5 - _4; L5 !== A5 && T3[L5] === 0; ) L5++;
    for (var Q5 = h4.repeat(g6); L5 < A5; ++L5) Q5 += o4.charAt(T3[L5]);
    return Q5;
  }
  function D5(u3) {
    if (typeof u3 != "string") throw new TypeError("Expected String");
    if (u3.length === 0) return new Uint8Array();
    var g6 = 0;
    if (u3[g6] !== " ") {
      for (var _4 = 0, y7 = 0; u3[g6] === h4; ) _4++, g6++;
      for (var b5 = (u3.length - g6) * c5 + 1 >>> 0, A5 = new Uint8Array(b5); u3[g6]; ) {
        var T3 = t[u3.charCodeAt(g6)];
        if (T3 === 255) return;
        for (var N3 = 0, k5 = b5 - 1; (T3 !== 0 || N3 < y7) && k5 !== -1; k5--, N3++) T3 += a4 * A5[k5] >>> 0, A5[k5] = T3 % 256 >>> 0, T3 = T3 / 256 >>> 0;
        if (T3 !== 0) throw new Error("Non-zero carry");
        y7 = N3, g6++;
      }
      if (u3[g6] !== " ") {
        for (var R4 = b5 - y7; R4 !== b5 && A5[R4] === 0; ) R4++;
        for (var L5 = new Uint8Array(_4 + (b5 - R4)), Q5 = _4; R4 !== b5; ) L5[Q5++] = A5[R4++];
        return L5;
      }
    }
  }
  function m(u3) {
    var g6 = D5(u3);
    if (g6) return g6;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p4, decodeUnsafe: D5, decode: m };
}
var Rs2 = Ss2;
var xs2 = Rs2;
var xt5 = (o4) => {
  if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array") return o4;
  if (o4 instanceof ArrayBuffer) return new Uint8Array(o4);
  if (ArrayBuffer.isView(o4)) return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Os2 = (o4) => new TextEncoder().encode(o4);
var As2 = (o4) => new TextDecoder().decode(o4);
var Ns2 = class {
  constructor(e, t, s2) {
    this.name = e, this.prefix = t, this.baseEncode = s2;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var zs2 = class {
  constructor(e, t, s2) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ot5(this, e);
  }
};
var Ls2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ot5(this, e);
  }
  decode(e) {
    const t = e[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ot5 = (o4, e) => new Ls2({ ...o4.decoders || { [o4.prefix]: o4 }, ...e.decoders || { [e.prefix]: e } });
var $s2 = class {
  constructor(e, t, s2, i4) {
    this.name = e, this.prefix = t, this.baseEncode = s2, this.baseDecode = i4, this.encoder = new Ns2(e, t, s2), this.decoder = new zs2(e, t, i4);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var re4 = ({ name: o4, prefix: e, encode: t, decode: s2 }) => new $s2(o4, e, t, s2);
var X4 = ({ prefix: o4, name: e, alphabet: t }) => {
  const { encode: s2, decode: i4 } = xs2(t, e);
  return re4({ prefix: o4, name: e, encode: s2, decode: (r3) => xt5(i4(r3)) });
};
var ks2 = (o4, e, t, s2) => {
  const i4 = {};
  for (let l3 = 0; l3 < e.length; ++l3) i4[e[l3]] = l3;
  let r3 = o4.length;
  for (; o4[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a4 = 0, h4 = 0, c5 = 0;
  for (let l3 = 0; l3 < r3; ++l3) {
    const p4 = i4[o4[l3]];
    if (p4 === void 0) throw new SyntaxError(`Non-${s2} character`);
    h4 = h4 << t | p4, a4 += t, a4 >= 8 && (a4 -= 8, n4[c5++] = 255 & h4 >> a4);
  }
  if (a4 >= t || 255 & h4 << 8 - a4) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Ms2 = (o4, e, t) => {
  const s2 = e[e.length - 1] === "=", i4 = (1 << t) - 1;
  let r3 = "", n4 = 0, a4 = 0;
  for (let h4 = 0; h4 < o4.length; ++h4) for (a4 = a4 << 8 | o4[h4], n4 += 8; n4 > t; ) n4 -= t, r3 += e[i4 & a4 >> n4];
  if (n4 && (r3 += e[i4 & a4 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var f3 = ({ name: o4, prefix: e, bitsPerChar: t, alphabet: s2 }) => re4({ prefix: e, name: o4, encode(i4) {
  return Ms2(i4, s2, t);
}, decode(i4) {
  return ks2(i4, s2, t, o4);
} });
var Us2 = re4({ prefix: "\0", name: "identity", encode: (o4) => As2(o4), decode: (o4) => Os2(o4) });
var Fs2 = Object.freeze({ __proto__: null, identity: Us2 });
var Ks2 = f3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Bs2 = Object.freeze({ __proto__: null, base2: Ks2 });
var Vs2 = f3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var js2 = Object.freeze({ __proto__: null, base8: Vs2 });
var qs2 = X4({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Gs2 = Object.freeze({ __proto__: null, base10: qs2 });
var Hs2 = f3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ys2 = f3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Js2 = Object.freeze({ __proto__: null, base16: Hs2, base16upper: Ys2 });
var Xs2 = f3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Ws2 = f3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Zs2 = f3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Qs2 = f3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var er4 = f3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var tr3 = f3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ir4 = f3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var sr3 = f3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var rr3 = f3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var nr4 = Object.freeze({ __proto__: null, base32: Xs2, base32upper: Ws2, base32pad: Zs2, base32padupper: Qs2, base32hex: er4, base32hexupper: tr3, base32hexpad: ir4, base32hexpadupper: sr3, base32z: rr3 });
var or3 = X4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var ar4 = X4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var hr5 = Object.freeze({ __proto__: null, base36: or3, base36upper: ar4 });
var cr4 = X4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var lr4 = X4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ur4 = Object.freeze({ __proto__: null, base58btc: cr4, base58flickr: lr4 });
var dr5 = f3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var pr5 = f3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var gr5 = f3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var yr5 = f3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Dr5 = Object.freeze({ __proto__: null, base64: dr5, base64pad: pr5, base64url: gr5, base64urlpad: yr5 });
var At3 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var mr5 = At3.reduce((o4, e, t) => (o4[t] = e, o4), []);
var br5 = At3.reduce((o4, e, t) => (o4[e.codePointAt(0)] = t, o4), []);
function fr5(o4) {
  return o4.reduce((e, t) => (e += mr5[t], e), "");
}
function _r5(o4) {
  const e = [];
  for (const t of o4) {
    const s2 = br5[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(s2);
  }
  return new Uint8Array(e);
}
var Er5 = re4({ prefix: "🚀", name: "base256emoji", encode: fr5, decode: _r5 });
var vr5 = Object.freeze({ __proto__: null, base256emoji: Er5 });
var wr5 = zt4;
var Nt5 = 128;
var Ir4 = 127;
var Tr5 = ~Ir4;
var Cr5 = Math.pow(2, 31);
function zt4(o4, e, t) {
  e = e || [], t = t || 0;
  for (var s2 = t; o4 >= Cr5; ) e[t++] = o4 & 255 | Nt5, o4 /= 128;
  for (; o4 & Tr5; ) e[t++] = o4 & 255 | Nt5, o4 >>>= 7;
  return e[t] = o4 | 0, zt4.bytes = t - s2 + 1, e;
}
var Pr5 = _e4;
var Sr5 = 128;
var Lt5 = 127;
function _e4(o4, s2) {
  var t = 0, s2 = s2 || 0, i4 = 0, r3 = s2, n4, a4 = o4.length;
  do {
    if (r3 >= a4) throw _e4.bytes = 0, new RangeError("Could not decode varint");
    n4 = o4[r3++], t += i4 < 28 ? (n4 & Lt5) << i4 : (n4 & Lt5) * Math.pow(2, i4), i4 += 7;
  } while (n4 >= Sr5);
  return _e4.bytes = r3 - s2, t;
}
var Rr5 = Math.pow(2, 7);
var xr4 = Math.pow(2, 14);
var Or5 = Math.pow(2, 21);
var Ar5 = Math.pow(2, 28);
var Nr5 = Math.pow(2, 35);
var zr4 = Math.pow(2, 42);
var Lr2 = Math.pow(2, 49);
var $r5 = Math.pow(2, 56);
var kr4 = Math.pow(2, 63);
var Mr2 = function(o4) {
  return o4 < Rr5 ? 1 : o4 < xr4 ? 2 : o4 < Or5 ? 3 : o4 < Ar5 ? 4 : o4 < Nr5 ? 5 : o4 < zr4 ? 6 : o4 < Lr2 ? 7 : o4 < $r5 ? 8 : o4 < kr4 ? 9 : 10;
};
var Ur4 = { encode: wr5, decode: Pr5, encodingLength: Mr2 };
var $t5 = Ur4;
var kt5 = (o4, e, t = 0) => ($t5.encode(o4, e, t), e);
var Mt5 = (o4) => $t5.encodingLength(o4);
var Ee5 = (o4, e) => {
  const t = e.byteLength, s2 = Mt5(o4), i4 = s2 + Mt5(t), r3 = new Uint8Array(i4 + t);
  return kt5(o4, r3, 0), kt5(t, r3, s2), r3.set(e, i4), new Fr3(o4, t, e, r3);
};
var Fr3 = class {
  constructor(e, t, s2, i4) {
    this.code = e, this.size = t, this.digest = s2, this.bytes = i4;
  }
};
var Ut3 = ({ name: o4, code: e, encode: t }) => new Kr2(o4, e, t);
var Kr2 = class {
  constructor(e, t, s2) {
    this.name = e, this.code = t, this.encode = s2;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ee5(this.code, t) : t.then((s2) => Ee5(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ft4 = (o4) => async (e) => new Uint8Array(await crypto.subtle.digest(o4, e));
var Br3 = Ut3({ name: "sha2-256", code: 18, encode: Ft4("SHA-256") });
var Vr2 = Ut3({ name: "sha2-512", code: 19, encode: Ft4("SHA-512") });
var jr4 = Object.freeze({ __proto__: null, sha256: Br3, sha512: Vr2 });
var Kt5 = 0;
var qr2 = "identity";
var Bt4 = xt5;
var Gr4 = (o4) => Ee5(Kt5, Bt4(o4));
var Hr2 = { code: Kt5, name: qr2, encode: Bt4, digest: Gr4 };
var Yr4 = Object.freeze({ __proto__: null, identity: Hr2 });
new TextEncoder(), new TextDecoder();
var Vt5 = { ...Fs2, ...Bs2, ...js2, ...Gs2, ...Js2, ...nr4, ...hr5, ...ur4, ...Dr5, ...vr5 };
({ ...jr4, ...Yr4 });
function Jr3(o4 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o4) : new Uint8Array(o4);
}
function jt3(o4, e, t, s2) {
  return { name: o4, prefix: e, encoder: { name: o4, prefix: e, encode: t }, decoder: { decode: s2 } };
}
var qt4 = jt3("utf8", "u", (o4) => "u" + new TextDecoder("utf8").decode(o4), (o4) => new TextEncoder().encode(o4.substring(1)));
var ve4 = jt3("ascii", "a", (o4) => {
  let e = "a";
  for (let t = 0; t < o4.length; t++) e += String.fromCharCode(o4[t]);
  return e;
}, (o4) => {
  o4 = o4.substring(1);
  const e = Jr3(o4.length);
  for (let t = 0; t < o4.length; t++) e[t] = o4.charCodeAt(t);
  return e;
});
var Xr3 = { utf8: qt4, "utf-8": qt4, hex: Vt5.base16, latin1: ve4, ascii: ve4, binary: ve4, ...Vt5 };
function Wr2(o4, e = "utf8") {
  const t = Xr3[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o4, "utf8") : t.decoder.decode(`${t.prefix}${o4}`);
}
var Gt4 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = Ze3, this.version = Qe2, this.initialized = false, this.storagePrefix = x5, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i4) => {
      this.isInitialized(), this.keychain.set(s2, i4), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.keychain.get(s2);
      if (typeof i4 > "u") {
        const { message: r3 } = S5("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i4;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Tt4(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt4(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Ht5 = class {
  constructor(e, t, s2) {
    this.core = e, this.logger = t, this.name = Xe4, this.randomSessionIdentifier = pr4(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i4) => (this.isInitialized(), this.keychain.has(i4)), this.getClientId = async () => {
      this.isInitialized();
      const i4 = await this.getClientSeed(), r3 = generateKeyPair(i4);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i4 = fr4();
      return this.setPrivateKey(i4.publicKey, i4.privateKey);
    }, this.signJWT = async (i4) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a4 = this.randomSessionIdentifier, h4 = We5;
      return await signJWT(a4, i4, h4, n4);
    }, this.generateSharedKey = (i4, r3, n4) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(i4), h4 = mr4(a4, r3);
      return this.setSymKey(h4, n4);
    }, this.setSymKey = async (i4, r3) => {
      this.isInitialized();
      const n4 = r3 || hr4(i4);
      return await this.keychain.set(n4, i4), n4;
    }, this.deleteKeyPair = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.deleteSymKey = async (i4) => {
      this.isInitialized(), await this.keychain.del(i4);
    }, this.encode = async (i4, r3, n4) => {
      this.isInitialized();
      const a4 = On2(n4), h4 = safeJsonStringify(r3);
      if (Nr4(a4)) return vr4(h4, n4 == null ? void 0 : n4.encoding);
      if (Or4(a4)) {
        const D5 = a4.senderPublicKey, m = a4.receiverPublicKey;
        i4 = await this.generateSharedKey(D5, m);
      }
      const c5 = this.getSymKey(i4), { type: l3, senderPublicKey: p4 } = a4;
      return gr4({ type: l3, symKey: c5, message: h4, senderPublicKey: p4, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i4, r3, n4) => {
      this.isInitialized();
      const a4 = wr4(r3, n4);
      if (Nr4(a4)) {
        const h4 = Er4(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(h4);
      }
      if (Or4(a4)) {
        const h4 = a4.receiverPublicKey, c5 = a4.senderPublicKey;
        i4 = await this.generateSharedKey(h4, c5);
      }
      try {
        const h4 = this.getSymKey(i4), c5 = br4({ symKey: h4, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(c5);
      } catch (h4) {
        this.logger.error(`Failed to decode message from topic: '${i4}', clientId: '${await this.getClientId()}'`), this.logger.error(h4);
      }
    }, this.getPayloadType = (i4, r3 = ge3) => {
      const n4 = Q3({ encoded: i4, encoding: r3 });
      return A3(n4.type);
    }, this.getPayloadSenderPublicKey = (i4, r3 = ge3) => {
      const n4 = Q3({ encoded: i4, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, g4) : void 0;
    }, this.core = e, this.logger = E(t, this.name), this.keychain = s2 || new Gt4(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(me4);
    } catch {
      e = pr4(), await this.keychain.set(me4, e);
    }
    return Wr2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Yt4 = class extends a3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = et5, this.version = tt3, this.initialized = false, this.storagePrefix = x5, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i4) => {
      this.isInitialized();
      const r3 = yr4(i4);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i4, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i4 = this.messages.get(s2);
      return typeof i4 > "u" && (i4 = {}), i4;
    }, this.has = (s2, i4) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = yr4(i4);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Tt4(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Pt4(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Zr3 = class extends g3 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.events = new import_events10.EventEmitter(), this.name = st5, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time6.toMiliseconds)(import_time6.ONE_MINUTE), this.failedPublishTimeout = (0, import_time6.toMiliseconds)(import_time6.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i4, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i4, opts: r3 } });
      const a4 = (r3 == null ? void 0 : r3.ttl) || it5, h4 = Ir3(r3), c5 = (r3 == null ? void 0 : r3.prompt) || false, l3 = (r3 == null ? void 0 : r3.tag) || 0, p4 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), D5 = { topic: s2, message: i4, opts: { ttl: a4, relay: h4, prompt: c5, tag: l3, id: p4, attestation: r3 == null ? void 0 : r3.attestation } }, m = `Failed to publish payload, please try again. id:${p4} tag:${l3}`, u3 = Date.now();
      let g6, _4 = 1;
      try {
        for (; g6 === void 0; ) {
          if (Date.now() - u3 > this.publishTimeout) throw new Error(m);
          this.logger.trace({ id: p4, attempts: _4 }, `publisher.publish - attempt ${_4}`), g6 = await await kt4(this.rpcPublish(s2, i4, a4, h4, c5, l3, p4, r3 == null ? void 0 : r3.attestation).catch((y7) => this.logger.warn(y7)), this.publishTimeout, m), _4++, g6 || await new Promise((y7) => setTimeout(y7, this.failedPublishTimeout));
        }
        this.relayer.events.emit(v4.publish, D5), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p4, topic: s2, message: i4, opts: r3 } });
      } catch (y7) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(y7), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw y7;
        this.queue.set(p4, D5);
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e, t, s2, i4, r3, n4, a4, h4) {
    var c5, l3, p4, D5;
    const m = { method: jr3(i4.protocol).publish, params: { topic: e, message: t, ttl: s2, prompt: r3, tag: n4, attestation: h4 }, id: a4 };
    return I4((c5 = m.params) == null ? void 0 : c5.prompt) && ((l3 = m.params) == null || delete l3.prompt), I4((p4 = m.params) == null ? void 0 : p4.tag) && ((D5 = m.params) == null || delete D5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m }), this.relayer.request(m);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: t, message: s2, opts: i4 } = e;
      await this.publish(t, s2, i4);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v4.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v4.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Qr4 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, t) => {
      const s2 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...s2, t]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const s2 = this.get(e);
      if (!this.exists(e, t)) return;
      const i4 = s2.filter((r3) => r3 !== t);
      if (!i4.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i4);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var en3 = Object.defineProperty;
var tn3 = Object.defineProperties;
var sn3 = Object.getOwnPropertyDescriptors;
var Jt4 = Object.getOwnPropertySymbols;
var rn3 = Object.prototype.hasOwnProperty;
var nn3 = Object.prototype.propertyIsEnumerable;
var Xt4 = (o4, e, t) => e in o4 ? en3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var W4 = (o4, e) => {
  for (var t in e || (e = {})) rn3.call(e, t) && Xt4(o4, t, e[t]);
  if (Jt4) for (var t of Jt4(e)) nn3.call(e, t) && Xt4(o4, t, e[t]);
  return o4;
};
var we5 = (o4, e) => tn3(o4, sn3(e));
var Wt5 = class extends d3 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Qr4(), this.events = new import_events10.EventEmitter(), this.name = ut5, this.version = dt3, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x5, this.subscribeTimeout = (0, import_time6.toMiliseconds)(import_time6.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i4) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } });
      try {
        const r3 = Ir3(i4), n4 = { topic: s2, relay: r3, transportType: i4 == null ? void 0 : i4.transportType };
        this.pending.set(s2, n4);
        const a4 = await this.rpcSubscribe(s2, r3, i4);
        return typeof a4 == "string" && (this.onSubscribe(a4, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i4 } })), a4;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i4) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i4 == null ? void 0 : i4.id) < "u" ? await this.unsubscribeById(s2, i4.id, i4) : await this.unsubscribeByTopic(s2, i4);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i4 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a4 = new import_time6.Watch();
        a4.start(i4);
        const h4 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(h4), a4.stop(i4), r3(true)), a4.elapsed(i4) >= pt3 && (clearInterval(h4), a4.stop(i4), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const s2 = this.topicMap.get(e);
    await Promise.all(s2.map(async (i4) => await this.unsubscribeById(e, i4, t)));
  }
  async unsubscribeById(e, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    try {
      const i4 = Ir3(s2);
      await this.rpcUnsubscribe(e, t, i4);
      const r3 = U5("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: s2 } });
    } catch (i4) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i4), i4;
    }
  }
  async rpcSubscribe(e, t, s2) {
    var i4;
    (s2 == null ? void 0 : s2.transportType) === M6.relay && await this.restartToComplete();
    const r3 = { method: jr3(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r3 });
    const n4 = (i4 = s2 == null ? void 0 : s2.internal) == null ? void 0 : i4.throwOnFailedPublish;
    try {
      const a4 = yr4(e + this.clientId);
      if ((s2 == null ? void 0 : s2.transportType) === M6.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r3).catch((c5) => this.logger.warn(c5));
      }, (0, import_time6.toMiliseconds)(import_time6.ONE_SECOND)), a4;
      const h4 = await kt4(this.relayer.request(r3).catch((c5) => this.logger.warn(c5)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h4 && n4) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h4 ? a4 : null;
    } catch (a4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v4.connection_stalled), n4) throw a4;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr3(t.protocol).batchSubscribe, params: { topics: e.map((i4) => i4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await kt4(this.relayer.request(s2).catch((i4) => this.logger.warn(i4)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v4.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, s2 = { method: jr3(t.protocol).batchFetchMessages, params: { topics: e.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i4;
    try {
      i4 = await await kt4(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(v4.connection_stalled);
    }
    return i4;
  }
  rpcUnsubscribe(e, t, s2) {
    const i4 = { method: jr3(s2.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 }), this.relayer.request(i4);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, we5(W4({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, W4({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, W4({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O4.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const s2 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(s2.topic, e), this.events.emit(O4.deleted, we5(W4({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(O4.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(O4.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const t = await this.rpcBatchSubscribe(e);
    L3(t) && this.onBatchSubscribe(t.map((s2, i4) => we5(W4({}, e[i4]), { id: s2 })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((t) => {
      e.push(t);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r2.pulse, async () => {
      await this.checkPending();
    }), this.events.on(O4.created, async (e) => {
      const t = O4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    }), this.events.on(O4.deleted, async (e) => {
      const t = O4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e());
      }, this.pollingInterval);
    });
  }
};
var on3 = Object.defineProperty;
var Zt4 = Object.getOwnPropertySymbols;
var an3 = Object.prototype.hasOwnProperty;
var hn3 = Object.prototype.propertyIsEnumerable;
var Qt4 = (o4, e, t) => e in o4 ? on3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ei2 = (o4, e) => {
  for (var t in e || (e = {})) an3.call(e, t) && Qt4(o4, t, e[t]);
  if (Zt4) for (var t of Zt4(e)) hn3.call(e, t) && Qt4(o4, t, e[t]);
  return o4;
};
var ti2 = class extends u2 {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new import_events10.EventEmitter(), this.name = ot3, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time6.toMiliseconds)(import_time6.THIRTY_SECONDS + import_time6.ONE_SECOND), this.request = async (t) => {
      var s2, i4;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a4 = await new Promise(async (h4, c5) => {
          const l3 = () => {
            c5(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(I5.disconnect, l3);
          const p4 = await n4;
          this.provider.off(I5.disconnect, l3), h4(p4);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i4 = t.params) == null ? void 0 : i4.topic }, "relayer.request - published"), a4;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (ce3()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i4;
          (i4 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i4.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(v4.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(v4.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(I5.payload, this.onPayloadHandler), this.provider.on(I5.connect, this.onConnectHandler), this.provider.on(I5.disconnect, this.onDisconnectHandler), this.provider.on(I5.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || nt3 })), this.messages = new Yt4(this.logger, e.core), this.subscriber = new Wt5(this, this.logger), this.publisher = new Zr3(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.projectId = e.projectId, this.bundleId = Ot4(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e, t, s2;
    return ((s2 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e, t, s2) {
    this.isInitialized(), await this.publisher.publish(e, t, s2), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: M6.relay });
  }
  async subscribe(e, t) {
    var s2, i4, r3;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    const n4 = typeof ((s2 = t == null ? void 0 : t.internal) == null ? void 0 : s2.throwOnFailedPublish) > "u" ? true : (i4 = t == null ? void 0 : t.internal) == null ? void 0 : i4.throwOnFailedPublish;
    let a4 = ((r3 = this.subscriber.topicMap.get(e)) == null ? void 0 : r3[0]) || "", h4;
    const c5 = (l3) => {
      l3.topic === e && (this.subscriber.off(O4.created, c5), h4());
    };
    return await Promise.all([new Promise((l3) => {
      h4 = l3, this.subscriber.on(O4.created, c5);
    }), new Promise(async (l3, p4) => {
      a4 = await this.subscriber.subscribe(e, ei2({ internal: { throwOnFailedPublish: n4 } }, t)).catch((D5) => {
        n4 && p4(D5);
      }) || a4, l3();
    })]), a4;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await kt4(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i4 = () => {
          this.provider.off(I5.disconnect, i4), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(I5.disconnect, i4), await kt4(this.provider.connect(), (0, import_time6.toMiliseconds)(import_time6.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await mo2()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((s2, i4) => s2.publishedAt - i4.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i4) {
      this.logger.warn(i4);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: s2 } = e;
    if (!t.sessionExists) {
      const i4 = Mt4(import_time6.FIVE_MINUTES), r3 = { topic: s2, expiry: i4, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(v4.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, t, s2, i4, r3;
    if (ce3()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((r3 = (i4 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i4.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((t) => e.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o2(new f($t4({ sdkVersion: se3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: s2 } = e;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i4 = this.messages.has(t, s2);
    return i4 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i4;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(at5)) return;
      const t = e.params, { topic: s2, message: i4, publishedAt: r3, attestation: n4 } = t.data, a4 = { topic: s2, message: i4, publishedAt: r3, transportType: M6.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ei2({ type: "event", event: t.id }, a4)), this.events.emit(t.id, a4), await this.acknowledgePayload(e), await this.onMessageEvent(a4);
    } else isJsonRpcResponse(e) && this.events.emit(v4.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(v4.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(I5.payload, this.onPayloadHandler), this.provider.off(I5.connect, this.onConnectHandler), this.provider.off(I5.disconnect, this.onDisconnectHandler), this.provider.off(I5.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await mo2();
    ho2(async (t) => {
      e !== t && (e = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(v4.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, (0, import_time6.toMiliseconds)(ht3))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var cn3 = Object.defineProperty;
var ii2 = Object.getOwnPropertySymbols;
var ln3 = Object.prototype.hasOwnProperty;
var un3 = Object.prototype.propertyIsEnumerable;
var si2 = (o4, e, t) => e in o4 ? cn3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var ri2 = (o4, e) => {
  for (var t in e || (e = {})) ln3.call(e, t) && si2(o4, t, e[t]);
  if (ii2) for (var t of ii2(e)) un3.call(e, t) && si2(o4, t, e[t]);
  return o4;
};
var ni2 = class extends p2 {
  constructor(e, t, s2, i4 = x5, r3 = void 0) {
    super(e, t, s2, i4), this.core = e, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = ct3, this.cached = [], this.initialized = false, this.storagePrefix = x5, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !I4(n4) ? this.map.set(this.getKey(n4), n4) : Yr3(n4) ? this.map.set(n4.id, n4) : Qr3(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a4 }), this.map.set(n4, a4), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a4) => Object.keys(n4).every((h4) => (0, import_lodash2.default)(a4[h4], n4[h4]))) : this.values), this.update = async (n4, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a4 });
      const h4 = ri2(ri2({}, this.getData(n4)), a4);
      this.map.set(n4, h4), await this.persist();
    }, this.delete = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a4 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i4, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i4 } = S5("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i4), new Error(i4);
      }
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var oi2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, this.name = gt5, this.version = yt3, this.events = new import_events10.default(), this.initialized = false, this.storagePrefix = x5, this.ignoredPayloadTypes = [D2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i4 = pr4(), r3 = await this.core.crypto.setSymKey(i4), n4 = Mt4(import_time6.FIVE_MINUTES), a4 = { protocol: rt3 }, h4 = { topic: r3, expiry: n4, relay: a4, active: false, methods: s2 == null ? void 0 : s2.methods }, c5 = Dr4({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i4, relay: a4, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(V5.create, h4), this.core.expirer.set(r3, n4), await this.pairings.set(r3, h4), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: c5 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i4 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z4.pairing_started] } });
      this.isValidPair(s2, i4);
      const { topic: r3, symKey: n4, relay: a4, expiryTimestamp: h4, methods: c5 } = kr3(s2.uri);
      i4.props.properties.topic = r3, i4.addTrace(z4.pairing_uri_validation_success), i4.addTrace(z4.pairing_uri_not_expired);
      let l3;
      if (this.pairings.keys.includes(r3)) {
        if (l3 = this.pairings.get(r3), i4.addTrace(z4.existing_pairing), l3.active) throw i4.setError($4.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i4.addTrace(z4.pairing_not_expired);
      }
      const p4 = h4 || Mt4(import_time6.FIVE_MINUTES), D5 = { topic: r3, relay: a4, expiry: p4, active: false, methods: c5 };
      this.core.expirer.set(r3, p4), await this.pairings.set(r3, D5), i4.addTrace(z4.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(V5.create, D5), i4.addTrace(z4.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i4.addTrace(z4.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i4.setError($4.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a4 });
      } catch (m) {
        throw i4.setError($4.subscribe_pairing_topic_failure), m;
      }
      return i4.addTrace(z4.subscribe_pairing_topic_success), D5;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i4 = Mt4(import_time6.THIRTY_DAYS);
      this.core.expirer.set(s2, i4), await this.pairings.update(s2, { active: true, expiry: i4 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i4 } = s2;
      if (this.pairings.keys.includes(i4)) {
        const r3 = await this.sendRequest(i4, "wc_pairingPing", {}), { done: n4, resolve: a4, reject: h4 } = _t4();
        this.events.once(Lt4("pairing_ping", r3), ({ error: c5 }) => {
          c5 ? h4(c5) : a4();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i4 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i4 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i4 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i4 } = s2;
      this.pairings.keys.includes(i4) && (await this.sendRequest(i4, "wc_pairingDelete", U5("USER_DISCONNECTED")), await this.deletePairing(i4));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i4, relay: r3, expiry: n4, methods: a4 } = s2, h4 = this.core.crypto.keychain.get(i4);
      return Dr4({ protocol: this.core.protocol, version: this.core.version, topic: i4, symKey: h4, relay: r3, expiryTimestamp: n4, methods: a4 });
    }, this.sendRequest = async (s2, i4, r3) => {
      const n4 = formatJsonRpcRequest(i4, r3), a4 = await this.core.crypto.encode(s2, n4), h4 = B5[i4].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a4, h4), n4.id;
    }, this.sendResult = async (s2, i4, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a4 = await this.core.crypto.encode(i4, n4), h4 = await this.core.history.get(i4, s2), c5 = B5[h4.request.method].res;
      await this.core.relayer.publish(i4, a4, c5), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i4, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a4 = await this.core.crypto.encode(i4, n4), h4 = await this.core.history.get(i4, s2), c5 = B5[h4.request.method] ? B5[h4.request.method].res : B5.unregistered_method.res;
      await this.core.relayer.publish(i4, a4, c5), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i4) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, U5("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i4 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i4) => Kt4(i4.expiry));
      await Promise.all(s2.map((i4) => this.deletePairing(i4.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i4, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i4, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i4, r3);
        default:
          return this.onUnknownRpcMethodRequest(i4, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i4, payload: r3 } = s2, n4 = (await this.core.history.get(i4, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i4, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(V5.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i4) => {
      const { id: r3 } = i4;
      setTimeout(() => {
        isJsonRpcResult(i4) ? this.events.emit(Lt4("pairing_ping", r3), {}) : isJsonRpcError(i4) && this.events.emit(Lt4("pairing_ping", r3), { error: i4.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i4) => {
      const { id: r3 } = i4;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(V5.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i4) => {
      const { id: r3, method: n4 } = i4;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a4 = U5("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(U5("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i4) => {
      var r3;
      if (!to2(s2)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i4.setError($4.malformed_pairing_uri), new Error(a4);
      }
      if (!Gr3(s2.uri)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i4.setError($4.malformed_pairing_uri), new Error(a4);
      }
      const n4 = kr3(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i4.setError($4.malformed_pairing_uri), new Error(a4);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i4.setError($4.malformed_pairing_uri), new Error(a4);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time6.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i4.setError($4.pairing_expired);
        const { message: a4 } = S5("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }, this.isValidPing = async (s2) => {
      if (!to2(s2)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidDisconnect = async (s2) => {
      if (!to2(s2)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i4 } = s2;
      await this.isValidPairingTopic(i4);
    }, this.isValidPairingTopic = async (s2) => {
      if (!b2(s2, false)) {
        const { message: i4 } = S5("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i4);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i4 } = S5("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i4);
      }
      if (Kt4(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i4 } = S5("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i4);
      }
    }, this.core = e, this.logger = E(t, this.name), this.pairings = new ni2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v4.message, async (e) => {
      const { topic: t, message: s2, transportType: i4 } = e;
      if (!this.pairings.keys.includes(t) || i4 === M6.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(S6.expired, async (e) => {
      const { topic: t } = Vt4(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(V5.expire, { topic: t }));
    });
  }
};
var ai2 = class extends h3 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events10.EventEmitter(), this.name = Dt5, this.version = mt3, this.cached = [], this.initialized = false, this.storagePrefix = x5, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i4, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i4, chainId: r3 }), this.records.has(i4.id)) return;
      const n4 = { id: i4.id, topic: s2, request: { method: i4.method, params: i4.params || null }, chainId: r3, expiry: Mt4(import_time6.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P4.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i4 = await this.getRecord(s2.id);
      typeof i4.response > "u" && (i4.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i4.id, i4), this.persist(), this.events.emit(P4.updated, i4));
    }, this.get = async (s2, i4) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i4 }), await this.getRecord(i4)), this.delete = (s2, i4) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i4 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i4 < "u" && r3.id !== i4) return;
          this.records.delete(r3.id), this.events.emit(P4.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i4) => (this.isInitialized(), this.records.has(i4) ? (await this.getRecord(i4)).topic === s2 : false), this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(s2);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P4.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(P4.created, (e) => {
      const t = P4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P4.updated, (e) => {
      const t = P4.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(P4.deleted, (e) => {
      const t = P4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r2.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time6.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P4.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var hi2 = class extends x4 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events10.EventEmitter(), this.name = bt5, this.version = ft3, this.cached = [], this.initialized = false, this.storagePrefix = x5, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i4 = this.formatTarget(s2);
        return typeof this.getExpiration(i4) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i4) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i4 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(S6.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i4 = this.formatTarget(s2);
      return this.getExpiration(i4);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i4 = this.formatTarget(s2), r3 = this.getExpiration(i4);
        this.expirations.delete(i4), this.events.emit(S6.deleted, { target: i4, expiration: r3 });
      }
    }, this.on = (s2, i4) => {
      this.events.on(s2, i4);
    }, this.once = (s2, i4) => {
      this.events.once(s2, i4);
    }, this.off = (s2, i4) => {
      this.events.off(s2, i4);
    }, this.removeListener = (s2, i4) => {
      this.events.removeListener(s2, i4);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Dt4(e);
    if (typeof e == "number") return xt4(e);
    const { message: t } = S5("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(S6.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = S5("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: s2 } = S5("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: s2 } = t;
    (0, import_time6.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(S6.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r2.pulse, () => this.checkExpirations()), this.events.on(S6.created, (e) => {
      const t = S6.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S6.expired, (e) => {
      const t = S6.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(S6.deleted, (e) => {
      const t = S6.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = S5("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var ci2 = class extends y4 {
  constructor(e, t, s2) {
    super(e, t, s2), this.core = e, this.logger = t, this.store = s2, this.name = _t5, this.verifyUrlV3 = vt5, this.storagePrefix = x5, this.version = De3, this.init = async () => {
      var i4;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time6.toMiliseconds)((i4 = this.publicKey) == null ? void 0 : i4.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i4) => {
      if (!V4() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a4 } = i4, h4 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a4}`;
      try {
        const c5 = (0, import_window_getters4.getDocument)(), l3 = this.startAbortTimer(import_time6.ONE_SECOND * 5), p4 = await new Promise((D5, m) => {
          const u3 = () => {
            window.removeEventListener("message", _4), c5.body.removeChild(g6), m("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u3);
          const g6 = c5.createElement("iframe");
          g6.src = h4, g6.style.display = "none", g6.addEventListener("error", u3, { signal: this.abortController.signal });
          const _4 = (y7) => {
            if (y7.data && typeof y7.data == "string") try {
              const b5 = JSON.parse(y7.data);
              if (b5.type === "verify_attestation") {
                if (decodeJWT(b5.attestation).payload.id !== n4) return;
                clearInterval(l3), c5.body.removeChild(g6), this.abortController.signal.removeEventListener("abort", u3), window.removeEventListener("message", _4), D5(b5.attestation === null ? "" : b5.attestation);
              }
            } catch (b5) {
              this.logger.warn(b5);
            }
          };
          c5.body.appendChild(g6), window.addEventListener("message", _4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p4), p4;
      } catch (c5) {
        this.logger.warn(c5);
      }
      return "";
    }, this.resolve = async (i4) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a4 } = i4;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a4) return;
        const c5 = await this.isValidJwtAttestation(r3);
        if (c5) {
          if (!c5.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return c5;
        }
      }
      if (!n4) return;
      const h4 = this.getVerifyUrl(i4 == null ? void 0 : i4.verifyUrl);
      return this.fetchAttestation(n4, h4);
    }, this.fetchAttestation = async (i4, r3) => {
      this.logger.debug(`resolving attestation: ${i4} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time6.ONE_SECOND * 5), a4 = await fetch(`${r3}/attestation/${i4}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a4.status === 200 ? await a4.json() : void 0;
    }, this.getVerifyUrl = (i4) => {
      let r3 = i4 || J2;
      return wt3.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${J2}`), r3 = J2), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i4 = this.startAbortTimer(import_time6.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i4), await r3.json();
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.persistPublicKey = async (i4) => {
      this.logger.debug("persisting public key to local storage", i4), await this.store.setItem(this.storeKey, i4), this.publicKey = i4;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i4) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i4, r3);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i4, n4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i4 = await this.fetchPromise;
      return this.fetchPromise = void 0, i4;
    }, this.validateAttestation = (i4, r3) => {
      const n4 = Rr4(i4, r3.publicKey), a4 = { hasExpired: (0, import_time6.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a4.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Wt4(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time6.toMiliseconds)(e));
  }
};
var li2 = class extends v3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, this.context = It3, this.registerDeviceToken = async (s2) => {
      const { clientId: i4, token: r3, notificationType: n4, enableEncrypted: a4 = false } = s2, h4 = `${Tt5}/${this.projectId}/clients`;
      await fetch(h4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i4, type: n4, token: r3, always_raw: a4 }) });
    }, this.logger = E(t, this.context);
  }
};
var dn3 = Object.defineProperty;
var ui2 = Object.getOwnPropertySymbols;
var pn2 = Object.prototype.hasOwnProperty;
var gn3 = Object.prototype.propertyIsEnumerable;
var di2 = (o4, e, t) => e in o4 ? dn3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Z4 = (o4, e) => {
  for (var t in e || (e = {})) pn2.call(e, t) && di2(o4, t, e[t]);
  if (ui2) for (var t of ui2(e)) gn3.call(e, t) && di2(o4, t, e[t]);
  return o4;
};
var pi2 = class extends C3 {
  constructor(e, t, s2 = true) {
    super(e, t, s2), this.core = e, this.logger = t, this.context = Pt5, this.storagePrefix = x5, this.storageVersion = Ct3, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Wt4()) try {
        const i4 = { eventId: Ht4(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Ge2(this.core.relayer.protocol, this.core.relayer.version, se3) } } };
        await this.sendEvent([i4]);
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.createEvent = (i4) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a4, trace: h4 } } = i4, c5 = Ht4(), l3 = this.core.projectId || "", p4 = Date.now(), D5 = Z4({ eventId: c5, timestamp: p4, props: { event: r3, type: n4, properties: { topic: a4, trace: h4 } }, bundleId: l3, domain: this.getAppDomain() }, this.setMethods(c5));
      return this.telemetryEnabled && (this.events.set(c5, D5), this.shouldPersist = true), D5;
    }, this.getEvent = (i4) => {
      const { eventId: r3, topic: n4 } = i4;
      if (r3) return this.events.get(r3);
      const a4 = Array.from(this.events.values()).find((h4) => h4.props.properties.topic === n4);
      if (a4) return Z4(Z4({}, a4), this.setMethods(a4.eventId));
    }, this.deleteEvent = (i4) => {
      const { eventId: r3 } = i4;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r2.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i4) => {
          (0, import_time6.fromMiliseconds)(Date.now()) - (0, import_time6.fromMiliseconds)(i4.timestamp) > St3 && (this.events.delete(i4.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i4) => ({ addTrace: (r3) => this.addTrace(i4, r3), setError: (r3) => this.setError(i4, r3) }), this.addTrace = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.setError = (i4, r3) => {
      const n4 = this.events.get(i4);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i4, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i4 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i4.length) return;
        i4.forEach((r3) => {
          this.events.set(r3.eventId, Z4(Z4({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i4) {
        this.logger.warn(i4);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i4 = [];
      for (const [r3, n4] of this.events) n4.props.type && i4.push(n4);
      if (i4.length !== 0) try {
        if ((await this.sendEvent(i4)).ok) for (const r3 of i4) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i4) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${Rt3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${se3}${r3}`, { method: "POST", body: JSON.stringify(i4) });
    }, this.getAppDomain = () => Nt4().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var yn3 = Object.defineProperty;
var gi2 = Object.getOwnPropertySymbols;
var Dn2 = Object.prototype.hasOwnProperty;
var mn2 = Object.prototype.propertyIsEnumerable;
var yi2 = (o4, e, t) => e in o4 ? yn3(o4, e, { enumerable: true, configurable: true, writable: true, value: t }) : o4[e] = t;
var Di2 = (o4, e) => {
  for (var t in e || (e = {})) Dn2.call(e, t) && yi2(o4, t, e[t]);
  if (gi2) for (var t of gi2(e)) mn2.call(e, t) && yi2(o4, t, e[t]);
  return o4;
};
var ne5 = class _ne extends n3 {
  constructor(e) {
    var t;
    super(e), this.protocol = ye5, this.version = De3, this.name = ie3, this.events = new import_events10.EventEmitter(), this.initialized = false, this.on = (n4, a4) => this.events.on(n4, a4), this.once = (n4, a4) => this.events.once(n4, a4), this.off = (n4, a4) => this.events.off(n4, a4), this.removeListener = (n4, a4) => this.events.removeListener(n4, a4), this.dispatchEnvelope = ({ topic: n4, message: a4, sessionExists: h4 }) => {
      if (!n4 || !a4) return;
      const c5 = { topic: n4, message: a4, publishedAt: Date.now(), transportType: M6.link_mode };
      this.relayer.onLinkMessageEvent(c5, { sessionExists: h4 });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || be5, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Ye2.logger }), { logger: i4, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a4;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a4 = this.logChunkController) == null || a4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i4, this.name), this.heartbeat = new i(), this.crypto = new Ht5(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ai2(this, this.logger), this.expirer = new hi2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(Di2(Di2({}, Je5), e == null ? void 0 : e.storageOptions)), this.relayer = new ti2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new oi2(this, this.logger), this.verify = new ci2(this, this.logger, this.storage), this.echoClient = new li2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new pi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const t = new _ne(e);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(lt3, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(fe4, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(fe4) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
};
var bn3 = ne5;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events11 = __toESM(require_events());
var import_time7 = __toESM(require_cjs());
var be6 = "wc";
var Ce6 = 2;
var Le4 = "client";
var ye6 = `${be6}@${Ce6}:${Le4}:`;
var we6 = { name: Le4, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe = "WALLETCONNECT_DEEPLINK_CHOICE";
var st6 = "proposal";
var it6 = "Proposal expired";
var rt4 = "session";
var z5 = import_time7.SEVEN_DAYS;
var nt4 = "engine";
var v5 = { wc_sessionPropose: { req: { ttl: import_time7.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time7.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time7.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time7.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time7.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time7.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time7.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me5 = { min: import_time7.FIVE_MINUTES, max: import_time7.SEVEN_DAYS };
var x6 = { idle: "IDLE", active: "ACTIVE" };
var ot4 = "request";
var at6 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct4 = "wc";
var lt4 = "auth";
var pt4 = "authKeys";
var ht4 = "pairingTopics";
var dt4 = "requests";
var oe4 = `${ct4}@${1.5}:${lt4}:`;
var ae6 = `${oe4}:PUB_KEY`;
var ys3 = Object.defineProperty;
var ws = Object.defineProperties;
var ms = Object.getOwnPropertyDescriptors;
var ut6 = Object.getOwnPropertySymbols;
var _s = Object.prototype.hasOwnProperty;
var Es = Object.prototype.propertyIsEnumerable;
var gt6 = (q6, o4, e) => o4 in q6 ? ys3(q6, o4, { enumerable: true, configurable: true, writable: true, value: e }) : q6[o4] = e;
var I6 = (q6, o4) => {
  for (var e in o4 || (o4 = {})) _s.call(o4, e) && gt6(q6, e, o4[e]);
  if (ut6) for (var e of ut6(o4)) Es.call(o4, e) && gt6(q6, e, o4[e]);
  return q6;
};
var D3 = (q6, o4) => ws(q6, ms(o4));
var Rs3 = class extends M4 {
  constructor(o4) {
    super(o4), this.name = nt4, this.events = new import_events11.default(), this.initialized = false, this.requestQueue = { state: x6.idle, queue: [] }, this.sessionRequestQueue = { state: x6.idle, queue: [] }, this.requestQueueDelay = import_time7.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v5) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time7.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D3(I6({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i4, optionalNamespaces: r3, sessionProperties: n4, relays: a4 } = t;
      let c5 = s2, h4, p4 = false;
      try {
        c5 && (p4 = this.client.core.pairing.pairings.get(c5).active);
      } catch (E3) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E3;
      }
      if (!c5 || !p4) {
        const { topic: E3, uri: S8 } = await this.client.core.pairing.create();
        c5 = E3, h4 = S8;
      }
      if (!c5) {
        const { message: E3 } = S5("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E3);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), l3 = v5.wc_sessionPropose.req.ttl || import_time7.FIVE_MINUTES, w4 = Mt4(l3), m = I6({ requiredNamespaces: i4, optionalNamespaces: r3, relays: a4 ?? [{ protocol: rt3 }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: w4, pairingTopic: c5 }, n4 && { sessionProperties: n4 }), { reject: y7, resolve: _4, done: R4 } = _t4(l3, it6);
      this.events.once(Lt4("session_connect"), async ({ error: E3, session: S8 }) => {
        if (E3) y7(E3);
        else if (S8) {
          S8.self.publicKey = d4;
          const M7 = D3(I6({}, S8), { pairingTopic: m.pairingTopic, requiredNamespaces: m.requiredNamespaces, optionalNamespaces: m.optionalNamespaces, transportType: M6.relay });
          await this.client.session.set(S8.topic, M7), await this.setExpiry(S8.topic, S8.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S8.peer.metadata }), this.cleanupDuplicatePairings(M7), _4(M7);
        }
      });
      const V7 = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m, throwOnFailedPublish: true });
      return await this.setProposal(V7, I6({ id: V7 }, m)), { uri: h4, approval: R4 };
    }, this.pair = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e) => {
      var t, s2, i4;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [Is.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N3) {
        throw r3.setError(Ts.no_internet_connection), N3;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (N3) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r3.setError(Ts.proposal_not_found), N3;
      }
      try {
        await this.isValidApprove(e);
      } catch (N3) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ts.session_approve_namespace_validation_failure), N3;
      }
      const { id: n4, relayProtocol: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p4 } = e, d4 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l3, proposer: w4, requiredNamespaces: m, optionalNamespaces: y7 } = d4;
      let _4 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l3 });
      _4 || (_4 = (i4 = this.client.core.eventClient) == null ? void 0 : i4.createEvent({ type: Is.session_approve_started, properties: { topic: l3, trace: [Is.session_approve_started, Is.session_namespaces_validation_success] } }));
      const R4 = await this.client.core.crypto.generateKeyPair(), V7 = w4.publicKey, E3 = await this.client.core.crypto.generateSharedKey(R4, V7), S8 = I6(I6({ relay: { protocol: a4 ?? "irn" }, namespaces: c5, controller: { publicKey: R4, metadata: this.client.metadata }, expiry: Mt4(z5) }, h4 && { sessionProperties: h4 }), p4 && { sessionConfig: p4 }), M7 = M6.relay;
      _4.addTrace(Is.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E3, { transportType: M7 });
      } catch (N3) {
        throw _4.setError(Ts.subscribe_session_topic_failure), N3;
      }
      _4.addTrace(Is.subscribe_session_topic_success);
      const W5 = D3(I6({}, S8), { topic: E3, requiredNamespaces: m, optionalNamespaces: y7, pairingTopic: l3, acknowledged: false, self: S8.controller, peer: { publicKey: w4.publicKey, metadata: w4.metadata }, controller: R4, transportType: M6.relay });
      await this.client.session.set(E3, W5), _4.addTrace(Is.store_session);
      try {
        _4.addTrace(Is.publishing_session_settle), await this.sendRequest({ topic: E3, method: "wc_sessionSettle", params: S8, throwOnFailedPublish: true }).catch((N3) => {
          throw _4 == null ? void 0 : _4.setError(Ts.session_settle_publish_failure), N3;
        }), _4.addTrace(Is.session_settle_publish_success), _4.addTrace(Is.publishing_session_approve), await this.sendResult({ id: n4, topic: l3, result: { relay: { protocol: a4 ?? "irn" }, responderPublicKey: R4 }, throwOnFailedPublish: true }).catch((N3) => {
          throw _4 == null ? void 0 : _4.setError(Ts.session_approve_publish_failure), N3;
        }), _4.addTrace(Is.session_approve_publish_success);
      } catch (N3) {
        throw this.client.logger.error(N3), this.client.session.delete(E3, U5("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E3), N3;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _4.eventId }), await this.client.core.pairing.updateMetadata({ topic: l3, metadata: w4.metadata }), await this.client.proposal.delete(n4, U5("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l3 }), await this.setExpiry(E3, Mt4(z5)), { topic: E3, acknowledged: () => Promise.resolve(this.client.session.get(E3)) };
    }, this.reject = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e;
      let i4;
      try {
        i4 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i4 && (await this.sendError({ id: t, topic: i4, error: s2, rpcOpts: v5.wc_sessionPropose.reject }), await this.client.proposal.delete(t, U5("USER_DISCONNECTED")));
    }, this.update = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (p4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p4;
      }
      const { topic: t, namespaces: s2 } = e, { done: i4, resolve: r3, reject: n4 } = _t4(), a4 = payloadId(), c5 = getBigIntRpcId().toString(), h4 = this.client.session.get(t).namespaces;
      return this.events.once(Lt4("session_update", a4), ({ error: p4 }) => {
        p4 ? n4(p4) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a4, relayRpcId: c5 }).catch((p4) => {
        this.client.logger.error(p4), this.client.session.update(t, { namespaces: h4 }), n4(p4);
      }), { acknowledged: i4 };
    }, this.extend = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a4) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a4;
      }
      const { topic: t } = e, s2 = payloadId(), { done: i4, resolve: r3, reject: n4 } = _t4();
      return this.events.once(Lt4("session_extend", s2), ({ error: a4 }) => {
        a4 ? n4(a4) : r3();
      }), await this.setExpiry(t, Mt4(z5)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a4) => {
        n4(a4);
      }), { acknowledged: i4 };
    }, this.request = async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (w4) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w4;
      }
      const { chainId: t, request: s2, topic: i4, expiry: r3 = v5.wc_sessionRequest.req.ttl } = e, n4 = this.client.session.get(i4);
      (n4 == null ? void 0 : n4.transportType) === M6.relay && await this.confirmOnlineStateOrThrow();
      const a4 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h4, resolve: p4, reject: d4 } = _t4(r3, "Request expired. Please try again.");
      this.events.once(Lt4("session_request", a4), ({ error: w4, result: m }) => {
        w4 ? d4(w4) : p4(m);
      });
      const l3 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l3 ? (await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i4, method: "wc_sessionRequest", params: { request: D3(I6({}, s2), { expiryTimestamp: Mt4(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l3 }).catch((w4) => d4(w4)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t, id: a4 }), await h4()) : await Promise.all([new Promise(async (w4) => {
        await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i4, method: "wc_sessionRequest", params: { request: D3(I6({}, s2), { expiryTimestamp: Mt4(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m) => d4(m)), this.client.events.emit("session_request_sent", { topic: i4, request: s2, chainId: t, id: a4 }), w4();
      }), new Promise(async (w4) => {
        var m;
        if (!((m = n4.sessionConfig) != null && m.disableDeepLink)) {
          const y7 = await qt3(this.client.core.storage, xe);
          await Ft3({ id: a4, topic: i4, wcDeepLink: y7 });
        }
        w4();
      }), h4()]).then((w4) => w4[2]);
    }, this.respond = async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s2 } = e, { id: i4 } = s2, r3 = this.client.session.get(t);
      r3.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i4, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i4, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e);
    }, this.ping = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i4 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a4 } = _t4();
        this.events.once(Lt4("session_ping", s2), ({ error: c5 }) => {
          c5 ? a4(c5) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i4 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s2, chainId: i4 } = e, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i4 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: U5("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = S5("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => zr3(t, e))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i4 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i4 ? M6.link_mode : M6.relay;
      r3 === M6.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a4 = "", uri: c5, domain: h4, nonce: p4, type: d4, exp: l3, nbf: w4, methods: m = [], expiry: y7 } = e, _4 = [...e.resources || []], { topic: R4, uri: V7 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R4, uri: V7 } });
      const E3 = await this.client.core.crypto.generateKeyPair(), S8 = hr4(E3);
      if (await Promise.all([this.client.auth.authKeys.set(ae6, { responseTopic: S8, publicKey: E3 }), this.client.auth.pairingTopics.set(S8, { topic: S8, pairingTopic: R4 })]), await this.client.core.relayer.subscribe(S8, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R4}`), m.length > 0) {
        const { namespace: O6 } = re3(n4[0]);
        let T3 = ir3(O6, "request", m);
        Y2(_4) && (T3 = cr3(T3, _4.pop())), _4.push(T3);
      }
      const M7 = y7 && y7 > v5.wc_sessionAuthenticate.req.ttl ? y7 : v5.wc_sessionAuthenticate.req.ttl, W5 = { authPayload: { type: d4 ?? "caip122", chains: n4, statement: a4, aud: c5, domain: h4, version: "1", nonce: p4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l3, nbf: w4, resources: _4 }, requester: { publicKey: E3, metadata: this.client.metadata }, expiryTimestamp: Mt4(M7) }, N3 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m])], events: ["chainChanged", "accountsChanged"] } }, De4 = { requiredNamespaces: {}, optionalNamespaces: N3, relays: [{ protocol: "irn" }], pairingTopic: R4, proposer: { publicKey: E3, metadata: this.client.metadata }, expiryTimestamp: Mt4(v5.wc_sessionPropose.req.ttl) }, { done: wt4, resolve: Ve, reject: Ee6 } = _t4(M7, "Request expired"), ce4 = async ({ error: O6, session: T3 }) => {
        if (this.events.off(Lt4("session_request", G3), Re2), O6) Ee6(O6);
        else if (T3) {
          T3.self.publicKey = E3, await this.client.session.set(T3.topic, T3), await this.setExpiry(T3.topic, T3.expiry), R4 && await this.client.core.pairing.updateMetadata({ topic: R4, metadata: T3.peer.metadata });
          const le4 = this.client.session.get(T3.topic);
          await this.deleteProposal(Z6), Ve({ session: le4 });
        }
      }, Re2 = async (O6) => {
        var T3, le4, Me;
        if (await this.deletePendingAuthRequest(G3, { message: "fulfilled", code: 0 }), O6.error) {
          const te3 = U5("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O6.error.code === te3.code ? void 0 : (this.events.off(Lt4("session_connect"), ce4), Ee6(O6.error.message));
        }
        await this.deleteProposal(Z6), this.events.off(Lt4("session_connect"), ce4);
        const { cacaos: ke2, responder: j3 } = O6.result, Ie4 = [], $e2 = [];
        for (const te3 of ke2) {
          await nr3({ cacao: te3, projectId: this.client.core.projectId }) || (this.client.logger.error(te3, "Signature verification failed"), Ee6(U5("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe5 } = te3, ve5 = Y2(fe5.resources), Ke4 = [ln2(fe5.iss)], mt4 = fe3(fe5.iss);
          if (ve5) {
            const qe3 = ar3(ve5), _t6 = ur3(ve5);
            Ie4.push(...qe3), Ke4.push(..._t6);
          }
          for (const qe3 of Ke4) $e2.push(`${qe3}:${mt4}`);
        }
        const ee7 = await this.client.core.crypto.generateSharedKey(E3, j3.publicKey);
        let pe3;
        Ie4.length > 0 && (pe3 = { topic: ee7, acknowledged: true, self: { publicKey: E3, metadata: this.client.metadata }, peer: j3, controller: j3.publicKey, expiry: Mt4(z5), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R4, namespaces: Jr2([...new Set(Ie4)], [...new Set($e2)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee7, { transportType: r3 }), await this.client.session.set(ee7, pe3), R4 && await this.client.core.pairing.updateMetadata({ topic: R4, metadata: j3.metadata }), pe3 = this.client.session.get(ee7)), (T3 = this.client.metadata.redirect) != null && T3.linkMode && (le4 = j3.metadata.redirect) != null && le4.linkMode && (Me = j3.metadata.redirect) != null && Me.universal && t && (this.client.core.addLinkModeSupportedApp(j3.metadata.redirect.universal), this.client.session.update(ee7, { transportType: M6.link_mode })), Ve({ auths: ke2, session: pe3 });
      }, G3 = payloadId(), Z6 = payloadId();
      this.events.once(Lt4("session_connect"), ce4), this.events.once(Lt4("session_request", G3), Re2);
      let Se2;
      try {
        if (i4) {
          const O6 = formatJsonRpcRequest("wc_sessionAuthenticate", W5, G3);
          this.client.core.history.set(R4, O6);
          const T3 = await this.client.core.crypto.encode("", O6, { type: M5, encoding: lr3 });
          Se2 = xr3(t, R4, T3);
        } else await Promise.all([this.sendRequest({ topic: R4, method: "wc_sessionAuthenticate", params: W5, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: G3 }), this.sendRequest({ topic: R4, method: "wc_sessionPropose", params: De4, expiry: v5.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z6 })]);
      } catch (O6) {
        throw this.events.off(Lt4("session_connect"), ce4), this.events.off(Lt4("session_request", G3), Re2), O6;
      }
      return await this.setProposal(Z6, I6({ id: Z6 }, De4)), await this.setAuthRequest(G3, { request: D3(I6({}, W5), { verifyContext: {} }), pairingTopic: R4, transportType: r3 }), { uri: Se2 ?? V7, response: wt4 };
    }, this.approveSessionAuthenticate = async (e) => {
      const { id: t, auths: s2 } = e, i4 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Cs.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y7) {
        throw i4.setError(Ps.no_internet_connection), y7;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i4.setError(Ps.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || M6.relay;
      n4 === M6.relay && await this.confirmOnlineStateOrThrow();
      const a4 = r3.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h4 = hr4(a4), p4 = { type: D2, receiverPublicKey: a4, senderPublicKey: c5 }, d4 = [], l3 = [];
      for (const y7 of s2) {
        if (!await nr3({ cacao: y7, projectId: this.client.core.projectId })) {
          i4.setError(Ps.invalid_cacao);
          const S8 = U5("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h4, error: S8, encodeOpts: p4 }), new Error(S8.message);
        }
        i4.addTrace(Cs.cacaos_verified);
        const { p: _4 } = y7, R4 = Y2(_4.resources), V7 = [ln2(_4.iss)], E3 = fe3(_4.iss);
        if (R4) {
          const S8 = ar3(R4), M7 = ur3(R4);
          d4.push(...S8), V7.push(...M7);
        }
        for (const S8 of V7) l3.push(`${S8}:${E3}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(c5, a4);
      i4.addTrace(Cs.create_authenticated_session_topic);
      let m;
      if ((d4 == null ? void 0 : d4.length) > 0) {
        m = { topic: w4, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a4, metadata: r3.requester.metadata }, controller: a4, expiry: Mt4(z5), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: Jr2([...new Set(d4)], [...new Set(l3)]), transportType: n4 }, i4.addTrace(Cs.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: n4 });
        } catch (y7) {
          throw i4.setError(Ps.subscribe_authenticated_session_topic_failure), y7;
        }
        i4.addTrace(Cs.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m), i4.addTrace(Cs.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i4.addTrace(Cs.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h4, id: t, result: { cacaos: s2, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y7) {
        throw i4.setError(Ps.authenticated_session_approve_publish_failure), y7;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i4.eventId }), { session: m };
    }, this.rejectSessionAuthenticate = async (e) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e, i4 = this.getPendingAuthRequest(t);
      if (!i4) throw new Error(`Could not find pending auth request with id ${t}`);
      i4.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i4.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a4 = hr4(r3), c5 = { type: D2, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a4, error: s2, encodeOpts: c5, rpcOpts: v5.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i4.requester.metadata, i4.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, U5("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e;
      return dn2(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i4) => {
          var r3, n4;
          return ((r3 = i4.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i4.peerMetadata) == null ? void 0 : n4.url) === e.peer.metadata.url && i4.topic && i4.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e) => {
      var t;
      const { topic: s2, expirerHasDeleted: i4 = false, emitEvent: r3 = true, id: n4 = 0 } = e, { self: a4 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, U5("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a4.publicKey) && await this.client.core.crypto.deleteKeyPair(a4.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i4 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s2 && this.deletePendingSessionRequest(c5.id, U5("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x6.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e), i4 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i4 == null ? void 0 : i4.setError(Ts.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, U5("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }, this.deletePendingSessionRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== e), s2 && (this.sessionRequestQueue.state = x6.idle, this.client.events.emit("session_request_expire", { id: e }));
    }, this.deletePendingAuthRequest = async (e, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }, this.setExpiry = async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }, this.setProposal = async (e, t) => {
      this.client.core.expirer.set(e, Mt4(v5.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }, this.setAuthRequest = async (e, t) => {
      const { request: s2, pairingTopic: i4, transportType: r3 = M6.relay } = t;
      this.client.core.expirer.set(e, s2.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e, pairingTopic: i4, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e) => {
      const { id: t, topic: s2, params: i4, verifyContext: r3 } = e, n4 = i4.request.expiryTimestamp || Mt4(v5.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i4, verifyContext: r3 });
    }, this.sendRequest = async (e) => {
      const { topic: t, method: s2, params: i4, expiry: r3, relayRpcId: n4, clientRpcId: a4, throwOnFailedPublish: c5, appLink: h4 } = e, p4 = formatJsonRpcRequest(s2, i4, a4);
      let d4;
      const l3 = !!h4;
      try {
        const y7 = l3 ? lr3 : ge3;
        d4 = await this.client.core.crypto.encode(t, p4, { encoding: y7 });
      } catch (y7) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y7;
      }
      let w4;
      if (at6.includes(s2)) {
        const y7 = yr4(JSON.stringify(p4)), _4 = yr4(d4);
        w4 = await this.client.core.verify.register({ id: _4, decryptedId: y7 });
      }
      const m = v5[s2].req;
      if (m.attestation = w4, r3 && (m.ttl = r3), n4 && (m.id = n4), this.client.core.history.set(t, p4), l3) {
        const y7 = xr3(h4, t, d4);
        await global.Linking.openURL(y7, this.client.name);
      } else {
        const y7 = v5[s2].req;
        r3 && (y7.ttl = r3), n4 && (y7.id = n4), c5 ? (y7.internal = D3(I6({}, y7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d4, y7)) : this.client.core.relayer.publish(t, d4, y7).catch((_4) => this.client.logger.error(_4));
      }
      return p4.id;
    }, this.sendResult = async (e) => {
      const { id: t, topic: s2, result: i4, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a4 } = e, c5 = formatJsonRpcResult(t, i4);
      let h4;
      const p4 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l3 = p4 ? lr3 : ge3;
        h4 = await this.client.core.crypto.encode(s2, c5, D3(I6({}, n4 || {}), { encoding: l3 }));
      } catch (l3) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l3;
      }
      let d4;
      try {
        d4 = await this.client.core.history.get(s2, t);
      } catch (l3) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l3;
      }
      if (p4) {
        const l3 = xr3(a4, s2, h4);
        await global.Linking.openURL(l3, this.client.name);
      } else {
        const l3 = v5[d4.request.method].res;
        r3 ? (l3.internal = D3(I6({}, l3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h4, l3)) : this.client.core.relayer.publish(s2, h4, l3).catch((w4) => this.client.logger.error(w4));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e) => {
      const { id: t, topic: s2, error: i4, encodeOpts: r3, rpcOpts: n4, appLink: a4 } = e, c5 = formatJsonRpcError(t, i4);
      let h4;
      const p4 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l3 = p4 ? lr3 : ge3;
        h4 = await this.client.core.crypto.encode(s2, c5, D3(I6({}, r3 || {}), { encoding: l3 }));
      } catch (l3) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l3;
      }
      let d4;
      try {
        d4 = await this.client.core.history.get(s2, t);
      } catch (l3) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l3;
      }
      if (p4) {
        const l3 = xr3(a4, s2, h4);
        await global.Linking.openURL(l3, this.client.name);
      } else {
        const l3 = n4 || v5[d4.request.method].res;
        this.client.core.relayer.publish(s2, h4, l3);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i4 = false;
        Kt4(s2.expiry) && (i4 = true), this.client.core.crypto.keychain.has(s2.topic) || (i4 = true), i4 && e.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        Kt4(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x6.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x6.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = x6.idle;
    }, this.processRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i4, transportType: r3, encryptedId: n4 } = e, a4 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a4 })) switch (a4) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i4, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a4}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: t, payload: s2, transportType: i4 } = e, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i4);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e) => {
      const { topic: t } = e, { message: s2 } = S5("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e) => {
      const { topic: t, requestMethod: s2 } = e, i4 = this.expectedPairingMethodMap.get(t);
      return !i4 || i4.includes(s2) ? false : !!(i4.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e) => {
      const { topic: t, payload: s2, attestation: i4, encryptedId: r3 } = e, { params: n4, id: a4 } = s2;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I6({}, s2.params));
        const h4 = n4.expiryTimestamp || Mt4(v5.wc_sessionPropose.req.ttl), p4 = I6({ id: a4, pairingTopic: t, expiryTimestamp: h4 }, n4);
        await this.setProposal(a4, p4);
        const d4 = await this.getVerifyContext({ attestationId: i4, hash: yr4(JSON.stringify(s2)), encryptedId: r3, metadata: p4.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5 == null ? void 0 : c5.setError($4.proposal_listener_not_found)), c5 == null ? void 0 : c5.addTrace(z4.emit_session_proposal), this.client.events.emit("session_proposal", { id: a4, params: p4, verifyContext: d4 });
      } catch (c5) {
        await this.sendError({ id: a4, topic: t, error: c5, rpcOpts: v5.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e, t, s2) => {
      const { id: i4 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a4 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a4 });
        const c5 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h4 = await this.client.core.crypto.generateSharedKey(a4, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h4 });
        const p4 = await this.client.core.relayer.subscribe(h4, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p4 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i4, U5("USER_DISCONNECTED"));
        const r3 = Lt4("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Lt4("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e, t) => {
      const { id: s2, params: i4 } = t;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: r3, controller: n4, expiry: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p4 } = t.params, d4 = D3(I6(I6({ topic: e, relay: r3, expiry: a4, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h4 && { sessionProperties: h4 }), p4 && { sessionConfig: p4 }), { transportType: M6.relay }), l3 = Lt4("session_connect");
        if (this.events.listenerCount(l3) === 0) throw new Error(`emitting ${l3} without any listeners 997`);
        this.events.emit(Lt4("session_connect"), { session: d4 }), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(Lt4("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, U5("USER_DISCONNECTED")), this.events.emit(Lt4("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e, t) => {
      const { params: s2, id: i4 } = t;
      try {
        const r3 = `${e}_session_update`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i4)) {
          this.client.logger.info(`Discarding out of sync request - ${i4}`), this.sendError({ id: i4, topic: e, error: U5("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I6({ topic: e }, s2));
        try {
          yo.set(r3, i4), await this.client.session.update(e, { namespaces: s2.namespaces }), await this.sendResult({ id: i4, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a4) {
          throw yo.delete(r3), a4;
        }
        this.client.events.emit("session_update", { id: i4, topic: e, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i4, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt4("session_update", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt4("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt4("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Mt4(z5)), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e, error: i4 }), this.client.logger.error(i4);
      }
    }, this.onSessionExtendResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt4("session_extend", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt4("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt4("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e });
      } catch (i4) {
        await this.sendError({ id: s2, topic: e, error: i4 }), this.client.logger.error(i4);
      }
    }, this.onSessionPingResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt4("session_ping", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Lt4("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Lt4("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(v4.publish, async () => {
            i4(await this.deleteSession({ topic: e, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: U5("USER_DISCONNECTED") })]).catch((i4) => this.client.logger.error(i4));
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }, this.onSessionRequest = async (e) => {
      var t, s2, i4;
      const { topic: r3, payload: n4, attestation: a4, encryptedId: c5, transportType: h4 } = e, { id: p4, params: d4 } = n4;
      try {
        await this.isValidRequest(I6({ topic: r3 }, d4));
        const l3 = this.client.session.get(r3), w4 = await this.getVerifyContext({ attestationId: a4, hash: yr4(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d4, p4))), encryptedId: c5, metadata: l3.peer.metadata, transportType: h4 }), m = { id: p4, topic: r3, params: d4, verifyContext: w4 };
        await this.setPendingSessionRequest(m), h4 === M6.link_mode && (t = l3.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l3.peer.metadata.redirect) == null ? void 0 : s2.universal), (i4 = this.client.signConfig) != null && i4.disableRequestQueue ? this.emitSessionRequest(m) : (this.addSessionRequestToSessionRequestQueue(m), this.processSessionRequestQueue());
      } catch (l3) {
        await this.sendError({ id: p4, topic: r3, error: l3 }), this.client.logger.error(l3);
      }
    }, this.onSessionRequestResponse = (e, t) => {
      const { id: s2 } = t, i4 = Lt4("session_request", s2);
      if (this.events.listenerCount(i4) === 0) throw new Error(`emitting ${i4} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Lt4("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt4("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e, t) => {
      const { id: s2, params: i4 } = t;
      try {
        const r3 = `${e}_session_event_${i4.event.name}`, n4 = yo.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I6({ topic: e }, i4)), this.client.events.emit("session_event", { id: s2, topic: e, params: i4 }), yo.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(Lt4("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Lt4("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e) => {
      var t;
      const { topic: s2, payload: i4, attestation: r3, encryptedId: n4, transportType: a4 } = e;
      try {
        const { requester: c5, authPayload: h4, expiryTimestamp: p4 } = i4.params, d4 = await this.getVerifyContext({ attestationId: r3, hash: yr4(JSON.stringify(i4)), encryptedId: n4, metadata: c5.metadata, transportType: a4 }), l3 = { requester: c5, pairingTopic: s2, id: i4.id, authPayload: h4, verifyContext: d4, expiryTimestamp: p4 };
        await this.setAuthRequest(i4.id, { request: l3, pairingTopic: s2, transportType: a4 }), a4 === M6.link_mode && (t = c5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i4.params, id: i4.id, verifyContext: d4 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h4 = i4.params.requester.publicKey, p4 = await this.client.core.crypto.generateKeyPair(), d4 = this.getAppLinkIfEnabled(i4.params.requester.metadata, a4), l3 = { type: D2, receiverPublicKey: h4, senderPublicKey: p4 };
        await this.sendError({ id: i4.id, topic: s2, error: c5, encodeOpts: l3, rpcOpts: v5.wc_sessionAuthenticate.autoReject, appLink: d4 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e) => {
      this.sessionRequestQueue.queue.push(e);
    }, this.cleanupAfterResponse = (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x6.idle, this.processSessionRequestQueue();
      }, (0, import_time7.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i4) => i4.topic === e && i4.request.method === "wc_sessionRequest").forEach((i4) => {
        const r3 = i4.request.id, n4 = Lt4("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Lt4("session_request", i4.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x6.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x6.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onPairingCreated = (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e) => {
      if (!to2(e)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(a4);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i4, sessionProperties: r3, relays: n4 } = e;
      if (I4(t) || await this.isValidPairingTopic(t), !eo(n4, true)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a4);
      }
      !I4(s2) && Z3(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !I4(i4) && Z3(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), I4(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e, t) => {
      const s2 = Xr2(e, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e) => {
      if (!to2(e)) throw new Error(S5("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s2, relayProtocol: i4, sessionProperties: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a4 = Wn(s2, "approve()");
      if (a4) throw new Error(a4.message);
      const c5 = zn(n4.requiredNamespaces, s2, "approve()");
      if (c5) throw new Error(c5.message);
      if (!b2(i4, true)) {
        const { message: h4 } = S5("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(h4);
      }
      I4(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e) => {
      if (!to2(e)) {
        const { message: i4 } = S5("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i4);
      }
      const { id: t, reason: s2 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !ro(s2)) {
        const { message: i4 } = S5("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i4);
      }
    }, this.isValidSessionSettleRequest = (e) => {
      if (!to2(e)) {
        const { message: c5 } = S5("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(c5);
      }
      const { relay: t, controller: s2, namespaces: i4, expiry: r3 } = e;
      if (!Jn(t)) {
        const { message: c5 } = S5("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n4 = Zr2(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a4 = Wn(i4, "onSessionSettleRequest()");
      if (a4) throw new Error(a4.message);
      if (Kt4(r3)) {
        const { message: c5 } = S5("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e) => {
      if (!to2(e)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a4);
      }
      const { topic: t, namespaces: s2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i4 = this.client.session.get(t), r3 = Wn(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = zn(i4.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e) => {
      if (!to2(e)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a4);
      }
      const { topic: t, request: s2, chainId: i4, expiry: r3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!co(n4, i4)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a4);
      }
      if (!oo(s2)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a4);
      }
      if (!ao(n4, i4, s2.method)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a4);
      }
      if (r3 && !po2(r3, me5)) {
        const { message: a4 } = S5("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me5.min} and ${me5.max}`);
        throw new Error(a4);
      }
    }, this.isValidRespond = async (e) => {
      var t;
      if (!to2(e)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i4 } = e;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r3;
      }
      if (!so(i4)) {
        const { message: r3 } = S5("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i4)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e) => {
      if (!to2(e)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i4 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!co(r3, i4)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(n4);
      }
      if (!io(s2)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!uo(r3, i4, s2.name)) {
        const { message: n4 } = S5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e) => {
      if (!to2(e)) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e) => {
      const { chains: t, uri: s2, domain: i4, nonce: r3 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!b2(s2, false)) throw new Error("uri is required parameter");
      if (!b2(i4, false)) throw new Error("domain is required parameter");
      if (!b2(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a4) => re3(a4).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = re3(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e) => {
      const { attestationId: t, hash: s2, encryptedId: i4, metadata: r3, transportType: n4 } = e, a4 = { verified: { verifyUrl: r3.verifyUrl || J2, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === M6.link_mode) {
          const h4 = this.getAppLinkIfEnabled(r3, n4);
          return a4.verified.validation = h4 && new URL(h4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a4;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i4, verifyUrl: r3.verifyUrl });
        c5 && (a4.verified.origin = c5.origin, a4.verified.isScam = c5.isScam, a4.verified.validation = c5.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a4)}`), a4;
    }, this.validateSessionProps = (e, t) => {
      Object.values(e).forEach((s2) => {
        if (!b2(s2, false)) {
          const { message: i4 } = S5("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i4);
        }
      });
    }, this.getPendingAuthRequest = (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i4 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i4) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s2 } = S5("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e, t) => {
      var s2, i4, r3, n4, a4, c5, h4, p4, d4;
      return !e || t !== M6.link_mode ? false : ((i4 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i4.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c5 = (a4 = this.client.metadata) == null ? void 0 : a4.redirect) == null ? void 0 : c5.universal) !== "" && ((h4 = e == null ? void 0 : e.redirect) == null ? void 0 : h4.universal) !== void 0 && ((p4 = e == null ? void 0 : e.redirect) == null ? void 0 : p4.universal) !== "" && ((d4 = e == null ? void 0 : e.redirect) == null ? void 0 : d4.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e, t) => {
      var s2;
      return this.isLinkModeEnabled(e, t) ? (s2 = e == null ? void 0 : e.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Bt3(e, "topic") || "", s2 = decodeURIComponent(Bt3(e, "wc_ev") || ""), i4 = this.client.session.keys.includes(t);
      i4 && this.client.session.update(t, { transportType: M6.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i4 });
    }, this.registerLinkModeListeners = async () => {
      var e;
      if (Wt4() || _2() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o4 } = S5("NOT_INITIALIZED", this.name);
      throw new Error(o4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v4.message, (o4) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o4) : this.onRelayMessage(o4);
    });
  }
  async onRelayMessage(o4) {
    const { topic: e, message: t, attestation: s2, transportType: i4 } = o4, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae6) ? this.client.auth.authKeys.get(ae6) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r3, encoding: i4 === M6.link_mode ? lr3 : ge3 });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e, n4), this.onRelayEventRequest({ topic: e, payload: n4, attestation: s2, transportType: i4, encryptedId: yr4(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e, payload: n4, transportType: i4 }), this.client.core.history.delete(e, n4.id)) : this.onRelayEventUnknownPayload({ topic: e, payload: n4, transportType: i4 });
    } catch (a4) {
      this.client.logger.error(a4);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(S6.expired, async (o4) => {
      const { topic: e, id: t } = Vt4(o4.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, S5("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, S5("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V5.create, (o4) => this.onPairingCreated(o4)), this.client.core.pairing.events.on(V5.delete, (o4) => {
      this.addToRecentlyDeleted(o4.topic, "pairing");
    });
  }
  isValidPairingTopic(o4) {
    if (!b2(o4, false)) {
      const { message: e } = S5("MISSING_OR_INVALID", `pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt4(this.client.core.pairing.pairings.get(o4).expiry)) {
      const { message: e } = S5("EXPIRED", `pairing topic: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(o4) {
    if (!b2(o4, false)) {
      const { message: e } = S5("MISSING_OR_INVALID", `session topic should be a string: ${o4}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(o4), !this.client.session.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `session topic doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt4(this.client.session.get(o4).expiry)) {
      await this.deleteSession({ topic: o4 });
      const { message: e } = S5("EXPIRED", `session topic: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(o4)) {
      const { message: e } = S5("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o4}`);
      throw await this.deleteSession({ topic: o4 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(o4) {
    if (this.checkRecentlyDeleted(o4), this.client.session.keys.includes(o4)) await this.isValidSessionTopic(o4);
    else if (this.client.core.pairing.pairings.keys.includes(o4)) this.isValidPairingTopic(o4);
    else if (b2(o4, false)) {
      const { message: e } = S5("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o4}`);
      throw new Error(e);
    } else {
      const { message: e } = S5("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o4}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(o4) {
    if (!no(o4)) {
      const { message: e } = S5("MISSING_OR_INVALID", `proposal id should be a number: ${o4}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(o4)) {
      const { message: e } = S5("NO_MATCHING_KEY", `proposal id doesn't exist: ${o4}`);
      throw new Error(e);
    }
    if (Kt4(this.client.proposal.get(o4).expiryTimestamp)) {
      await this.deleteProposal(o4);
      const { message: e } = S5("EXPIRED", `proposal id: ${o4}`);
      throw new Error(e);
    }
  }
};
var Ss3 = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, st6, ye6), this.core = o4, this.logger = e;
  }
};
var yt4 = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, rt4, ye6), this.core = o4, this.logger = e;
  }
};
var Is2 = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, ot4, ye6, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var fs = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, pt4, oe4, () => ae6), this.core = o4, this.logger = e;
  }
};
var vs3 = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, ht4, oe4), this.core = o4, this.logger = e;
  }
};
var qs3 = class extends ni2 {
  constructor(o4, e) {
    super(o4, e, dt4, oe4, (t) => t.id), this.core = o4, this.logger = e;
  }
};
var Ts2 = class {
  constructor(o4, e) {
    this.core = o4, this.logger = e, this.authKeys = new fs(this.core, this.logger), this.pairingTopics = new vs3(this.core, this.logger), this.requests = new qs3(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e5 = class __e extends S4 {
  constructor(o4) {
    super(o4), this.protocol = be6, this.version = Ce6, this.name = we6.name, this.events = new import_events11.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i4) {
        throw this.logger.error(i4.message), i4;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o4 == null ? void 0 : o4.name) || we6.name, this.metadata = (o4 == null ? void 0 : o4.metadata) || Nt4(), this.signConfig = o4 == null ? void 0 : o4.signConfig;
    const e = typeof (o4 == null ? void 0 : o4.logger) < "u" && typeof (o4 == null ? void 0 : o4.logger) != "string" ? o4.logger : (0, import_pino.default)(k({ level: (o4 == null ? void 0 : o4.logger) || we6.logger }));
    this.core = (o4 == null ? void 0 : o4.core) || new bn3(o4), this.logger = E(e, this.name), this.session = new yt4(this.core, this.logger), this.proposal = new Ss3(this.core, this.logger), this.pendingRequest = new Is2(this.core, this.logger), this.engine = new Rs3(this), this.auth = new Ts2(this.core, this.logger);
  }
  static async init(o4) {
    const e = new __e(o4);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o4.message), o4;
    }
  }
};
var Ns3 = yt4;
var Ps2 = _e5;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l2 = { exports: {} };
var c4 = typeof Reflect == "object" ? Reflect : null;
var y6 = c4 && typeof c4.apply == "function" ? c4.apply : function(t, e, n4) {
  return Function.prototype.apply.call(t, e, n4);
};
var f4;
c4 && typeof c4.ownKeys == "function" ? f4 = c4.ownKeys : Object.getOwnPropertySymbols ? f4 = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f4 = function(t) {
  return Object.getOwnPropertyNames(t);
};
function k4(s2) {
  console && console.warn && console.warn(s2);
}
var w3 = Number.isNaN || function(t) {
  return t !== t;
};
function o3() {
  o3.init.call(this);
}
l2.exports = o3, l2.exports.once = K4, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
var L4 = 10;
function g5(s2) {
  if (typeof s2 != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s2);
}
Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
  return L4;
}, set: function(s2) {
  if (typeof s2 != "number" || s2 < 0 || w3(s2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s2 + ".");
  L4 = s2;
} }), o3.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o3.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w3(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _3(s2) {
  return s2._maxListeners === void 0 ? o3.defaultMaxListeners : s2._maxListeners;
}
o3.prototype.getMaxListeners = function() {
  return _3(this);
}, o3.prototype.emit = function(t) {
  for (var e = [], n4 = 1; n4 < arguments.length; n4++) e.push(arguments[n4]);
  var i4 = t === "error", a4 = this._events;
  if (a4 !== void 0) i4 = i4 && a4.error === void 0;
  else if (!i4) return false;
  if (i4) {
    var r3;
    if (e.length > 0 && (r3 = e[0]), r3 instanceof Error) throw r3;
    var h4 = new Error("Unhandled error." + (r3 ? " (" + r3.message + ")" : ""));
    throw h4.context = r3, h4;
  }
  var u3 = a4[t];
  if (u3 === void 0) return false;
  if (typeof u3 == "function") y6(u3, this, e);
  else for (var d4 = u3.length, M7 = O5(u3, d4), n4 = 0; n4 < d4; ++n4) y6(M7[n4], this, e);
  return true;
};
function S7(s2, t, e, n4) {
  var i4, a4, r3;
  if (g5(e), a4 = s2._events, a4 === void 0 ? (a4 = s2._events = /* @__PURE__ */ Object.create(null), s2._eventsCount = 0) : (a4.newListener !== void 0 && (s2.emit("newListener", t, e.listener ? e.listener : e), a4 = s2._events), r3 = a4[t]), r3 === void 0) r3 = a4[t] = e, ++s2._eventsCount;
  else if (typeof r3 == "function" ? r3 = a4[t] = n4 ? [e, r3] : [r3, e] : n4 ? r3.unshift(e) : r3.push(e), i4 = _3(s2), i4 > 0 && r3.length > i4 && !r3.warned) {
    r3.warned = true;
    var h4 = new Error("Possible EventEmitter memory leak detected. " + r3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h4.name = "MaxListenersExceededWarning", h4.emitter = s2, h4.type = t, h4.count = r3.length, k4(h4);
  }
  return s2;
}
o3.prototype.addListener = function(t, e) {
  return S7(this, t, e, false);
}, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(t, e) {
  return S7(this, t, e, true);
};
function D4() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C5(s2, t, e) {
  var n4 = { fired: false, wrapFn: void 0, target: s2, type: t, listener: e }, i4 = D4.bind(n4);
  return i4.listener = e, n4.wrapFn = i4, i4;
}
o3.prototype.once = function(t, e) {
  return g5(e), this.on(t, C5(this, t, e)), this;
}, o3.prototype.prependOnceListener = function(t, e) {
  return g5(e), this.prependListener(t, C5(this, t, e)), this;
}, o3.prototype.removeListener = function(t, e) {
  var n4, i4, a4, r3, h4;
  if (g5(e), i4 = this._events, i4 === void 0) return this;
  if (n4 = i4[t], n4 === void 0) return this;
  if (n4 === e || n4.listener === e) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i4[t], i4.removeListener && this.emit("removeListener", t, n4.listener || e));
  else if (typeof n4 != "function") {
    for (a4 = -1, r3 = n4.length - 1; r3 >= 0; r3--) if (n4[r3] === e || n4[r3].listener === e) {
      h4 = n4[r3].listener, a4 = r3;
      break;
    }
    if (a4 < 0) return this;
    a4 === 0 ? n4.shift() : F5(n4, a4), n4.length === 1 && (i4[t] = n4[0]), i4.removeListener !== void 0 && this.emit("removeListener", t, h4 || e);
  }
  return this;
}, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(t) {
  var e, n4, i4;
  if (n4 = this._events, n4 === void 0) return this;
  if (n4.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n4[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[t]), this;
  if (arguments.length === 0) {
    var a4 = Object.keys(n4), r3;
    for (i4 = 0; i4 < a4.length; ++i4) r3 = a4[i4], r3 !== "removeListener" && this.removeAllListeners(r3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = n4[t], typeof e == "function") this.removeListener(t, e);
  else if (e !== void 0) for (i4 = e.length - 1; i4 >= 0; i4--) this.removeListener(t, e[i4]);
  return this;
};
function b4(s2, t, e) {
  var n4 = s2._events;
  if (n4 === void 0) return [];
  var i4 = n4[t];
  return i4 === void 0 ? [] : typeof i4 == "function" ? e ? [i4.listener || i4] : [i4] : e ? z6(i4) : O5(i4, i4.length);
}
o3.prototype.listeners = function(t) {
  return b4(this, t, true);
}, o3.prototype.rawListeners = function(t) {
  return b4(this, t, false);
}, o3.listenerCount = function(s2, t) {
  return typeof s2.listenerCount == "function" ? s2.listenerCount(t) : E2.call(s2, t);
}, o3.prototype.listenerCount = E2;
function E2(s2) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s2];
    if (typeof e == "function") return 1;
    if (e !== void 0) return e.length;
  }
  return 0;
}
o3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f4(this._events) : [];
};
function O5(s2, t) {
  for (var e = new Array(t), n4 = 0; n4 < t; ++n4) e[n4] = s2[n4];
  return e;
}
function F5(s2, t) {
  for (; t + 1 < s2.length; t++) s2[t] = s2[t + 1];
  s2.pop();
}
function z6(s2) {
  for (var t = new Array(s2.length), e = 0; e < t.length; ++e) t[e] = s2[e].listener || s2[e];
  return t;
}
function K4(s2, t) {
  return new Promise(function(e, n4) {
    function i4(r3) {
      s2.removeListener(t, a4), n4(r3);
    }
    function a4() {
      typeof s2.removeListener == "function" && s2.removeListener("error", i4), e([].slice.call(arguments));
    }
    R3(s2, t, a4, { once: true }), t !== "error" && U7(s2, i4, { once: true });
  });
}
function U7(s2, t, e) {
  typeof s2.on == "function" && R3(s2, "error", t, e);
}
function R3(s2, t, e, n4) {
  if (typeof s2.on == "function") n4.once ? s2.once(t, e) : s2.on(t, e);
  else if (typeof s2.addEventListener == "function") s2.addEventListener(t, function i4(a4) {
    n4.once && s2.removeEventListener(t, i4), e(a4);
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s2);
}
var A4 = "wc";
var p3 = "Web3Wallet";
var $6 = `${A4}@2:${p3}:`;
var Q4 = class extends l2.exports {
  constructor() {
    super();
  }
};
var x7 = class {
  constructor(t) {
    this.opts = t;
  }
};
var P5 = class {
  constructor(t) {
    this.client = t;
  }
};
var V6 = Object.defineProperty;
var B6 = Object.defineProperties;
var J3 = Object.getOwnPropertyDescriptors;
var q5 = Object.getOwnPropertySymbols;
var Y3 = Object.prototype.hasOwnProperty;
var Z5 = Object.prototype.propertyIsEnumerable;
var j2 = (s2, t, e) => t in s2 ? V6(s2, t, { enumerable: true, configurable: true, writable: true, value: e }) : s2[t] = e;
var ee6 = (s2, t) => {
  for (var e in t || (t = {})) Y3.call(t, e) && j2(s2, e, t[e]);
  if (q5) for (var e of q5(t)) Z5.call(t, e) && j2(s2, e, t[e]);
  return s2;
};
var te2 = (s2, t) => B6(s2, J3(t));
var se4 = class extends P5 {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await Ps2.init({ core: this.client.core, metadata: this.client.metadata, signConfig: this.client.signConfig }), this.authClient = await zr2.init({ core: this.client.core, projectId: "", metadata: this.client.metadata });
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: n4, acknowledged: i4 } = await this.signClient.approve(te2(ee6({}, e), { id: e.id, namespaces: e.namespaces, sessionProperties: e.sessionProperties, sessionConfig: e.sessionConfig }));
      return await i4(), this.signClient.session.get(n4);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await this.signClient.update(e), this.extendSession = async (e) => await this.signClient.extend(e), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, n4) => (e[n4.topic] = n4, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, n4) => await this.authClient.respond(e, n4), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, n4) => this.authClient.formatMessage(e, n4), this.approveSessionAuthenticate = async (e) => await this.signClient.approveSessionAuthenticate(e), this.rejectSessionAuthenticate = async (e) => await this.signClient.rejectSessionAuthenticate(e), this.formatAuthMessage = (e) => this.signClient.formatAuthMessage(e), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.on = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "on"), this.client.events.on(e, n4)), this.once = (e, n4) => (this.setEvent(e, "off"), this.setEvent(e, "once"), this.client.events.once(e, n4)), this.off = (e, n4) => (this.setEvent(e, "off"), this.client.events.off(e, n4)), this.removeListener = (e, n4) => (this.setEvent(e, "removeListener"), this.client.events.removeListener(e, n4)), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.onSessionRequestAuthenticate = (e) => {
      this.client.events.emit("session_authenticate", e);
    }, this.setEvent = (e, n4) => {
      switch (e) {
        case "session_request":
          this.signClient.events[n4]("session_request", this.onSessionRequest);
          break;
        case "session_proposal":
          this.signClient.events[n4]("session_proposal", this.onSessionProposal);
          break;
        case "session_delete":
          this.signClient.events[n4]("session_delete", this.onSessionDelete);
          break;
        case "auth_request":
          this.authClient[n4]("auth_request", this.onAuthRequest);
          break;
        case "proposal_expire":
          this.signClient.events[n4]("proposal_expire", this.onProposalExpire);
          break;
        case "session_request_expire":
          this.signClient.events[n4]("session_request_expire", this.onSessionRequestExpire);
          break;
        case "session_authenticate":
          this.signClient.events[n4]("session_authenticate", this.onSessionRequestAuthenticate);
          break;
      }
    }, this.signClient = {}, this.authClient = {};
  }
};
var ne6 = { decryptMessage: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(s2.topic, s2.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (s2) => {
  const t = { core: new bn3({ storageOptions: s2.storageOptions, storage: s2.storage }), sessionStore: null };
  t.sessionStore = new Ns3(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(s2.topic), n4 = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, n4;
} };
var T2 = class extends x7 {
  constructor(s2) {
    super(s2), this.events = new l2.exports(), this.on = (t, e) => this.engine.on(t, e), this.once = (t, e) => this.engine.once(t, e), this.off = (t, e) => this.engine.off(t, e), this.removeListener = (t, e) => this.engine.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (n4) {
        throw this.logger.error(n4.message), n4;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSessionAuthenticate = (t) => {
      try {
        return this.engine.approveSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSessionAuthenticate = (t) => {
      try {
        return this.engine.rejectSessionAuthenticate(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = s2.metadata, this.name = s2.name || p3, this.signConfig = s2.signConfig, this.core = s2.core, this.logger = this.core.logger, this.engine = new se4(this);
  }
  static async init(s2) {
    const t = new T2(s2);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (s2) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(s2.message), s2;
    }
  }
};
var v6 = T2;
v6.notifications = ne6;
var ie4 = v6;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-fbb7ab15.browser.esm.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-a72d5b10.browser.esm.js
var import_dist37 = __toESM(require_dist());
var import_dist38 = __toESM(require_dist2());
var import_dist39 = __toESM(require_dist3());
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId,
      ...getAnalyticsHeaders()
    },
    body: JSON.stringify(body)
  });
}
var AbstractClientWallet = class extends AbstractWallet {
  /**
   * @internal
   */
  /**
   * @internal
   */
  getMeta() {
    return this.constructor.meta;
  }
  /**
   * Creates an returns instance of `AbstractClientWallet`
   *
   * @param walletId - A Unique identifier for the wallet ( name of the wallet )
   * @param options - Options for creating wallet instance
   */
  constructor(walletId, options) {
    super();
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c5) => updateChainRPCs(c5, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  /**
   * Returns the Wallet Connector used by the wallet
   */
  /**
   * auto-connect the wallet if possible
   * @returns
   */
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return this._connect(true, options);
  }
  /**
   * Connect wallet
   * @param connectOptions - Options for connecting to the wallet
   * @returns
   */
  async connect(connectOptions) {
    this._connectParams = connectOptions;
    const address = await this._connect(false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  /**
   * @internal
   * Get the options used for connecting to the wallet
   * @returns
   */
  getConnectParams() {
    return this._connectParams;
  }
  /**
   * @internal
   * Get the options used for creating the wallet instance
   */
  getOptions() {
    return this.options;
  }
  async _connect(isAutoConnect, connectOptions) {
    const connector = await this.getConnector();
    this._subscribeToEvents(connector);
    const isConnected = await connector.isConnected();
    if (isConnected) {
      const address = await connector.getAddress();
      connector.setupListeners();
      if (connectOptions == null ? void 0 : connectOptions.chainId) {
        await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
      }
      this.emit("connect", {
        address,
        chainId: await this.getChainId()
      });
      this._trackConnection(address);
      return address;
    }
    if (isAutoConnect) {
      throw new Error("Failed to auto connect to the wallet.");
    }
    try {
      const address = await connector.connect(connectOptions);
      this._trackConnection(address);
      return address;
    } catch (error) {
      throw new Error(error.message);
    }
  }
  _trackConnection(address) {
    var _a;
    track({
      clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
      source: "connectWallet",
      action: "connect",
      walletType: this.walletId,
      walletAddress: address
    });
  }
  async _subscribeToEvents(connector) {
    connector.on("connect", (data) => {
      var _a;
      this.emit("connect", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("change", (data) => {
      var _a;
      this.emit("change", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("message", (data) => {
      this.emit("message", data);
    });
    connector.on("disconnect", async () => {
      this.emit("disconnect");
    });
    connector.on("error", (error) => this.emit("error", error));
  }
  /**
   * Get [ethers Signer](https://docs.ethers.org/v5/api/signer/) object of the connected wallet
   */
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  /**
   * Switch to different Network/Blockchain in the connected wallet
   * @param chainId - The chainId of the network to switch to
   */
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  /**
   * Update the chains supported by the wallet. This is useful if wallet was initialized with some chains and this needs to be updated without re-initializing the wallet
   */
  async updateChains(chains) {
    this.chains = chains.map((c5) => {
      var _a;
      return updateChainRPCs(c5, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  /**
   * If the wallet uses another "personal wallet" under the hood, return it
   *
   * This is only useful for wallets like Safe or Smart Wallet uses a "personal wallet" under the hood to sign transactions. This method returns that wallet
   */
  getPersonalWallet() {
    return void 0;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
var import_dist40 = __toESM(require_dist());
var import_dist41 = __toESM(require_dist2());
var import_dist42 = __toESM(require_dist3());
init_lib3();
var BloctoWallet = class _BloctoWallet extends AbstractClientWallet {
  /**
   * Create a `BloctoWallet` instance
   * @param options - The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### appId (recommended)
   * To get advanced features and support from Blocto, you can create an appId from [blocto dashboard](https://docs.blocto.app/blocto-sdk/register-app-id)
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { BloctoWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new BloctoWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### chain (optional)
   * The Network to connect the wallet to. Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(_BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  /**
   * @internal
   */
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-ASKXFOGU.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
var import_dist43 = __toESM(require_dist());
var import_dist44 = __toESM(require_dist2());
var import_dist45 = __toESM(require_dist3());
init_lib3();
var EmbeddedWallet = class _EmbeddedWallet extends AbstractClientWallet {
  /**
   * Sends a verification email to the provided email address.
   *
   * @param email - The email address to which the verification email will be sent.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * EmbeddedWallet.sendVerificationEmail({ email: 'test@example.com', clientId: 'yourClientId' })
   *   .then(() => console.log('Verification email sent successfully.'))
   *   .catch(error => console.error('Failed to send verification email:', error));
   * ```
   */
  static async sendVerificationEmail(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  /**
   * Sends a verification sms to the provider phone number.
   *
   * @param phoneNumber - The phone number to which the verification sms will be sent. The phone number must contain the country code.
   * @param clientId - Your thirdweb client ID
   * @returns Information on the user's status and whether they are a new user.
   *
   * @example
   * ```typescript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  phoneNumber: '+1234567890',
   *  clientId: 'yourClientId'
   * });
   * ```
   */
  static async sendVerificationSms(options) {
    const wallet = new _EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationSms({
      phoneNumber: options.phoneNumber
    });
  }
  /**
   * @internal
   */
  get walletName() {
    return "Embedded Wallet";
  }
  /**
   * @internal
   */
  /**
   * The options for instantiating an `EmbeddedWallet`
   *
   * @param options -
   * The options object contains the following properties:
   *
   * ### clientId (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### chain (required)
   * The chain to connect to by default.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   */
  constructor(options) {
    super(_EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-R6JIIUL6.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: ((_a = this.options) == null ? void 0 : _a.clientId) ?? "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_b = this.options) == null ? void 0 : _b.onAuthSuccess
      });
    }
    return this.connector;
  }
  /**
   * auto connect the wallet if the wallet was previously connected and session is still valid
   */
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  /**
   * @internal
   */
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  /**
   * Get the email associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getEmail();
   * ```
   */
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  /**
   * Get the phone number associated with the currently connected wallet.
   * @example
   * ```ts
   * ```javascript
   * const email = await wallet.getPhoneNumber();
   * ```
   */
  async getPhoneNumber() {
    const connector = await this.getConnector();
    return connector.getPhoneNumber();
  }
  /**
   * Get the instance of `EmbeddedWalletSdk` used by the wallet.
   */
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  // TODO move to connect/auth callback
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  /**
   * Send a verification code to the user's email for verification.
   * Use this as a prestep before calling `authenticate` with the `email_verification` strategy.
   *
   * ```javascript
   * const result = await wallet.sendVerificationEmail({
   *   email: "alice@example.com",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationEmail({
   *  email: "alice@example.com",
   * })
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### email (required)
   * The email address to send verification email to.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   *
   */
  async sendVerificationEmail(options) {
    const {
      email
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  /**
   * Send a verification code to the user's phone number for verification. The phone number must contain the country code.
   * Use this as a pre-step before calling `authenticate` with the `phone_number_verification` strategy.
   *
   * ```js
   * const result = await wallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * This method is also available as a static method on the `EmbeddedWallet` class.
   * ```javascript
   * const result = await EmbeddedWallet.sendVerificationSms({
   *   phoneNumber: "+1234567890",
   * });
   * ```
   *
   * @param options - The `options` object contains the following properties:
   * ### phoneNumber (required)
   * The phone number to send verification SMS to. The phone number must contain the country code.
   *
   * @returns object containing below properties:
   *
   * ```ts
   * {
   *  isNewDevice: boolean;
   *  isNewUser: boolean;
   *  recoveryShareManagement: "USER_MANAGED" | "AWS_MANAGED";
   * }
   * ```
   *
   * ### isNewDevice
   * If user has not logged in from this device before, this will be true.
   *
   * ### isNewUser
   * If user is logging in for the first time, this will be true.
   *
   * ### recoveryShareManagement
   * Recovery share management type. Can be either `USER_MANAGED` or `AWS_MANAGED`.
   */
  async sendVerificationSms(options) {
    const {
      phoneNumber
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationSms({
      phoneNumber
    });
  }
  /**
   * Authenticate the user with any of the available auth strategies.
   *
   * @example
   * ```javascript
   * const authResult = await wallet.authenticate({
   *   strategy: "google",
   * });
   * ```
   *
   * @param params -
   * Choose one of the available auth strategy, which comes with different required arguments.
   * ```ts
   * // email verification
   * type EmailVerificationAuthParams = {
   *   strategy: "email_verification";
   *   email: string;
   *   verificationCode: string;
   *   recoveryCode?: string;
   * };
   *
   * export type EmbeddedWalletOauthStrategy = "google" | "apple" | "facebook";
   *
   * type OauthAuthParams = {
   *   strategy: EmbeddedWalletOauthStrategy;
   *   openedWindow?: Window;
   *   closeOpenedWindow?: (window: Window) => void;
   * };
   *
   * // bring your own authentication
   * type JwtAuthParams = {
   *   strategy: "jwt";
   *   jwt: string;
   *   encryptionKey?: string;
   * };
   *
   * // open iframe to send and input the verification code only
   * type IframeOtpAuthParams = {
   *   strategy: "iframe_email_verification";
   *   email: string;
   * };
   *
   * // open iframe to enter email and verification code
   * type IframeAuthParams = {
   *   strategy: "iframe";
   * };
   * ```
   *
   * @returns
   * The `authResult` object - which you can pass to the `connect` method to connect to the wallet.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   * await wallet.connect({ authResult });
   * ```
   */
  async authenticate(params) {
    const connector = await this.getConnector();
    const authResult = connector.authenticate(params);
    try {
      await this.walletStorage.setItem(LAST_USED_AUTH_STRATEGY, params.strategy);
    } catch {
    }
    return authResult;
  }
  /**
   * @internal
   */
  async getLastUsedAuthStrategy() {
    try {
      return await this.walletStorage.getItem(LAST_USED_AUTH_STRATEGY);
    } catch {
      return null;
    }
  }
  /**
   * After authenticating, you can connect to the wallet by passing the `authResult` to the `connect` method.
   *
   * ```ts
   * const authResult = await wallet.authenticate(authOptions);
   *
   * await wallet.connect({ authResult });
   * ```
   *
   * @param connectOptions - The `connectOptions` object contains the following properties:
   *
   * ### authResult (required)
   *
   * The `authResult` object is returned from the `authenticate` method.
   *
   * @returns The address of the connected wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});
var LAST_USED_AUTH_STRATEGY = "lastUsedAuthStrategy";

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
var import_dist46 = __toESM(require_dist());
var import_dist47 = __toESM(require_dist2());
var import_dist48 = __toESM(require_dist3());
init_lib3();
var MetaMaskWallet = class _MetaMaskWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "MetaMask";
  }
  /**
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   * Provide clientId to use the thirdweb RPCs for given chains
   * You can create a client ID for your application from thirdweb dashboard.
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to MetaMask mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to `defaultChains` ( `import { defaultChains } from "@thirdweb-dev/chains"` )
   *
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MetaMaskWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new MetaMaskWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal for connecting to MetaMask on mobile if MetaMask is not injected.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * options to customize the Wallet Connect QR Code Modal ( only relevant when qrcode is true )
   */
  constructor(options) {
    super(_MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-YEK7GMX5.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the MetaMask wallet using a QR code if the user does not have the Metamask extension installed.
   *
   * You can use this method to display a QR code. User can scan the QR code from the MetaMask mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * metamask.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, MetaMask will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * MetaMask extension on desktop supports switching accounts.
   * This method will trigger the MetaMask extension to show the account switcher Modal
   */
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
var import_dist49 = __toESM(require_dist());
var import_dist50 = __toESM(require_dist2());
var import_dist51 = __toESM(require_dist3());
init_lib3();
var OKXWallet = class _OKXWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OKX";
  }
  /**
   * Create instance of `OKXWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-QVNXKOLT.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OKX Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
var import_dist52 = __toESM(require_dist());
var import_dist53 = __toESM(require_dist2());
var import_dist54 = __toESM(require_dist3());
init_lib3();
var CoreWallet = class _CoreWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Core wallet";
  }
  /**
   * Create instance of `CoreWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-A3CIO7Z4.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Core Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.browser.esm.js
var import_dist55 = __toESM(require_dist());
var import_dist56 = __toESM(require_dist2());
var import_dist57 = __toESM(require_dist3());
init_lib3();
var OneKeyWallet = class _OneKeyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "OneKey wallet";
  }
  /**
   * Create instance of `OneKeyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_OneKeyWallet.id, options);
    this.isInjected = !!getInjectedOneKeyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OneKeyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-onekey.browser.esm-GHFETHVP.js");
        this.OneKeyConnector = new OneKeyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OneKeyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the OneKey Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OneKeyWallet, "id", walletIds.oneKey);

// node_modules/@thirdweb-dev/wallets/evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.browser.esm.js
var import_dist58 = __toESM(require_dist());
var import_dist59 = __toESM(require_dist2());
var import_dist60 = __toESM(require_dist3());
init_lib3();
var CryptoDefiWallet = class _CryptoDefiWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Crypto Defi wallet";
  }
  /**
   * Create instance of `CryptoDefiWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_CryptoDefiWallet.id, options);
    this.isInjected = !!getInjectedCryptoDefiWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CryptoDefiWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-crypto-defi-wallet.browser.esm-DCPVJ2QU.js");
        this.CryptoDefiWalletConnector = new CryptoDefiWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CryptoDefiWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Defi Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CryptoDefiWallet, "id", walletIds.cryptoDefiWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.browser.esm.js
var import_dist61 = __toESM(require_dist());
var import_dist62 = __toESM(require_dist2());
var import_dist63 = __toESM(require_dist3());
init_lib3();
var RabbyWallet = class _RabbyWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Rabby wallet";
  }
  /**
   * Create instance of `RabbyWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_RabbyWallet.id, options);
    this.isInjected = !!getInjectedRabbyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RabbyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rabby.browser.esm-3M5F5BRI.js");
        this.RabbyConnector = new RabbyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.RabbyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Rabby Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RabbyWallet, "id", walletIds.rabby);

// node_modules/@thirdweb-dev/wallets/evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.browser.esm.js
var import_dist64 = __toESM(require_dist());
var import_dist65 = __toESM(require_dist2());
var import_dist66 = __toESM(require_dist3());
init_lib3();
var Coin98Wallet = class _Coin98Wallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coin98 wallet";
  }
  /**
   * Create instance of `Coin98Wallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super(_Coin98Wallet.id, options);
    this.isInjected = !!getInjectedCoin98Provider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          Coin98Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-coin98.browser.esm-2UBL3WVE.js");
        this.Coin98Connector = new Coin98Connector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.Coin98Connector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Coin98 Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(Coin98Wallet, "id", walletIds.coin98);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-b24ac791.browser.esm.js
var import_dist67 = __toESM(require_dist());
var import_dist68 = __toESM(require_dist2());
var import_dist69 = __toESM(require_dist3());
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/dist/engine-09701abe.browser.esm.js
var import_dist70 = __toESM(require_dist());
var import_dist71 = __toESM(require_dist2());
var import_dist72 = __toESM(require_dist3());
init_lib3();
var EngineSigner = class _EngineSigner extends ethers_exports.Signer {
  constructor(config, provider) {
    super();
    this.config = {
      ...config,
      engineUrl: config.engineUrl.replace(/\/$/, "")
    };
    ethers_exports.utils.defineReadOnly(this, "provider", provider || null);
  }
  async getAddress() {
    return this.config.backendWalletAddress;
  }
  async signMessage(message) {
    const res = await this.fetch({
      path: "/backend-wallet/sign-message",
      method: "POST",
      body: {
        message
      }
    });
    return res.result;
  }
  async signTransaction(transaction) {
    var _a, _b, _c, _d, _e6, _f;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: "/backend-wallet/sign-transaction",
      method: "POST",
      body: {
        ...tx,
        nonce: (_a = tx.nonce) == null ? void 0 : _a.toString(),
        gasLimit: (_b = tx.gasLimit) == null ? void 0 : _b.toString(),
        gasPrice: (_c = tx.gasPrice) == null ? void 0 : _c.toString(),
        value: (_d = tx.value) == null ? void 0 : _d.toString(),
        maxPriorityFeePerGas: (_e6 = tx.maxPriorityFeePerGas) == null ? void 0 : _e6.toString(),
        maxFeePerGas: (_f = tx.maxFeePerGas) == null ? void 0 : _f.toString()
      }
    });
    return res.result;
  }
  async sendTransaction(transaction) {
    if (!this.provider) {
      throw new Error("Sending transactions requires a provider!");
    }
    const chainId = (await this.provider.getNetwork()).chainId;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: `/backend-wallet/${chainId}/send-transaction`,
      method: "POST",
      body: {
        toAddress: tx.to,
        data: tx.data,
        value: tx.value || "0"
      }
    });
    const queueId = res.result.queueId;
    return {
      hash: queueId,
      confirmations: 0,
      from: this.config.backendWalletAddress,
      nonce: 0,
      gasLimit: BigNumber.from(0),
      value: BigNumber.from(0),
      data: "",
      chainId,
      wait: async (confirmations) => {
        if (!this.provider) {
          throw new Error("Sending transactions requires a provider!");
        }
        while (true) {
          const {
            result: txRes
          } = await this.fetch({
            path: `/transaction/status/${queueId}`,
            method: "GET"
          });
          switch (txRes.status) {
            case "errored":
              throw new Error(`Transaction errored with reason: ${txRes.errorMessage}`);
            case "cancelled":
              throw new Error(`Transaction execution cancelled.`);
            case "mined":
              const receipt = await this.provider.getTransactionReceipt(txRes.transactionHash);
              return receipt;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
    };
  }
  connect(provider) {
    return new _EngineSigner(this.config, provider);
  }
  async fetch(_ref) {
    let {
      path,
      method,
      body
    } = _ref;
    const res = await fetch(`${this.config.engineUrl}${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.accessToken}`,
        "x-backend-wallet-address": this.config.backendWalletAddress
      },
      ...body ? {
        body: JSON.stringify(body)
      } : {}
    });
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res.json();
  }
};
var EngineWallet = class extends AbstractWallet {
  constructor(config) {
    super();
    this._signer = new EngineSigner(config);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
var import_dist73 = __toESM(require_dist());
var import_dist74 = __toESM(require_dist2());
var import_dist75 = __toESM(require_dist3());
init_lib3();
var PaperWallet = class _PaperWallet extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a;
    super(_PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = options.paperClientId ?? options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-XDLPRBZO.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
var import_dist76 = __toESM(require_dist());
var import_dist77 = __toESM(require_dist2());
var import_dist78 = __toESM(require_dist3());
init_dist();
init_lib3();
{
  window.Buffer = Buffer$1;
}
var CoinbaseWallet = class _CoinbaseWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Coinbase Wallet";
  }
  /**
   * @internal
   */
  /**
   * @internal
   */
  /**
   *
   * @param options -
   * The `options` object contains the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { CoinbaseWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new CoinbaseWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   * ### headlessMode (optional)
   * This is only relevant applies when coinbase extension wallet is NOT installed on user's browser.
   *
   * By default `headlessMode` is set to `false` - which means that when user does not have coinbase wallet extension installed, a QR Code scan modal will open when calling the `connect` method to allow the user to connect to their coinbase mobile app by scanning the QR code.
   *
   * If headlessMode is set to `true` and coinbase wallet extension is not installed, the wallet will NOT open a QR Code scan modal - This is useful if you want to create a custom QR Code modal.
   *
   * you can use the `getQrUrl` method to get the QR Code url and create your own QR Code Modal
   *
   * Must be a `boolean`.
   */
  constructor(options) {
    super(_CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-EIS5EFQH.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  /**
   * Get the QR Code url to render a custom QR Code Modal for connecting to Coinbase Wallet.
   *
   * This method is only relevant when coinbase extension wallet is NOT installed on user's browser and `headlessMode` is set to `true`.
   *
   * @example
   * ```ts
   * const wallet = new CoinbaseWallet({ headlessMode: true });
   *
   * const qrUrl = await wallet.getQrUrl();
   * // render a QR Code Modal with the qrUrl
   *
   * const walletAddress = await wallet.connect(); // this is resolved when user scans the QR Code and wallet is connected
   *
   * console.log('connected to', walletAddress);
   * ```
   *
   * @returns
   */
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
var import_dist79 = __toESM(require_dist());
var import_dist80 = __toESM(require_dist2());
var import_dist81 = __toESM(require_dist3());
init_lib3();
var EthersWallet = class extends AbstractWallet {
  /**
   * Create instance of `EthersWallet`
   * @param signer - ethers.js signer object
   */
  constructor(signer) {
    super();
    this._signer = signer;
  }
  /**
   * Returns [ethers signer](https://docs.ethers.org/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
var import_dist82 = __toESM(require_dist());
var import_dist83 = __toESM(require_dist2());
var import_dist84 = __toESM(require_dist3());
init_lib3();
var FrameWallet = class _FrameWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Frame Wallet";
  }
  /**
   * Create a `FrameWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { FrameWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new FrameWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-GE3UYJA3.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/imtoken/dist/thirdweb-dev-wallets-evm-wallets-imtoken.browser.esm.js
var import_dist85 = __toESM(require_dist());
var import_dist86 = __toESM(require_dist2());
var import_dist87 = __toESM(require_dist3());
init_lib3();
var ImTokenWallet = class _ImTokenWallet extends AbstractClientWallet {
  get walletName() {
    return "imToken";
  }
  constructor(options) {
    var _a;
    super(_ImTokenWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isImToken);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ImTokenConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-imtoken.browser.esm-NLWPMLER.js");
        const imtokenConnector = new ImTokenConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.imtokenConnector = imtokenConnector;
        this.connector = new WagmiAdapter(imtokenConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ImTokenWallet, "meta", {
  name: "imToken",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMl80NzgzKSI+CjxtYXNrIGlkPSJtYXNrMF8yMjJfNDc4MyIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCI+CjxwYXRoIGQ9Ik03OS44OTQ4IDBIMC4wNTA3ODEyVjgwSDc5Ljg5NDhWMFoiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF8yMjJfNDc4MykiPgo8cGF0aCBkPSJNNjIuMDI3NSAwSDE4LjA1MDlDOC4xNDYzOSAwIDAuMTE3MTg4IDguMDQ0ODggMC4xMTcxODggMTcuOTY4OFY2Mi4wMzEyQzAuMTE3MTg4IDcxLjk1NTEgOC4xNDYzOSA4MCAxOC4wNTA5IDgwSDYyLjAyNzVDNzEuOTMyIDgwIDc5Ljk2MTIgNzEuOTU1MSA3OS45NjEyIDYyLjAzMTJWMTcuOTY4OEM3OS45NjEyIDguMDQ0ODggNzEuOTMyIDAgNjIuMDI3NSAwWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIyMl80NzgzKSIvPgo8cGF0aCBkPSJNNjUuMDk4MSAyNC43MzNDNjYuNzU4NiA0Ny4yNjY3IDUyLjMwMjEgNTcuOTE3MiAzOS4zNDIzIDU5LjA1M0MyNy4yOTM1IDYwLjEwODcgMTUuOTUyIDUyLjY5MDggMTQuOTU3MSA0MS4yOTM2QzE0LjEzNjMgMzEuODc3NiAxOS45NDQ1IDI3Ljg2ODkgMjQuNTA4IDI3LjQ2OTRDMjkuMjAxNSAyNy4wNTcgMzMuMTQ1OCAzMC4zMDAxIDMzLjQ4NzkgMzQuMjI2OUMzMy44MTc1IDM4LjAwMiAzMS40NjY0IDM5LjcyMDUgMjkuODMxMyAzOS44NjM0QzI4LjUzODIgMzkuOTc3IDI2LjkxMTQgMzkuMTkwNSAyNi43NjQ1IDM3LjUwMTZDMjYuNjM4NSAzNi4wNTAzIDI3LjE4ODUgMzUuODUyNiAyNy4wNTQxIDM0LjMxMDlDMjYuODE0OSAzMS41NjYyIDI0LjQyNjEgMzEuMjQ2NiAyMy4xMTgzIDMxLjM2MDFDMjEuNTM1NyAzMS40OTkxIDE4LjY2NDEgMzMuMzQ5OCAxOS4wNjcgMzcuOTZDMTkuNDcyMiA0Mi42MTAxIDIzLjkyMjIgNDYuMjg0NSAyOS43NTU3IDQ1Ljc3MzRDMzYuMDUwOSA0NS4yMjIzIDQwLjQzMzcgNDAuMzExNCA0MC43NjM0IDMzLjQyMzRDNDAuNzYwMyAzMy4wNTg2IDQwLjgzNyAzMi42OTc1IDQwLjk4OCAzMi4zNjU1TDQwLjk5IDMyLjM1NzJDNDEuMDU3OCAzMi4yMTI4IDQxLjEzNzIgMzIuMDc0MiA0MS4yMjcyIDMxLjk0MjhDNDEuMzYxNiAzMS43NDA5IDQxLjUzMzggMzEuNTE4IDQxLjc1NjIgMzEuMjczOUM0MS43NTgzIDMxLjI2NzYgNDEuNzU4MyAzMS4yNjc2IDQxLjc2MjYgMzEuMjY3NkM0MS45MjQxIDMxLjA4NDcgNDIuMTE5NCAzMC44ODcgNDIuMzM5NyAzMC42NzQ1QzQ1LjA4OTcgMjguMDc1IDU0Ljk5MzEgMjEuOTQ0MiA2NC4zNTkyIDIzLjg4NTVDNjQuNTU3MyAyMy45MjggNjQuNzM2MSAyNC4wMzM0IDY0Ljg2OTMgMjQuMTg2MkM2NS4wMDI1IDI0LjMzOTEgNjUuMDgyNiAyNC41MzA4IDY1LjA5ODEgMjQuNzMzWiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzQ3ODMiIHgxPSI3My41MDA5IiB5MT0iNS4zMTI1IiB4Mj0iMi44NzI0MSIgeTI9Ijc3LjY3NDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzExQzREMSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDYyQUQiLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMjJfNDc4MyI+CjxyZWN0IHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4=",
  urls: {
    ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940",
    android: "https://play.google.com/store/apps/details?id=im.token.app"
  }
});
_defineProperty(ImTokenWallet, "id", walletIds.imtoken);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
var import_dist88 = __toESM(require_dist());
var import_dist89 = __toESM(require_dist2());
var import_dist90 = __toESM(require_dist3());
init_lib3();
var InjectedWallet = class _InjectedWallet extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(_InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-QZR2UFHW.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
var import_dist91 = __toESM(require_dist());
var import_dist92 = __toESM(require_dist2());
var import_dist93 = __toESM(require_dist3());
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var LocalWallet = class _LocalWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Local Wallet";
  }
  /**
   * Initialize the `LocalWallet` with the given `options`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId or secretKey (recommended)
   * Provide `clientId` or `secretKey` to use the thirdweb RPCs for given `chains`
   *
   * If you are using the `LocalWallet` in a in frontend - provide a `clientId`, If you are using the `LocalWallet` in backend - you can provide a `secretKey`.
   *
   * You can create a `clientId` / `secretKey` from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chain (optional)
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   * Defaults to `Ethereum`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### storage (optional)
   * This is the default storage for storing the private key, mnemonic or encrypted JSON. This can be implemented in any way you want, as long as it conforms to the `AsyncStorage` interface:
   *
   * If omitted, defaults to browser local storage.
   *
   *
   * ```javascript
   * import { LocalWallet } from "@thirdweb-dev/wallets";
   *
   * const customStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * };
   *
   * const walletWithOptions = new LocalWallet({
   *   storage: customStorage,
   * });
   * ```
   *
   */
  constructor(options) {
    super(_LocalWallet.id, options);
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-MO6J2C6X.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c5) => updateChainRPCs(c5, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  /**
   * Load the saved wallet data from storage, if it exists, or generate a new one and save it.
   *
   * @example
   * ```js
   * wallet.loadOrCreate({
   *   strategy: "encryptedJson",
   *   password: password,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOrCreateOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Load the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Load the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the saved private key is encrypted.
   */
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  /**
   * Creates a new random wallet and returns the wallet address.
   *
   * @example
   * ```ts
   * const address = await wallet.generate();
   * ```
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  /**
   * Create local wallet by importing a private key, mnemonic or encrypted JSON.
   * @example
   * ```javascript
   * const address = await localWallet.import({
   *   privateKey: "...",
   *   encryption: false,
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletImportOptions` which can have either `privateKey`, `mnemonic` or `encryptedJson` as a property.
   * They all can be encrypted or un-encrypted. If encrypted, the `encryption` property must be provided with `password` property to decrypt the data.
   *
   * ### privateKey
   * The Private Key of the wallet.
   *
   * ### mnemonic
   * The mnemonic (seed phrase) of the wallet.
   *
   * ### encryptedJson
   * The encrypted JSON of the wallet.
   *
   * ### encryption
   * This is only required if the given `privateKey`, `mnemonic` or `encryptedJson` is encrypted.
   * The `encryption` object of type `DecryptOptions` can be provided to decrypt the data. It is an object with the following properties:
   *
   * #### password
   * The password to decrypt the data.
   *
   * #### decrypt
   * A custom decrypt function that takes the encrypted data and password as arguments and returns the decrypted data.
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  /**
   * Initialize the wallet from saved data on storage
   *
   * ```js
   * await wallet.load({
   *   strategy: "encryptedJson",
   *   password: "your-password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletLoadOptions` which contains a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Initialize the wallet from encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to decrypt the encrypted JSON
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Initialize the wallet from a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the private key. This is only required if the private key is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Initialize the wallet from a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `DecryptOptions` to decrypt the mnemonic. This is only required if the mnemonic is encrypted.
   * * `storage` - optional storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @returns Promise that resolves to the address of the wallet
   */
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  /**
   * Save the wallet data to storage
   *
   * @example
   * ```javascript
   * wallet.save({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletSaveOptions`. It takes a `strategy` property and other properties depending on the strategy.
   *
   * ### strategy "encryptedJson"
   * Save the wallet data as encrypted JSON. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "privateKey"
   * Save the wallet data as a private key. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the private key. This is only required if you want to encrypt the private key.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   * ### strategy "mnemonic"
   * Save the wallet data as a mnemonic (seed phrase). The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - optional encryption object of type `EncryptOptions` to encrypt the mnemonic. This is only required if you want to encrypt the mnemonic.
   * * `storage` - optional storage to save the wallet data to. Must be of type `AsyncStorage`
   *
   */
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await this._saveData({
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await this._saveData({
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await this._saveData({
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  /**
   * Check if the wallet data is saved in storage.
   *
   * @returns `true` if initialized wallet's data is saved in storage
   */
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  /**
   * Delete the saved wallet from storage. This action is irreversible, use with caution.
   *
   * @example
   * ```ts
   * await wallet.deleteSaved();
   * ```
   */
  async deleteSaved() {
    await this._storage.removeItem(STORAGE_KEY_WALLET_DATA);
  }
  /**
   * Encrypts the wallet with a password in various formats and return it.
   *
   * @example
   * ```javascript
   * const data = await wallet.export({
   *   strategy: "encryptedJson",
   *   password: "password",
   * });
   * ```
   *
   * @param options - The `options` object must be of type `LocalWalletExportOptions`. It takes a `strategy` and other properties depending on the strategy.
   *
   * ### strategy - "encryptedJson"
   * Export wallet in encryptedJson format. The `options` object takes the following properties:
   * * `strategy` - must be "encryptedJson"
   * * `password` - the password to encrypt the wallet data
   *
   * ### strategy - "privateKey"
   * Encrypt the private key of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "privateKey"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the private key. It takes a `password` property to encrypt the private key and an optional `encrypt` function to encrypt the private key. If `encrypt` function is not provided, it uses the default encryption.
   *
   * ### strategy - "mnemonic"
   * Encrypt the mnemonic (seed phrase) of the wallet. The `options` object takes the following properties:
   * * `strategy` - must be "mnemonic"
   * * `encryption` - encryption object of type `EncryptOptions` to encrypt the mnemonic. It takes a `password` property to encrypt the mnemonic and an optional `encrypt` function to encrypt the mnemonic. If `encrypt` function is not provided, it uses the default encryption.
   *
   * @returns Promise that resolves to a `string` that contains encrypted wallet data
   */
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  /**
   * Get the saved wallet data from storage
   * @param storage - storage to get the wallet data from. Must be of type `AsyncStorage`
   *
   * @example
   * ```javascript
   * const someStorage = {
   *   getItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   removeItem: (key) => {
   *     // Implement your own storage logic here
   *   },
   *   setItem: (key, value) => {
   *     // Implement your own storage logic here
   *   },
   * }
   *
   * wallet.getSaved(someStorage);
   * ```
   *
   * @returns `Promise` which resolves to a `WalletData` object containing the wallet data. It returns `null` if no wallet data is found in storage.
   * ```ts
   * {
   *     address: string;
   *     strategy: "mnemonic" | "privateKey" | "encryptedJson";
   *     data: string;
   *     isEncrypted: boolean;
   * }
   * ```
   */
  async getSavedData(storage) {
    const _storage = storage || this._storage;
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  /**
   * store the wallet data to storage
   */
  async _saveData(data, storage) {
    const _storage = storage || this._storage;
    await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
  }
  /**
   * Disconnect the wallet
   */
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function noop(msg) {
  return msg;
}
function getDecryptor(encryption) {
  return encryption ? (msg) => (
    // we're using aesDecryptCompat here because we want to support legacy crypto-js ciphertext for the moment
    (encryption.decrypt || aesDecryptCompat)(msg, encryption.password)
  ) : noop;
}
function getEncryptor(encryption) {
  return encryption ? (msg) => (encryption.encrypt || aesEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
var import_dist94 = __toESM(require_dist());
var import_dist95 = __toESM(require_dist2());
var import_dist96 = __toESM(require_dist3());
init_lib3();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-AIKZ7PNG.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c5) => updateChainRPCs(c5, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
var import_dist97 = __toESM(require_dist());
var import_dist98 = __toESM(require_dist2());
var import_dist99 = __toESM(require_dist3());
init_lib3();
var MagicLink = class _MagicLink extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Link";
  }
  /**
   * @internal
   */
  /**
   * Create an instance of the `MagicLink` wallet
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### apiKey (required)
   * Your Magic Link apiKey. You can get an API key by signing up for an account on [Magic Link's website](https://magic.link/).
   *
   * Must be a `string`.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### type (optional)
   * Whether to use [Magic Auth](https://magic.link/docs/auth/overview) or [Magic Connect](https://magic.link/docs/connect/overview) to connect to the wallet.
   *
   * Default is `"auth"`.
   *
   * ```ts
   * type: "auth" | "connect";
   * ```
   *
   * ### magicSdkConfiguration (optional)
   * Configuration for [Magic Auth](https://magic.link/docs/auth/overview) SDK.
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * ```ts
   * {
   *   locale?: string;
   *   endpoint?: string;
   *   testMode?: boolean;
   * }
   * ```
   *
   * * locale (optional) - Customize the language of Magic's modal, email and confirmation screen. See [Localization](https://magic.link/docs/auth/more/customization/localization) for more.
   *
   * * endpoint (optional) - A URL pointing to the Magic iframe application.
   *
   * * testMode (optional) - Enable [testMode](https://magic.link/docs/auth/introduction/test-mode) to assert the desired behavior through the email address so that you don't have to go through the auth flow.
   *
   *
   * ### smsLogin
   * Specify whether you want to allow users to log in with their phone number or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   * ### emailLogin (optional)
   * Specify whether you want to allow users to log in with their email or not. It is `true` by default
   *
   * This is only relevant if you are using `type: 'auth'`.
   *
   * Must be a `boolean`.
   *
   *
   * ### oauthOptions (optional)
   * Specify which oauth providers you support in `providers` array. This is only relevant if you are using `type: 'auth'`.
   *
   * Specify which URI to redirect to after the oauth flow is complete in `redirectURI` option. If no `redirectURI` is specified, the user will be redirected to the current page.
   *
   * You must pass full URL and not just a relative path. For example, `"https://example.com/foo"` is valid but `"/foo"` is not.
   * You can use `new URL("/foo", window.location.origin).href` to get the full URL from a relative path based on the current origin.
   *
   * You also need to enable the oauth providers for your apiKey from [Magic dashboard](https://dashboard.magic.link/).
   *
   * ```ts
   * type OauthOptions = {
   *   redirectURI?: string;
   *   providers: OauthProvider[];
   * };
   *
   * type OauthProvider =
   *   | "google"
   *   | "facebook"
   *   | "apple"
   *   | "github"
   *   | "bitbucket"
   *   | "gitlab"
   *   | "linkedin"
   *   | "twitter"
   *   | "discord"
   *   | "twitch"
   *   | "microsoft";
   * ```
   *
   * ```ts
   * const wallet = new MagicLink({
   *   apiKey: "YOUR_API_KEY",
   *   type: "auth",
   *   // specify which Oauth providers to enable
   *   oauthOptions: {
   *     redirectURI: new URL("/foo", window.location.origin).href,
   *     providers: ["google", "facebook", "github", "bitbucket"],
   *   },
   * });
   * ```
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   */
  constructor(options) {
    super(_MagicLink.id, options);
    this.options = options;
  }
  /**
   * @internal
   */
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-QIYLI4PW.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  /**
   * Get Magic Auth SDK instance. Learn more about [Magic Auth SDK](https://magic.link/docs/auth/overview)
   *
   * you use all methods available in the Magic Auth SDK from the SDK instance. Refer to [Magic Auth API](https://magic.link/docs/auth/api-reference/client-side-sdks/web) for more details.
   *
   * ```javascript
   * const magicSDK = await wallet.getMagic();
   * ```
   */
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  /**
   * Auto connect wallet if the user is already logged in.
   * @returns
   */
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  /**
   * Disconnect wallet
   */
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  /**
   * Connect Wallet using Magic Auth or Magic Connect
   *
   * ### Magic Auth
   * There are three ways to call the `connect` function - `email` or `phoneNumber` or `oauthProvider`
   *
   * #### email
   * This opens the Magic Link's Modal and prompts the user to click on the link sent to their email.
   *
   * ```ts
   * await wallet.connect({
   *   email: "user@example.com",
   * });
   * ```
   *
   * #### phoneNumber
   * This opens the Magic Link's Modal and prompts the user to enter the OTP sent to their phone via SMS.
   *
   * ```ts
   * await wallet.connect({
   *   phoneNumber: "+123456789",
   * });
   * ```
   *
   * #### oauthProvider
   * This redirects the user to given provider's sign-in page and once the user is authenticated, it redirects the user back to the `redirectURI` provided in `MagicLink` constructor.
   *
   * ```ts
   * await magic.connect({
   *   oauthProvider: "google",
   * });
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * ### Magic Connect
   * You can call the `connect` function without any arguments. Calling `connect` opens the Magic Link's Modal and prompts the user to login via Google or email.
   *
   * ```ts
   * await wallet.connect();
   * ```
   *
   * #### Additional Configuration
   *
   * ```typescript
   * wallet.connect({
   *   chainId: 5,
   * });
   * ```
   *
   * If `chainId` is provided, the wallet will be connected to the network with the given chainId, else it will be connected to the Ethereum Mainnet.
   *
   * @param options - The `options` object can include the following properties:
   * ### Magic Auth
   * If you are using `type: 'auth'`, you can pass any one of the following properties
   * - `email` - The email address of the user
   * - `phoneNumber` - The phone number of the user
   * - `oauthProvider` - The oauth provider to use for login
   *
   * ### Magic Connect
   * If you are using `type: 'connect'`, you don't need to pass any arguments to `connect` function.
   *
   * @returns
   */
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.browser.esm.js
var import_dist100 = __toESM(require_dist());
var import_dist101 = __toESM(require_dist2());
var import_dist102 = __toESM(require_dist3());
init_lib3();
var XDEFIWallet = class _XDEFIWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "XDEFI";
  }
  /**
   * Create instance of `XDEFIWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { XDEFIWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new XDEFIWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_XDEFIWallet.id, options);
    this.isInjected = !!getInjectedXDEFIProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        XDEFIConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-xdefi.browser.esm-RD6WFCAL.js");
      const connector = new XDEFIConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(XDEFIWallet, "id", walletIds.xdefi);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
var import_dist103 = __toESM(require_dist());
var import_dist104 = __toESM(require_dist2());
var import_dist105 = __toESM(require_dist3());
init_lib3();
var PhantomWallet = class _PhantomWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Phantom";
  }
  /**
   * Create a `PhantomWallet` instance
   * @param options -
   * The `options` object includes the following properties
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { PhantomWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new PhantomWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-JVIFMAKF.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
    // not specifiying theme because they can't be used to connect
    // android: "https://play.google.com/store/apps/details?id=app.phantom",
    // ios: "https://apps.apple.com/us/app/phantom-crypto-wallet/id1598432977",
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
var import_dist106 = __toESM(require_dist());
var import_dist107 = __toESM(require_dist2());
var import_dist108 = __toESM(require_dist3());
init_lib3();
var PrivateKeyWallet = class extends AbstractWallet {
  /**
   * Create instance of `PrivateKeyWallet`
   *
   * @param privateKey - The private key to use for signing transactions.
   *
   * @param chain - The chain or rpc url to connect to when querying the blockchain directly through this wallet.
   *
   * @param secretKey -
   * Provide `secretKey` to use the thirdweb RPCs for given `chain`
   *
   * You can create a secret key from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   */
  constructor(privateKey, chain, secretKey) {
    super();
    this._signer = new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0);
  }
  /**
   * Get the [ethers.js signer](https://docs.ethers.io/v5/api/signer/) object used by the wallet
   */
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
var import_dist109 = __toESM(require_dist());
var import_dist110 = __toESM(require_dist2());
var import_dist111 = __toESM(require_dist3());
init_lib3();
var RainbowWallet = class _RainbowWallet extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(_RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-5MA4AHRX.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * connect to wallet with QR code
   *
   * @example
   * ```typescript
   * rainbow.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
var import_dist112 = __toESM(require_dist());
var import_dist113 = __toESM(require_dist2());
var import_dist114 = __toESM(require_dist3());
init_lib3();
var SafeWallet = class _SafeWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Safe Wallet";
  }
  /**
   * Create a `SafeWallet` instance.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   *
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   *
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SafeWallet } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new SafeWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   }
   * });
   * ```
   *
   */
  constructor(options) {
    super(_SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-AX3Z3FR2.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Safe wallet.
   * @returns
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Auto connect the wallet if it was previously connected.
   */
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect Safe wallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * @example
   * ```javascript
   * import { CoinbaseWallet, SafeWallet } from "@thirdweb-dev/wallets";
   * import { Ethereum } from "@thirdweb-dev/chains";
   *
   * // First, connect the personal wallet
   * const personalWallet = new CoinbaseWallet();
   * await personalWallet.connect();
   *
   * // Then, connect the Safe wallet
   * const wallet = new SafeWallet();
   * await wallet.connect({
   *   personalWallet: personalWallet, // Wallet that can sign transactions on the Safe
   *   chain: Ethereum, // Chain that the Safe is on
   *   safeAddress: "{{contract_address}}", // Smart contract address of the Safe
   * });
   * ```
   *
   * ### personalWallet
   *
   * The instance of a personal wallet that can sign transactions on the Safe.
   *
   * Must be of type `EVMWallet` such as [`CoinbaseWallet`](/wallet/coinbase-wallet) or [`MetamaskWallet`](/wallet/metamask).
   *
   * ### chain
   *
   * The chain that the Safe smart contract is deployed to.
   *
   * Must be a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * ### safeAddress
   *
   * Smart contract address of the Safe wallet.
   *
   * Must be a `string`.
   *
   * @returns A Promise that resolves to the Safe address.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
var import_dist115 = __toESM(require_dist());
var import_dist116 = __toESM(require_dist2());
var import_dist117 = __toESM(require_dist3());
init_lib3();
var import_contracts = __toESM(require_dist4());
var SmartWallet = class _SmartWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Smart Wallet";
  }
  /**
   *
   * @param options - The `options` object includes the following properties:
   * ### Required Properties
   *
   * #### chain
   * The chain that the Smart Wallet contract is deployed to.
   *
   * Either a `Chain` object, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package, a chain name, or an RPC URL.
   *
   *
   * #### factoryAddress
   * The address of the Smart Wallet Factory contract.
   *
   * Must be a `string`.
   *
   *
   * #### gasless
   * Whether to turn on or off gasless transactions.
   *
   * - If set to `true`, all gas fees will be paid by a paymaster.
   * - If set to `false`, all gas fees will be paid by the Smart Wallet itself (needs to be funded).
   *
   * Must be a `boolean`.
   *
   *
   * ### Optional properties
   *
   * #### clientId or secretKey (recommended)
   * Your API key can be obtained from the [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * If you're using your own bundler and paymaster, you can set this to an empty string.
   *
   * You can use either the `clientId` or the `secretKey` depending on whether your application is client or server side.
   *
   * Must be a `string`.
   *
   * #### factoryInfo
   * Customize how the Smart Wallet Factory contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `createAccount` - a function that returns the transaction object to create a new Smart Wallet.
   * - `getAccountAddress` - a function that returns the address of the Smart Wallet contract given the owner address.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       factoryInfo: {
   *         createAccount: async (factory, owner) => {
   *           return factory.prepare("customCreateAccount", [
   *             owner,
   *             getExtraData(),
   *           ]);
   *         },
   *         getAccountAddress: async (factory, owner) => {
   *           return factory.call("getAccountAddress", [owner]);
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   *
   * #### accountInfo
   * Customize how the Smart Wallet Account contract is interacted with. If not provided, the default functions will be used.
   *
   * Must be a `object`. The object can contain the following properties:
   *
   * - `execute` - a function that returns the transaction object to execute an arbitrary transaction.
   * - `getNonce` - a function that returns the current nonce of the account.
   * - `abi` - optional ABI. If not provided, the ABI will be auto-resolved.
   *
   * ```javascript
   *  const config: SmartWalletConfig = {
   *       chain,
   *       gasless,
   *       factoryAddress,
   *       clientId,
   *       accountInfo: {
   *         execute: async (account, target, value, data) => {
   *           return account.prepare("customExecute", [
   *             target, value, data
   *           ]);
   *         },
   *         getNonce: async (account) => {
   *           return account.call("getNonce");
   *         },
   *         abi: [...]
   *       },
   *     };
   * ```
   *
   * #### bundlerUrl
   * Your own bundler URL to send user operations to. Uses thirdweb's bundler by default.
   *
   * Must be a `string`.
   *
   * #### paymasterUrl
   * Your own paymaster URL to send user operations to for gasless transactions. Uses thirdweb's paymaster by default.
   *
   * Must be a `string`.
   *
   * #### paymasterAPI
   * Fully customize how the paymaster data is computed.
   *
   * Must be a `PaymasterAPI` class.
   *
   * ```javascript
   * class MyPaymaster extends PaymasterAPI {
   *   async getPaymasterAndData(
   *     userOp: Partial<UserOperationStruct>,
   *   ): Promise<string> {
   *     // your implementation, must return the signed paymaster data
   *   }
   * }
   *
   * const config: SmartWalletConfig = {
   *   chain,
   *   gasless,
   *   factoryAddress,
   *   clientId,
   *   // highlight-start
   *   paymasterAPI: new MyPaymaster(),
   *   // highlight-end
   * };
   * ```
   *
   *
   * #### entryPointAddress
   * The entrypoint contract address. Uses v0.6 by default.
   *
   * Must be a `string`.
   *
   * #### deployOnSign
   * Whether to deploy the smart wallet when the user signs a message. Defaults to true.
   *
   * Must be a `boolean`.
   *
   * #### chains
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to thirdweb's [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * #### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url` and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { SmartWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new SmartWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp", // optional
   *     logoUrl: "https://thirdweb.com/favicon.ico", // optional
   *   },
   * });
   * ```
   *
   */
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(_SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      if (this.options && await isZkSyncChain(this.options.chain, this.options.clientId, this.options.secretKey)) {
        const {
          ZkSyncConnector
        } = await import("./zk-connector-fada2157.browser.esm-HIU5GGIF.js");
        this.connector = new ZkSyncConnector(this.options);
      } else {
        const {
          SmartWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-JHPJEXE5.js");
        this.connector = new SmartWalletConnector(this.options);
      }
    }
    return this.connector;
  }
  /**
   * Get the personal wallet that is connected to the Smart Wallet.
   * @example
   * ```ts
   * const personalWallet = wallet.getPersonalWallet();
   * ```
   */
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction - The transaction to execute using the smart wallet.
   * @returns `Promise<true>` if connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  /**
   * Send a single transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async send(transaction, options) {
    const connector = await this.getConnector();
    return connector.send(transaction, options);
  }
  /**
   * Execute a single transaction and wait for confirmations
   *
   * @example
   * ```javascript
   * const transaction = prepareTransaction();
   * await wallet.execute(transaction);
   * ```
   *
   * @param transaction -
   * The transaction to execute. Must be of type `Transaction` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](https://portal.thirdweb.com/typescript/v4/interact#prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async execute(transaction, options) {
    const connector = await this.getConnector();
    return connector.execute(transaction, options);
  }
  /**
   * Send a multiple transaction in a batch without waiting for confirmations
   * @param transactions -
   * An array of transactions to send. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async sendBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions, options);
  }
  /**
   * Execute multiple transactions in a single batch and wait for confirmations, only requiring one signature from the personal wallet.
   *
   * ```javascript
   * // Then you can execute multiple transactions at once
   * const transactions = [
   *   prepareTransaction1(),
   *   prepareTransaction2(),
   *   prepareTransaction3(),
   * ];
   * await wallet.executeBatch(transactions);
   * ```
   *
   * @param transactions -
   * An array of transactions to execute. Must be of type `Transaction[]` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * Creating these transactions can be done easily using the [Transaction Builder](typescript/sdk.smartcontract.prepare) from the thirdweb SDK.
   *
   * @param options - optional transaction options
   * @returns `TransactionResult` containing the transaction receipt.
   */
  async executeBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions, options);
  }
  /**
   * Send a single raw transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction, options);
  }
  /**
   * Execute a single raw transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction, options);
  }
  /**
   * Estimate the gas cost of a single transaction
   * @param transaction - the transaction to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimate(transaction, options) {
    const connector = await this.getConnector();
    return connector.estimate(transaction, options);
  }
  /**
   * Estimate the gas cost of a batch of transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions, options);
  }
  /**
   * Estimate the gas cost of a single raw transaction
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions, options);
  }
  /**
   * Estimate the gas cost of a batch of raw transactions
   * @param transactions - the transactions to estimate
   * @param options - optional transaction options
   * @returns
   */
  async estimateBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions, options);
  }
  /**
   * Send multiple raw transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @param options - optional transaction options
   * @returns The transaction result
   */
  async sendBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions, options);
  }
  /**
   * Execute multiple raw transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async executeBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions, options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   *
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * const tx = await wallet.deploy();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deploy(options) {
    const connector = await this.getConnector();
    return connector.deploy(options);
  }
  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   *
   * @example
   * ```ts
   * await wallet.deployIfNeeded();
   * ```
   * @param options - optional transaction options
   * @returns The transaction receipt
   */
  async deployIfNeeded(options) {
    const connector = await this.getConnector();
    return connector.deployIfNeeded(options);
  }
  /**
   * Check if the smart wallet contract is deployed
   * @example
   * ```ts
   * const isDeployed = await wallet.isDeployed();
   * ```
   *
   * @returns `true` if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    if (connector.chainId && await isZkSyncChain(connector.chainId)) {
      return true;
    }
    return connector.isDeployed();
  }
  /**
   * Create and add a session key to the Smart Wallet with specific permissions.
   * @example
   * ```javascript
   * // Then you can add session keys with permissions
   * await wallet.createSessionKey(
   *   "0x...", // the session key address
   *   {
   *       approvedCallTargets: ["0x..."], // the addresses of contracts that the session key can call
   *       nativeTokenLimitPerTransaction: 0.1, // the maximum amount of native token (in ETH) that the session key can spend per transaction
   *       startDate: new Date(), // the date when the session key becomes active
   *       expirationDate = new Date(Date.now() + 24 * 60 * 60 * 1000); // the date when the session key expires
   *   }
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to add to the Smart Wallet.
   *
   * @param permissions -
   * The specific permissions to give to the session key.
   * Must be of type `SignerPermissionsInput` from the [`@thirdweb-dev/sdk`](https://www.npmjs.com/package/\@thirdweb-dev/sdk) package.
   *
   * ```typescript
   * {
   *   startDate: Date;
   *   expirationDate: Date;
   *   nativeTokenLimitPerTransaction: number;
   *   approvedCallTargets: string[];
   * }
   * ```
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  /**
   * Revoke a session key from the Smart Wallet.
   * @example
   * ```javascript
   * await wallet.revokeSessionKey(
   *   "0x...", // the session key address
   * );
   * ```
   *
   * @param keyAddress - The address of the session key to revoke.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  /**
   * Add another admin to the smart wallet.
   * @param adminAddress - The address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress - The address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  /**
   * Get the underlying account contract of the smart wallet.
   * @returns The account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns The account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  async verifySignature(message, signature, address, chainId) {
    var _a, _b;
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        return await checkContractWalletSignature(message, signature, address, chainId || 1, (_a = this.options) == null ? void 0 : _a.clientId, (_b = this.options) == null ? void 0 : _b.secretKey);
      } catch {
      }
    }
    return false;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  /**
   * Connect the SmartWallet with given personalWallet
   * @param connectOptions -
   * The `connectOptions` object includes the following properties:
   *
   * #### personalWallet
   * The instance of a personal wallet that can sign transactions on the Smart Wallet.
   * Must be of type `EVMWallet` instance such as `CoinbaseWallet` or `MetamaskWallet`.
   *
   * @returns A Promise that resolves to the address of the Smart Wallet.
   */
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
var import_dist118 = __toESM(require_dist());
var import_dist119 = __toESM(require_dist2());
var import_dist120 = __toESM(require_dist3());
init_lib3();
var TrustWallet = class _TrustWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Trust Wallet";
  }
  /**
   * Create instance of `TrustWallet`
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### projectId (recommended)
   *
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ### qrcode
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    var _a;
    super(_TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-RKRBAYRB.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Trust Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
var import_dist121 = __toESM(require_dist());
var import_dist122 = __toESM(require_dist2());
var import_dist123 = __toESM(require_dist3());
init_lib3();
var WalletConnect = class _WalletConnect extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  /**
   *
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### projectId (recommended)
   * Your project's unique identifier. It can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * It enables the following functionalities within WalletConnect's web3modal:
   *
   * - wallet and chain logos
   * - optional WalletConnect RPC
   * - support for all wallets from our Explorer and WalletConnect v2 support
   *
   * Defaults to thirdweb's common project id.
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { WalletConnect } from "@thirdweb-dev/wallets";
   *
   * const walletWithOptions = new WalletConnect({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrcode (optional)
   * Whether to display the Wallet Connect QR code Modal or not.
   *
   * Must be a `boolean`. Defaults to `true`.
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   *
   */
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || _WalletConnect.id, options);
    _defineProperty(this, "_maybeThrowError", (error) => {
      if (error) {
        throw error;
      }
    });
    _defineProperty(this, "_onConnect", (data) => {
      this._provider = data.provider;
      if (!this._provider) {
        throw new Error("WalletConnect provider not found after connecting.");
      }
    });
    _defineProperty(this, "_onDisconnect", () => {
      this._removeListeners();
    });
    _defineProperty(this, "_onChange", async (payload) => {
      if (payload.chain) ;
      else if (payload.account) ;
    });
    _defineProperty(this, "_onMessage", (payload) => {
      switch (payload.type) {
        case "display_uri":
          this.emit("display_uri", payload.data);
          break;
      }
    });
    _defineProperty(this, "_onSessionRequestSent", () => {
      this.emit("wc_session_request_sent");
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
      this._walletConnectConnector = new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      });
      this.connector = new WagmiAdapter(this._walletConnectConnector);
      this._provider = await this._walletConnectConnector.getProvider();
      this._setupListeners();
    }
    return this.connector;
  }
  _setupListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._removeListeners();
    this._walletConnectConnector.on("connect", this._onConnect);
    this._walletConnectConnector.on("disconnect", this._onDisconnect);
    this._walletConnectConnector.on("change", this._onChange);
    this._walletConnectConnector.on("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.on("session_request_sent", this._onSessionRequestSent);
  }
  _removeListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._walletConnectConnector.removeListener("connect", this._onConnect);
    this._walletConnectConnector.removeListener("disconnect", this._onDisconnect);
    this._walletConnectConnector.removeListener("change", this._onChange);
    this._walletConnectConnector.removeListener("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", this._onSessionRequestSent);
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. User can scan this QR code from the Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = false;
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  /**
   * @internal
   */
  async connectWithModal(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = true;
    await wcConnector.initProvider();
    await this.connect({
      chainId: options == null ? void 0 : options.chainId
    });
  }
};
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
var import_dist124 = __toESM(require_dist());
var import_dist125 = __toESM(require_dist2());
var import_dist126 = __toESM(require_dist3());
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
var import_dist127 = __toESM(require_dist());
var import_dist128 = __toESM(require_dist2());
var import_dist129 = __toESM(require_dist3());
init_lib3();
var ZerionWallet = class _ZerionWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Zerion Wallet";
  }
  /**
   * Create an instance of `ZerionWallet`.
   * @param options -
   * The `options` object includes the following properties:
   *
   * ### clientId (recommended)
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   *
   * ### projectId (recommended)
   * This is only relevant if you want to use [WalletConnect](https://walletconnect.com/) for connecting to Zerion wallet mobile app when MetaMask is not injected.
   *
   * This `projectId` can be obtained at [cloud.walletconnect.com](https://cloud.walletconnect.com/). It is highly recommended to use your own project id and only use the default one for testing purposes.
   *
   * ### qrcode
   * Whether to open the default Wallet Connect QR code Modal for connecting to Zerion Wallet on mobile
   * (if Zerion is not injected when calling `connect()`).
   *
   * Must be a `boolean`. Defaults to `false`.
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   * ```javascript
   * import { ZerionWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new ZerionWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   *
   * ### qrModalOptions
   * WalletConnect's [options](https://docs.walletconnect.com/advanced/walletconnectmodal/options) to customize the QR Code Modal.
   */
  constructor(options) {
    var _a;
    super(_ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-WQ6LNTHD.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-677EWMN2.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            // TODO,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  /**
   * Connect to the wallet using a QR code.
   * You can use this method to display a QR code. The user can scan this QR code using the Zerion Wallet mobile app to connect to your dapp.
   *
   * @example
   * ```typescript
   * wallet.connectWithQrCode({
   *  chainId: 1,
   *  onQrCodeUri(qrCodeUri) {
   *    // render the QR code with `qrCodeUri`
   *  },
   *  onConnected(accountAddress)  {
   *    // update UI to show connected state
   *  },
   * })
   * ```
   *
   * @param options -
   * The options object contains the following properties/method:
   *
   * ### chainId (optional)
   * If provided, wallet will prompt the user to switch to the network with the given `chainId` after connecting.
   *
   * ### onQrCodeUri
   * A callback to get the QR code URI to display to the user.
   *
   * ### onConnected
   * A callback that is called when the user has connected their wallet using the QR code.
   */
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
var import_dist130 = __toESM(require_dist());
var import_dist131 = __toESM(require_dist2());
var import_dist132 = __toESM(require_dist3());
init_lib3();
var import_contracts2 = __toESM(require_dist4());
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-TTGKX4S4.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic-eden/dist/thirdweb-dev-wallets-evm-wallets-magic-eden.browser.esm.js
var import_dist133 = __toESM(require_dist());
var import_dist134 = __toESM(require_dist2());
var import_dist135 = __toESM(require_dist3());
init_lib3();
var MagicEdenWallet = class _MagicEdenWallet extends AbstractClientWallet {
  /**
   * @internal
   */
  get walletName() {
    return "Magic Eden";
  }
  /**
   * Create instance of `MagicEdenWallet`
   *
   * @param options - The `options` object contains the following properties:
   * ### clientId (recommended)
   *
   * Provide `clientId` to use the thirdweb RPCs for given `chains`
   *
   * You can create a client ID for your application from [thirdweb dashboard](https://thirdweb.com/create-api-key).
   *
   * ### chains (optional)
   * Provide an array of chains you want to support.
   *
   * Must be an array of `Chain` objects, from the [`@thirdweb-dev/chains`](https://www.npmjs.com/package/\@thirdweb-dev/chains) package.
   *
   * Defaults to our [default chains](/react/react.thirdwebprovider#default-chains).
   *
   * ### dappMetadata (optional)
   * Information about your app that the wallet will display when your app tries to connect to it.
   *
   * Must be an object containing `name`, `url`, and optionally `description` and `logoUrl` properties.
   *
   * ```javascript
   * import { MagicEdenWallet } from "@thirdweb-dev/wallets";
   *
   * const wallet = new MagicEdenWallet({
   *   dappMetadata: {
   *     name: "thirdweb powered dApp",
   *     url: "https://thirdweb.com",
   *     description: "thirdweb powered dApp",
   *     logoUrl: "https://thirdweb.com/favicon.ico",
   *   },
   * });
   * ```
   */
  constructor(options) {
    super(_MagicEdenWallet.id, options);
    this.isInjected = !!getInjectedMagicEdenProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        MagicEdenConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-magic-eden.browser.esm-6UEZ3IM4.js");
      const connector = new MagicEdenConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(MagicEdenWallet, "id", walletIds.magicEden);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_contracts3 = __toESM(require_dist4());
init_dist();
var import_utils5 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "thirdweb Smart Account",
        description: "thirdweb Smart Account",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    this._wcMetadata = defaultWCReceiverConfig.walletConnectWalletMetadata;
    this._core = new bn({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    });
  }
  async init() {
    this._wcWallet = await ie4.init({
      core: this._core,
      metadata: this._wcMetadata
    });
    const sessions = this._wcWallet.getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      this._session = sessions[keys[0]];
    }
    this._setupWalletConnectEventsListeners();
  }
  async connectApp(wcUri) {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await this._wcWallet.core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = this._activeProposal;
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    this._session = await this._wcWallet.approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    });
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = this._activeProposal;
    await this._wcWallet.rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a, _b;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      params,
      id
    } = this._activeRequestEvent;
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = this._getSignParamsMessage(request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = this._wcWallet) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      id
    } = this._activeRequestEvent;
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = this._wcWallet.getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!this._session) {
      return Promise.resolve();
    }
    const params = {
      topic: this._session.topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.disconnectSession(params);
  }
  _setupWalletConnectEventsListeners() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this._wcWallet.on("session_proposal", (proposal) => {
      this._activeProposal = proposal;
      this.emit("session_proposal", {
        proposer: {
          metadata: proposal.params.proposer.metadata
        }
      });
    });
    this._wcWallet.on("session_delete", (session) => {
      this._session = void 0;
      this._activeProposal = void 0;
      this.emit("session_delete", {
        topic: session.topic
      });
    });
    this._wcWallet.on("session_request", async (requestEvent) => {
      if (!this._session) {
        return;
      }
      const {
        params: requestParams
      } = requestEvent;
      const {
        request
      } = requestParams;
      const {
        params
      } = request;
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          this._activeRequestEvent = requestEvent;
          const message = params[0];
          const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
          const paramsCopy = [...params];
          paramsCopy[0] = decodedMessage;
          this.emit("session_request", {
            topic: this._session.topic,
            params: paramsCopy,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          this._activeRequestEvent = requestEvent;
          this.emit("session_request", {
            topic: this._session.topic,
            params: requestEvent.params.request.params,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        default:
          throw new Error(`WCV2.Method not supported: ${request.method}`);
      }
    });
  }
  /**
   * Gets message from various signing request methods by filtering out
   * a value that is not an address (thus is a message).
   * If it is a hex string, it gets converted to utf8 string
   */
  _getSignParamsMessage(params) {
    const message = params.filter((p4) => !utils_exports.isAddress(p4))[0] || "";
    if (utils_exports.isHexString(message)) {
      return utils_exports.toUtf8String(message);
    }
    return message;
  }
};

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  BloctoWallet,
  EmbeddedWallet,
  MetaMaskWallet,
  OKXWallet,
  CoreWallet,
  OneKeyWallet,
  CryptoDefiWallet,
  RabbyWallet,
  Coin98Wallet,
  getInjectedCoinbaseProvider,
  EngineSigner,
  EngineWallet,
  PaperWallet,
  CoinbaseWallet,
  EthersWallet,
  FrameWallet,
  ImTokenWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  XDEFIWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  MagicEdenWallet,
  LocalStorage,
  createLocalStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
//# sourceMappingURL=chunk-KIPALCAW.js.map
