import{C as b,_ as C,cC as D,cD as A,aw as L,ay as R,B as o,bV as T,cE as k,a as v,cF as _,b7 as d,bI as E,cG as B,cH as N}from"./index-CBGS744k.js";import{H as z}from"./http-rpc-client-0a079e80.browser.esm-BVSRZYKg.js";const u=5e4,g=113,M={Transaction:[{name:"txType",type:"uint256"},{name:"from",type:"uint256"},{name:"to",type:"uint256"},{name:"gasLimit",type:"uint256"},{name:"gasPerPubdataByteLimit",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymaster",type:"uint256"},{name:"nonce",type:"uint256"},{name:"value",type:"uint256"},{name:"data",type:"bytes"},{name:"factoryDeps",type:"bytes32[]"},{name:"paymasterInput",type:"bytes"}]};class y extends L{constructor(e,t){super(),this.signer=e,R.defineReadOnly(this,"provider",e.provider),this.httpRpcClient=t}async getAddress(){return await this.signer.getAddress()}async signMessage(e){return await this.signer.signMessage(e)}async signTransaction(e){return await this.signer.signTransaction(e)}connect(e){return new y(this.signer.connect(e),this.httpRpcClient)}_signTypedData(e,t,r){return this.signer._signTypedData(e,t,r)}async sendTransaction(e){return await this.sendZkSyncTransaction(e)}async sendZkSyncTransaction(e){var l,P,w,f,x,I,S,G;let t=await this.populateTransaction(e);if(!t.chainId)throw new Error("ChainId is required to send a ZkSync transaction");if(!this.provider)throw new Error("Provider is required to send a ZkSync transaction");const r=await this.getAddress(),c=o.from(t.gasLimit||await this.provider.estimateGas(t)).mul(3),s=o.from(t.gasPrice||await this.provider.getGasPrice()).mul(2);t.maxFeePerGas?t.maxFeePerGas=t.maxFeePerGas.mul(2):t.maxFeePerGas=s,t.maxPriorityFeePerGas?t.maxPriorityFeePerGas=t.maxPriorityFeePerGas.mul(2):t.maxPriorityFeePerGas=s,t={...t,from:r,gasLimit:c,gasPrice:s,chainId:(await this.provider.getNetwork()).chainId,nonce:await this.provider.getTransactionCount(r),type:113,value:BigInt(0)};const n=await((l=this.httpRpcClient)==null?void 0:l.zkPaymasterData(t));t.customData={gasPerPubdata:u,factoryDeps:[],paymasterParams:{paymaster:n.paymaster,paymasterInput:n.paymasterInput}};const m={txType:g,from:BigInt(t.from||await this.getAddress()).toString(),to:BigInt(t.to||"0x0").toString(),gasLimit:t.gasLimit?Number(t.gasLimit):0,gasPerPubdataByteLimit:u,maxFeePerGas:o.from(t.maxFeePerGas).toNumber(),maxPriorityFeePerGas:o.from(t.maxPriorityFeePerGas).toNumber(),paymaster:BigInt(n.paymaster).toString(),nonce:o.from(t.nonce).toNumber(),value:o.from(t.value).toNumber(),data:t.data||"0x",factoryDeps:[],paymasterInput:T(n.paymasterInput)},a=await this._signTypedData({name:"zkSync",version:"2",chainId:t.chainId},M,m),i=this.serialize(t,a),h={from:((P=t.from)==null?void 0:P.toString())||await this.getAddress(),to:((w=t.to)==null?void 0:w.toString())||"",gas:((f=t.gasLimit)==null?void 0:f.toString())||"",maxFeePerGas:((x=t.maxFeePerGas)==null?void 0:x.toString())||"0",maxPriorityFeePerGas:((I=t.maxPriorityFeePerGas)==null?void 0:I.toString())||"0",signedTransaction:i,paymaster:n.paymaster},F=(await((S=this.httpRpcClient)==null?void 0:S.zkBroadcastTransaction(h))).transactionHash;return await((G=this.provider)==null?void 0:G.getTransaction(F))}serialize(e,t){if(!e.customData&&e.type!==g)return k(e,t);if(!e.chainId)throw Error("Transaction chainId isn't set!");function r(i,h){const p=d(o.from(i).toHexString());if(p.length>32)throw new Error(`Invalid length for ${h}!`);return p}if(!e.from)throw new Error("Explicitly providing `from` field is required for EIP712 transactions!");const c=e.from,s=e.customData??{},n=e.maxFeePerGas||e.gasPrice||0,m=e.maxPriorityFeePerGas||n,a=[r(e.nonce||0,"nonce"),r(m,"maxPriorityFeePerGas"),r(n,"maxFeePerGas"),r(e.gasLimit||0,"gasLimit"),e.to?v(e.to):"0x",r(e.value||0,"value"),e.data||"0x"];if(t){const i=_(t);a.push(r(i.recoveryParam,"recoveryParam")),a.push(d(i.r)),a.push(d(i.s))}else a.push(r(e.chainId,"chainId")),a.push("0x"),a.push("0x");if(a.push(r(e.chainId,"chainId")),a.push(v(c)),a.push(r(s.gasPerPubdata||u,"gasPerPubdata")),a.push((s.factoryDeps??[]).map(i=>E(i))),s.customSignature&&T(s.customSignature).length===0)throw new Error("Empty signatures are not supported!");return a.push(s.customSignature||"0x"),s.paymasterParams?a.push([s.paymasterParams.paymaster,E(s.paymasterParams.paymasterInput)]):a.push([]),B([[g],N(a)])}}class U extends b{constructor(e){super(),C(this,"chainId",1),this.config=e}async connect(e){if(this.personalWallet=e.personalWallet,this.chainId=await(await this.personalWallet.getSigner()).getChainId(),!await D(this.chainId))throw new Error("Invalid zksync chain id");const t=this.config.bundlerUrl||`https://${this.chainId}.bundler.thirdweb.com`,r=this.config.entryPointAddress||A;return this.httpRpcClient=new z(t,r,this.chainId,this.config.clientId,this.config.secretKey),this.getAddress()}disconnect(){throw new Error("Method not implemented.")}async getAddress(){return(await this.getSigner()).getAddress()}async getSigner(){if(!this.personalWallet)throw new Error("Wallet not connected");return new y(await this.personalWallet.getSigner(),this.httpRpcClient)}switchChain(e){throw new Error("Method not implemented.")}isConnected(){return Promise.resolve(!!this.personalWallet)}setupListeners(){throw new Error("Method not implemented.")}updateChains(e){throw new Error("Method not implemented.")}async getProvider(){if(!this.getSigner())throw new Error("Personal wallet not connected");const e=await this.getSigner();if(!e.provider)throw new Error("Provider not found");return e.provider}}export{U as ZkSyncConnector};
