var B=Object.defineProperty;var N=(o,t,a)=>t in o?B(o,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):o[t]=a;var d=(o,t,a)=>N(o,typeof t!="symbol"?t+"":t,a);import{a5 as k,aK as W,o as y,a2 as M,T as u,a9 as F,X as L,t as v,aL as D,aM as U,aN as b,B as x,c as S,ai as O,aO as z,aP as I}from"./index-CBGS744k.js";import{h as g}from"./contract-appuri-5c40af52.browser.esm-ulK3nCZT.js";import{C as A}from"./setErc20Allowance-7f76f677.browser.esm-CIQGEfPa.js";import{g as T,f as V}from"./QueryParams-32a56510.browser.esm-DCGbhPjt.js";import{a as q}from"./index-BzgVYt3b.js";class G{constructor(t,a){d(this,"featureName",k.name);d(this,"setDefaultRoyaltyInfo",y(async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),r=await this.metadata._parseAndUploadMetadata(e);if(g("setContractURI",this.contractWrapper)){const c=new M(this.contractWrapper),n=[c.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),c.encode("setContractURI",[r])];return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:h=>({receipt:h,data:()=>this.getDefaultRoyaltyInfo()})})}else throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));d(this,"setTokenRoyaltyInfo",y(async(t,a)=>{const e=W.parse(a);return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:r=>({receipt:r,data:()=>this.getDefaultRoyaltyInfo()})})}));this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return W.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return W.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}}class J{constructor(t,a,e,r){d(this,"createDelayedRevealBatch",y(async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const c=await this.storage.uploadBatch([A.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),n=T(c),h=await this.nextTokenIdToMintFn(),i=await this.storage.uploadBatch(a.map(p=>A.parse(p)),{onProgress:r==null?void 0:r.onProgress,rewriteFileNames:{fileStartNumber:h.toNumber()}}),s=T(i),l=await this.contractWrapper.read("getBaseURICount",[]),R=await this.hashDelayRevealPassword(l,e),_=await this.contractWrapper.read("encryptDecrypt",[v(s),R]);let w;if(await this.isLegacyContract())w=_;else{const p=await this.contractWrapper.getChainID(),f=D(["bytes","bytes","uint256"],[v(s),R,p]);w=U.encode(["bytes","bytes32"],[_,f])}return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[i.length,n.endsWith("/")?n:`${n}/`,w],parse:p=>{const f=this.contractWrapper.parseLogs("TokensLazyMinted",p==null?void 0:p.logs),E=f[0].args.startTokenId,P=f[0].args.endTokenId,C=[];for(let m=E;m.lte(P);m=m.add(1))C.push({id:m,receipt:p});return C}})}));d(this,"reveal",y(async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const r=await this.contractWrapper.callStatic().reveal(t,e);if(!r.includes("://")||!r.endsWith("/"))throw new Error("invalid password")}catch{throw new Error("invalid password")}return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}));this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(s=>{if(g("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[s]);if(g("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[s]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),r=e.slice(0,e.length-1),c=await Promise.all(Array.from([0,...r]).map(s=>this.getNftMetadata(s.toString()))),n=await this.isLegacyContract(),i=(await Promise.all(Array.from([...e]).map(s=>n?this.getLegacyEncryptedData(s):this.contractWrapper.read("encryptedData",[s])))).map(s=>b(s)>0?n?s:U.decode(["bytes","bytes32"],s)[0]:s);return c.map((s,l)=>({batchId:x.from(l),batchUri:s.uri,placeholderMetadata:s})).filter((s,l)=>b(i[l])>0)}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return D(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return V(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(g("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch{return!1}return!1}async getLegacyEncryptedData(t){const a=(await S(async()=>{const{default:c}=await import("./IDelayedRevealDeprecated-JM0269jw.js");return{default:c}},[])).default,r=await new O(this.contractWrapper.address,a,this.contractWrapper.getProvider()).functions.encryptedBaseURI(t);return r.length>0?r[0]:"0x"}}async function Q(o,t,a,e,r){let c={};const n=e||I,i=(await z(o.getProvider(),t,n)).mul(a);return i.gt(0)&&(n===I?c={value:i}:n!==I&&r&&await q(o,n,i,a,0)),c}class tt{constructor(t){d(this,"featureName",F.name);d(this,"set",y(async t=>{const a=await L(t);return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})}));this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}}export{G as C,J as D,tt as a,Q as c};
