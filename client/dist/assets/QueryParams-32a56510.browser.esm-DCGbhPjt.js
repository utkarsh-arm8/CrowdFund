const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CBGS744k.js","assets/index-Djp-cZ_d.css"])))=>i.map(i=>d[i]);
import{bV as w,bG as m,B as c,ba as y,c as l,ai as d}from"./index-CBGS744k.js";import{a as _,C as E}from"./setErc20Allowance-7f76f677.browser.esm-CIQGEfPa.js";const C=w("0x80ac58cd"),R=w("0xd9b67a26"),b={name:"Failed to load NFT metadata"};async function I(t,a,e){if(a.startsWith("data:application/json;base64")&&typeof m<"u"){const s=a.split(",")[1],i=JSON.parse(m.from(s,"base64").toString("utf-8"));return _.parse({...i,id:c.from(t).toString(),uri:a})}const r=a.replace("{id}",y(c.from(t).toHexString(),32).slice(2));let n;try{n=await e.downloadJSON(r)}catch{const i=a.replace("{id}",c.from(t).toString());try{n=await e.downloadJSON(i)}catch{console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:a})} -- falling back to default metadata`),n=b}}return _.parse({...n,id:c.from(t).toString(),uri:a})}async function S(t,a,e,r){let n;const s=(await l(async()=>{const{default:o}=await import("./IERC165-ODxXmlQV.js");return{default:o}},[])).default,i=new d(t,s,a),[p,g]=await Promise.all([i.supportsInterface(C),i.supportsInterface(R)]);if(p){const o=(await l(async()=>{const{default:f}=await import("./index-CBGS744k.js").then(u=>u.em);return{default:f}},__vite__mapDeps([0,1]))).default;n=await new d(t,o,a).tokenURI(e)}else if(g){const o=(await l(async()=>{const{default:f}=await import("./index-CBGS744k.js").then(u=>u.eo);return{default:f}},__vite__mapDeps([0,1]))).default;n=await new d(t,o,a).uri(e)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return n?I(e,n,r):_.parse({...b,id:c.from(e).toString(),uri:""})}async function A(t,a){return typeof t=="string"?t:await a.upload(E.parse(t))}async function x(t,a,e,r){if(T(t))return t;if(N(t))return await a.uploadBatch(t.map(s=>E.parse(s)),{rewriteFileNames:{fileStartNumber:e||0},onProgress:r==null?void 0:r.onProgress});throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function L(t){const a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${r}'`)}return a.replace(/\/$/,"")+"/"}function T(t){return t.find(a=>typeof a!="string")===void 0}function N(t){return t.find(a=>typeof a!="object")===void 0}const M=100;export{M as D,b as F,C as I,I as a,A as b,R as c,S as f,L as g,x as u};
